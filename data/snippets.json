[
  {
    "id": "193a1eff-8d79-4708-a78e-ca1e2e5894c2",
    "title": "Funciones hlsl mas usadas",
    "created_at": "2025-04-01 21:48:57.925052+00",
    "content": "//==============================\n// FUNCIONES HLSL M\u00c1S USADAS\n//==============================\n\n//----- MATH B\u00c1SICA -----\nfloat a = abs(-2.5);             // valor absoluto\nfloat b = ceil(1.3);             // redondea hacia arriba\nfloat c = floor(1.9);            // redondea hacia abajo\nfloat d = frac(3.75);            // parte decimal (0.75)\nfloat e = fmod(5.2, 2.0);        // m\u00f3dulo decimal (1.2)\nfloat f = clamp(1.5, 0.0, 1.0);  // limita entre 0 y 1\nfloat g = lerp(0.0, 1.0, 0.5);   // interpolaci\u00f3n lineal (0.5)\nfloat h = min(2.0, 3.0);         // 2.0\nfloat i = max(5.0, 4.0);         // 5.0\nfloat j = saturate(x);           // clamp entre 0 y 1\n\n//----- RAMPAS / CONTROL -----\nfloat s1 = step(0.5, 0.3);                 // 0.0 (x < edge)\nfloat s2 = smoothstep(0.2, 0.8, 0.5);      // rampa suave\nfloat s3 = sign(-5.0);                     // -1\nfloat s4 = isnan(value);                  // 1 si es NaN\n\n//----- TRIGONOMETR\u00cdA -----\nfloat t1 = sin(3.14);\nfloat t2 = cos(0.0);\nfloat t3 = tan(1.0);\nfloat t4 = asin(1.0);\nfloat t5 = acos(0.0);\nfloat t6 = atan2(y, x); // \u00e1ngulo entre (x, y)\n\n//----- POTENCIAS Y LOGARITMOS -----\nfloat p1 = pow(2.0, 3.0);  // 8\nfloat p2 = sqrt(25.0);     // 5\nfloat p3 = rsqrt(25.0);    // 1 / sqrt(25) = 0.2\nfloat p4 = exp(1.0);       // e^1\nfloat p5 = log(2.71828);   // loge\n\n//----- VECTORES -----\nfloat len = length(float3(1, 2, 2));           // magnitud\nfloat dist = distance(a, b);                   // distancia\nfloat3 norm = normalize(float3(1, 2, 3));      // vector normalizado\nfloat dp = dot(a, b);                          // producto punto\nfloat3 cr = cross(float3(1,0,0), float3(0,1,0));// producto cruzado\nfloat3 ref = reflect(-viewDir, normal);        // reflexi\u00f3n\nfloat3 refr = refract(viewDir, normal, 1.0);   // refracci\u00f3n\nfloat3 face = faceforward(n, i, ng);           // orienta una normal hacia la c\u00e1mara\n\n//----- TEXTURAS -----\nTexture2D tex : register(t0);\nSamplerState samp : register(s0);\nfloat4 col = tex.Sample(samp, uv);                 // sampleo normal\nfloat4 colBias = tex.SampleBias(samp, uv, -1.0);   // con bias\nfloat4 colGrad = tex.SampleGrad(samp, uv, dx, dy); // con gradiente manual\nfloat4 colLOD = tex.SampleLevel(samp, uv, 2.0);     // sample mip espec\u00edfico\nfloat2 texSize; tex.GetDimensions(texSize.x, texSize.y);\n\n//----- COLORES -----\nfloat3 hsv = float3(0.6, 1.0, 1.0); // ejemplo color HSV\nfloat3 rgb = hsv2rgb(hsv);          // si defines t\u00fa mismo esta funci\u00f3n\nfloat3 gray = float3(0.5.xxx);      // gris neutro\n\n//----- UV / ANIMACI\u00d3N -----\nfloat wave = sin(uv.x * 10.0 + time * 5.0);    // animaci\u00f3n senoidal\nfloat2 scrollUV = uv + time * 0.1;            // scrolling\nfloat2 polar = float2(cos(a), sin(a));        // direcci\u00f3n circular\nfloat ripple = sin(distance(uv, center) * 20.0 - time * 5.0); // onda radial\n\n//----- RUIDO B\u00c1SICO -----\nfloat hash(float2 p)\n{\n    return frac(sin(dot(p, float2(127.1, 311.7))) * 43758.5453);\n}\n\nfloat noise(float2 uv)\n{\n    float2 i = floor(uv);\n    float2 f = frac(uv);\n\n    float a = hash(i);\n    float b = hash(i + float2(1, 0));\n    float c = hash(i + float2(0, 1));\n    float d = hash(i + float2(1, 1));\n\n    float2 u = f * f * (3.0 - 2.0 * f); // fade\n\n    return lerp(lerp(a, b, u.x), lerp(c, d, u.x), u.y);\n}\n\n//----- PARALLAX OFFSET (b\u00e1sico) -----\nfloat height = heightMap.Sample(samp, uv).r;\nfloat2 parallaxOffset = viewDirTS.xy * height * intensity;\nfloat2 uvOffset = uv + parallaxOffset;",
    "type": "c\u00f3digo"
  },
  {
    "id": "245ebab7-793f-4bda-b6c8-05ac1fcec3e7",
    "title": "Postprocess",
    "created_at": "2025-04-02 06:24:00.383718+00",
    "content": "//=========================================================================\n// VFX/TECH ARTISTS - HLSL LIBRARY 2 + 5 + 6 + 9\n// Shapes Procedurales + TBN/Parallax + Material FX + Post FX\n//=========================================================================\n\n#ifndef VFX_MATERIAL_UTILS_INCLUDED\n#define VFX_MATERIAL_UTILS_INCLUDED\n\n//=========================================================================\n// 2. SHAPES PROCEDURALES (sin texturas)\n//=========================================================================\n\n// C\u00edrculo centrado en UV\nfloat Circle(float2 uv, float2 center, float radius)\n{\n    float d = distance(uv, center);\n    return step(d, radius);\n}\n\n// C\u00edrculo suave\nfloat SoftCircle(float2 uv, float2 center, float radius, float softness)\n{\n    float d = distance(uv, center);\n    return smoothstep(radius, radius - softness, d);\n}\n\n// Estrella de 5 puntas\nfloat Star5(float2 uv, float2 center, float size, float sharpness)\n{\n    float2 p = uv - center;\n    float a = atan2(p.y, p.x);\n    float r = length(p);\n    float star = cos(5.0 * a) * sharpness + 0.5;\n    return smoothstep(star * size, star * size - 0.01, r);\n}\n\n// Pol\u00edgono",
    "type": "c\u00f3digo"
  },
  {
    "id": "57b07ed6-96c1-41c8-8ee8-16b52c5ab250",
    "title": "Masks library",
    "created_at": "2025-04-01 21:59:41.320255+00",
    "content": "//===========================================================\n// HLSL MASK LIBRARY - EXTENDED\n//===========================================================\n\n#ifndef VFX_MASKS_INCLUDED\n#define VFX_MASKS_INCLUDED\n\n//-----------------------------------------------------------\n// UTILIDADES B\u00c1SICAS\n//-----------------------------------------------------------\n\n// Clamp suave entre 0\u20131\nfloat Saturate(float x) {\n    return clamp(x, 0.0, 1.0);\n}\n\n// Interpolaci\u00f3n suave Hermite (usado en soft masks)\nfloat SmoothStep(float edge0, float edge1, float x) {\n    float t = saturate((x - edge0) / (edge1 - edge0));\n    return t * t * (3.0 - 2.0 * t);\n}\n\n// Pulse entre dos rangos\nfloat Pulse(float edge0, float edge1, float x) {\n    return step(edge0, x) - step(edge1, x);\n}\n\n// Distancia UV al centro\nfloat DistToCenter(float2 uv, float2 center) {\n    return distance(uv, center);\n}\n\nfloat DistToEdge(float2 uv) {\n    float2 d = min(uv, 1.0 - uv);\n    return min(d.x, d.y);\n}\n\n//-----------------------------------------------------------\n// FORMAS B\u00c1SICAS\n//-----------------------------------------------------------\n\n// M\u00e1scara circular\nfloat CircleMask(float2 uv, float2 center, float radius) {\n    float d = distance(uv, center);\n    return step(d, radius);\n}\n\n// C\u00edrculo suave (falloff)\nfloat SoftCircleMask(float2 uv, float2 center, float radius, float softness) {\n    float d = distance(uv, center);\n    return smoothstep(radius, radius - softness, d);\n}\n\n// Rect\u00e1ngulo centrado (sin rotaci\u00f3n)\nfloat BoxMask(float2 uv, float2 center, float2 size) {\n    float2 diff = abs(uv - center);\n    float2 halfSize = size * 0.5;\n    return step(diff.x, halfSize.x) * step(diff.y, halfSize.y);\n}\n\n// Rect\u00e1ngulo con bordes suaves\nfloat SoftBoxMask(float2 uv, float2 center, float2 size, float softness) {\n    float2 diff = abs(uv - center);\n    float2 halfSize = size * 0.5;\n    float2 edge = smoothstep(halfSize, halfSize - softness, diff);\n    return edge.x * edge.y;\n}\n\n// L\u00ednea horizontal con grosor\nfloat LineMask(float2 uv, float y, float thickness) {\n    return step(abs(uv.y - y), thickness * 0.5);\n}\n\n// L\u00ednea suave\nfloat SoftLineMask(float2 uv, float y, float thickness, float softness) {\n    float d = abs(uv.y - y);\n    return smoothstep(thickness * 0.5 + softness, thickness * 0.5, d);\n}\n\n//-----------------------------------------------------------\n// FORMAS AVANZADAS\n//-----------------------------------------------------------\n\n// Anillo\nfloat RingMask(float2 uv, float2 center, float radius, float thickness) {\n    float d = distance(uv, center);\n    return step(abs(d - radius), thickness * 0.5);\n}\n\n// Anillo suave\nfloat SoftRingMask(float2 uv, float2 center, float radius, float thickness, float softness) {\n    float d = distance(uv, center);\n    float outer = smoothstep(radius + thickness * 0.5, radius + thickness * 0.5 - softness, d);\n    float inner = smoothstep(radius - thickness * 0.5, radius - thickness * 0.5 + softness, d);\n    return outer * inner;\n}\n\n// M\u00e1scara radial (de centro a borde)\nfloat RadialGradient(float2 uv, float2 center) {\n    return saturate(distance(uv, center));\n}\n\n// M\u00e1scara radial invertida\nfloat InvertedRadial(float2 uv, float2 center) {\n    return 1.0 - RadialGradient(uv, center);\n}\n\n// M\u00e1scara tipo borde\nfloat EdgeMask(float2 uv, float thickness) {\n    float edge = min(min(uv.x, 1.0 - uv.x), min(uv.y, 1.0 - uv.y));\n    return step(thickness, edge);\n}\n\n//-----------------------------------------------------------\n// M\u00c1SCARAS ANIMADAS\n//-----------------------------------------------------------\n\n// Wipe horizontal\nfloat HorizontalWipe(float2 uv, float progress) {\n    return step(uv.x, progress);\n}\n\n// Wipe radial (reloj)\nfloat RadialWipe(float2 uv, float2 center, float progress) {\n    float2 dir = normalize(uv - center);\n    float angle = atan2(dir.y, dir.x) / (2.0 * 3.14159) + 0.5;\n    return step(angle, progress);\n}\n\n// M\u00e1scara con ruido\nfloat NoisyMask(float2 uv, float noiseValue, float threshold, float softness) {\n    return smoothstep(threshold, threshold - softness, noiseValue);\n}\n\n//-----------------------------------------------------------\n// M\u00c1SCARAS EN ESPACIO WORLD / PERSONALIZADO\n//-----------------------------------------------------------\n\n// M\u00e1scara basada en altura (eje Y)\nfloat HeightMask(float3 worldPos, float height, float falloff) {\n    return smoothstep(height, height - falloff, worldPos.y);\n}\n\n// M\u00e1scara por proyecci\u00f3n planar Y\nfloat PlanarYMask(float3 worldPos, float centerY, float range, float falloff) {\n    float d = abs(worldPos.y - centerY);\n    return smoothstep(range, range - falloff, d);\n}\n\n// M\u00e1scara por distancia a un punto en mundo\nfloat WorldDistanceMask(float3 worldPos, float3 worldCenter, float radius, float softness) {\n    float d = distance(worldPos, worldCenter);\n    return smoothstep(radius, radius - softness, d);\n}\n\n//-----------------------------------------------------------\n// M\u00c1SCARA MODULADA / COMBINADA\n//-----------------------------------------------------------\n\n// Combine (AND l\u00f3gico)\nfloat CombineAND(float a, float b) {\n    return a * b;\n}\n\n// Combine (OR l\u00f3gico)\nfloat CombineOR(float a, float b) {\n    return saturate(a + b);\n}\n\n// Combine (XOR l\u00f3gico visual)\nfloat CombineXOR(float a, float b) {\n    return abs(a - b);\n}\n\n// Interpolaci\u00f3n entre dos m\u00e1scaras\nfloat BlendMasks(float a, float b, float blend) {\n    return lerp(a, b, blend);\n}\n\n#endif // VFX_MASKS_INCLUDED",
    "type": "c\u00f3digo"
  },
  {
    "id": "5d95dfe9-d816-4ee5-8391-05d69f915e50",
    "title": "Time library",
    "created_at": "2025-04-02 06:12:08.567279+00",
    "content": "//===========================================================\n// TIME UTILITY LIBRARY - VFX / TECHNICAL ARTISTS\n// Usando i.fTime como base de tiempo\n//===========================================================\n\n#ifndef TIME_UTILS_INCLUDED\n#define TIME_UTILS_INCLUDED\n\n//-----------------------------------------------------------\n// Tiempo normalizado c\u00edclico [0 \u2192 1]\n// Ideal para loops de animaci\u00f3n\n//-----------------------------------------------------------\nfloat Time01(float time, float speed)\n{\n    return frac(time * speed);\n}\n\n//-----------------------------------------------------------\n// Tiempo senoidal suave entre 0 y 1\n// Oscila suavemente - ideal para efectos respirantes o pulsantes\n//-----------------------------------------------------------\nfloat SineTime01(float time, float speed)\n{\n    return sin(time * speed) * 0.5 + 0.5;\n}\n\n//-----------------------------------------------------------\n// PingPong (tri\u00e1ngulo) entre 0 y 1\n// \u00datil para efectos que deben ir y volver\n//-----------------------------------------------------------\nfloat PingPong(float time, float speed)\n{\n    return abs(frac(time * speed) * 2.0 - 1.0);\n}\n\n//-----------------------------------------------------------\n// Onda triangular suavizada (para parpadeos, loops sim\u00e9tricos)\n//-----------------------------------------------------------\nfloat TriangleWave(float time, float speed)\n{\n    return abs(frac(time * speed + 0.5) * 2.0 - 1.0);\n}\n\n//-----------------------------------------------------------\n// Pulso repetitivo (ideal para flashes, glitches...)\n// Devuelve 1 solo durante un tramo del ciclo\n//-----------------------------------------------------------\nfloat PulseLoop(float time, float speed, float width)\n{\n    float t = frac(time * speed);\n    return step(t, width); // Ejemplo: width = 0.1 \u2192 pulso breve\n}\n\n//-----------------------------------------------------------\n// Oscilador entre dos valores\n//-----------------------------------------------------------\nfloat Oscillate(float minVal, float maxVal, float time, float speed)\n{\n    float t = SineTime01(time, speed);\n    return lerp(minVal, maxVal, t);\n}\n\n//-----------------------------------------------------------\n// Ramp-Up Loop: sube de 0 a 1, luego se queda en 1 por un tiempo\n//-----------------------------------------------------------\nfloat RampHoldLoop(float time, float speed, float holdRatio)\n{\n    float t = frac(time * speed);\n    float rise = 1.0 - holdRatio;\n    return t < rise ? t / rise : 1.0;\n}\n\n//-----------------------------------------------------------\n// Delay temporal por fragmento (\u00fatil para efectos secuenciales)\n//-----------------------------------------------------------\nfloat TimeWithDelay(float time, float delay)\n{\n    return max(0.0, time - delay);\n}\n\n//-----------------------------------------------------------\n// Fase desincronizada por UV o World Position\n// Perfecto para que cada p\u00edxel haga el efecto en distinto momento\n//-----------------------------------------------------------\nfloat DesyncByCoord(float2 uv, float time, float speed, float spread)\n{\n    float offset = frac(dot(uv, float2(12.9898, 78.233))) * spread;\n    return frac((time + offset) * speed);\n}\n\n#endif // TIME_UTILS_INCLUDED",
    "type": "c\u00f3digo"
  },
  {
    "id": "66607c43-d45b-4b71-9131-5fd1578fbbe3",
    "title": "Code Test",
    "created_at": "2025-04-01 20:34:40.582093+00",
    "content": "// Transformamos la direcci\u00f3n del visor de world space a tangent space\nfloat3 viewDirTS = mul(TBN, viewDirWS);\n\n// Calculamos un factor de escala basado en cu\u00e1n inclinado es el \u00e1ngulo de visi\u00f3n\n// viewDirTS.z es cu\u00e1nto \"miramos de frente\"; si es bajo, estamos mirando en \u00e1ngulo\n// En lugar de dividir por z, usamos (1 - z) como multiplicador para simular ese efecto\nfloat scale = saturate(1.0 - viewDirTS.z); // saturate asegura que el valor est\u00e9 entre 0 y 1\n\n// Calculamos el desplazamiento de parallax multiplicando por ese factor\nfloat2 parallaxOffset = viewDirTS.xy * height * height_intensity * scale;\n\n// Sumamos el desplazamiento a las UV originales\nreturn uv + parallaxOffset;",
    "type": "c\u00f3digo"
  },
  {
    "id": "7cc47bd6-fac6-4cde-8a82-772d4c0bf660",
    "title": "Vertex shader toolkit",
    "created_at": "2025-04-02 06:27:08.30053+00",
    "content": "//=========================================================================\n// VERTEX TRANSFORM UTILITY LIBRARY - VFX / TECHNICAL ARTISTS\n//=========================================================================\n\n#ifndef VFX_VERTEX_TRANSFORMS_INCLUDED\n#define VFX_VERTEX_TRANSFORMS_INCLUDED\n\n//-----------------------------------------------------------\n// ROTACIONES\n//-----------------------------------------------------------\n\n// Rotaci\u00f3n en el eje Z\nfloat2 Rotate2D(float2 pos, float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return float2(pos.x * c - pos.y * s, pos.x * s + pos.y * c);\n}\n\n// Rotaci\u00f3n alrededor de eje arbitrario\nfloat3 RotateAroundAxis(float3 pos, float3 axis, float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    float3x3 R =\n    {\n        c + axis.x * axis.x * (1 - c),\n        axis.x * axis.y * (1 - c) - axis.z * s,\n        axis.x * axis.z * (1 - c) + axis.y * s,\n\n        axis.y * axis.x * (1 - c) + axis.z * s,\n        c + axis.y * axis.y * (1 - c),\n        axis.y * axis.z * (1 - c) - axis.x * s,\n\n        axis.z * axis.x * (1 - c) - axis.y * s,\n        axis.z * axis.y * (1 - c) + axis.x * s,\n        c + axis.z * axis.z * (1 - c)\n    };\n    return mul(R, pos);\n}\n\n// Rotaci\u00f3n alrededor de un pivote\nfloat3 RotateAroundPivot(float3 pos, float3 pivot, float3 axis, float angle)\n{\n    float3 local = pos - pivot;\n    float3 rotated = RotateAroundAxis(local, axis, angle);\n    return rotated + pivot;\n}\n\n//-----------------------------------------------------------\n// ESCALADO Y TRANSLACI\u00d3N\n//-----------------------------------------------------------\n\nfloat3 ScaleAroundPivot(float3 pos, float3 pivot, float3 scale)\n{\n    return (pos - pivot) * scale + pivot;\n}\n\nfloat3 Translate(float3 pos, float3 offset)\n{\n    return pos + offset;\n}\n\n//-----------------------------------------------------------\n// DEFORMACIONES / OSCILACIONES\n//-----------------------------------------------------------\n\n// Onda senoidal en eje Y\nfloat3 SinWaveY(float3 pos, float frequency, float amplitude, float time)\n{\n    pos.y += sin(pos.x * frequency + time) * amplitude;\n    return pos;\n}\n\n// Wobble XYZ (3D sin wave)\nfloat3 Wobble(float3 pos, float3 freq, float3 amp, float time)\n{\n    pos += sin(pos * freq + time) * amp;\n    return pos;\n}\n\n// Morph entre dos posiciones\nfloat3 MorphPosition(float3 posA, float3 posB, float factor)\n{\n    return lerp(posA, posB, factor);\n}\n\n// Stretch hacia arriba con falloff (\u00fatil para FX tipo \"grow\")\nfloat3 VerticalStretch(float3 pos, float heightLimit, float intensity)\n{\n    float t = saturate(pos.y / heightLimit);\n    pos.y += t * intensity;\n    return pos;\n}\n\n//-----------------------------------------------------------\n// NOISE VERTEX OFFSET\n//-----------------------------------------------------------\n\n// Hash r\u00e1pido\nfloat Hash21(float2 p)\n{\n    p = frac(p * float2(123.34, 456.21));\n    p += dot(p, p + 45.32);\n    return frac(p.x * p.y);\n}\n\n// Simple noise offset en Y\nfloat3 VertexNoiseOffset(float3 pos, float scale, float strength)\n{\n    float2 p = pos.xz * scale;\n    float noise = Hash21(p);\n    pos.y += (noise - 0.5) * strength;\n    return pos;\n}\n\n// Noise animado (ideal para fuego, lava, etc.)\nfloat3 VertexNoiseAnim(float3 pos, float scale, float strength, float time)\n{\n    float2 p = pos.xz * scale + time * 0.5;\n    float noise = Hash21(p);\n    pos.y += (noise - 0.5) * strength;\n    return pos;\n}\n\n//-----------------------------------------------------------\n// TAPER Y SHEAR\n//-----------------------------------------------------------\n\n// Taper: estrecha o ensancha seg\u00fan altura\nfloat3 TaperY(float3 pos, float height, float factor)\n{\n    float t = saturate(pos.y / height);\n    pos.xz *= lerp(1.0, factor, t);\n    return pos;\n}\n\n// Shear XZ basado en altura Y\nfloat3 ShearXZ(float3 pos, float height, float shearAmount)\n{\n    float t = saturate(pos.y / height);\n    pos.x += t * shearAmount;\n    pos.z += t * shearAmount;\n    return pos;\n}\n\n#endif // VFX_VERTEX_TRANSFORMS_INCLUDED",
    "type": "c\u00f3digo"
  },
  {
    "id": "b8e04b67-f75f-4f2b-8f7d-f0d42cb325b3",
    "title": "Parallax mapping basico",
    "created_at": "2025-04-01 21:43:35.177911+00",
    "content": "float height = heightTex.Sample(sampler, uv).r;\nfloat2 offset = viewDirTS.xy * height * intensity;\nfloat2 newUV = uv + offset;",
    "type": "c\u00f3digo"
  },
  {
    "id": "cd9d1012-6400-4faa-bc38-f565bec1c5e1",
    "title": "Solid Color",
    "created_at": "2025-04-01 21:41:35.893949+00",
    "content": "float4 PS_Main(float4 pos : SV_POSITION) : SV_TARGET\n{\n    return float4(1.0, 0.0, 0.0, 1.0); // Color rojo\n}",
    "type": "c\u00f3digo"
  },
  {
    "id": "d24e3da0-cf5e-4046-9c6c-ff17dd3e7102",
    "title": "Treshold",
    "created_at": "2025-04-01 21:42:33.145036+00",
    "content": "Texture2D maskTex : register(t0);\nSamplerState maskSampler : register(s0);\n\nfloat threshold = 0.5;\n\nfloat4 PS_Main(float4 pos : SV_POSITION, float2 uv : TEXCOORD0) : SV_TARGET\n{\n    float mask = maskTex.Sample(maskSampler, uv).r;\n    float masked = step(threshold, mask);\n    return float4(masked.xxx, 1.0); // Blanco si mayor a threshold\n}",
    "type": "c\u00f3digo"
  },
  {
    "id": "dd29ea9a-dd13-4574-8106-6089b3a8d59e",
    "title": "Distortion and geo",
    "created_at": "2025-04-02 06:22:24.051298+00",
    "content": "//=========================================================================\n// VFX/TECH ARTISTS - MEGA HLSL LIBRARY\n// Distorsi\u00f3n UV + Geometr\u00eda de Pantalla + Fresnel + Luz + Glitch FX\n//=========================================================================\n\n#ifndef VFX_MEGA_LIB_INCLUDED\n#define VFX_MEGA_LIB_INCLUDED\n\n//=========================================================================\n// 1. DISTORSI\u00d3N UV / PROCEDURAL WARP\n//=========================================================================\n\n// Scroll UV b\u00e1sico\nfloat2 ScrollUV(float2 uv, float2 direction, float speed, float time)\n{\n    return uv + direction * speed * time;\n}\n\n// Onda senoidal\nfloat2 SinWaveDistort(float2 uv, float frequency, float amplitude, float time)\n{\n    uv.y += sin(uv.x * frequency + time) * amplitude;\n    return uv;\n}\n\n// Onda radial (turbulencia circular)\nfloat2 RadialWaveDistort(float2 uv, float2 center, float freq, float amp, float time)\n{\n    float2 offset = uv - center;\n    float r = length(offset);\n    float angle = atan2(offset.y, offset.x);\n    r += sin(angle * freq + time) * amp;\n    return center + float2(cos(angle), sin(angle)) * r;\n}\n\n// Distorsi\u00f3n con ruido simple\nfloat Hash21(float2 p)\n{\n    p = frac(p * float2(123.34, 456.21));\n    p += dot(p, p + 45.32);\n    return frac(p.x * p.y);\n}\n\nfloat ValueNoise(float2 uv)\n{\n    float2 i = floor(uv);\n    float2 f = frac(uv);\n    float a = Hash21(i);\n    float b = Hash21(i + float2(1, 0));\n    float c = Hash21(i + float2(0, 1));\n    float d = Hash21(i + float2(1, 1));\n    float2 u = f * f * (3.0 - 2.0 * f);\n    return lerp(lerp(a, b, u.x), lerp(c, d, u.x), u.y);\n}\n\nfloat2 NoiseWarpUV(float2 uv, float scale, float strength, float time)\n{\n    float2 n = float2(\n        ValueNoise(uv * scale + float2(0, time)),\n        ValueNoise(uv * scale + float2(5.2, time + 1.0))\n    );\n    return uv + (n - 0.5) * strength;\n}\n\n//=========================================================================\n// 3. GEOMETR\u00cdA DE PANTALLA / UV TOOLS\n//=========================================================================\n\n// Coordenadas centradas (-1 a 1)\nfloat2 CenteredUV(float2 uv)\n{\n    return uv * 2.0 - 1.0;\n}\n\n// Distancia al centro\nfloat DistanceToCenter(float2 uv)\n{\n    return length(CenteredUV(uv));\n}\n\n// M\u00e1scara de borde (falloff hacia los lados)\nfloat EdgeMask(float2 uv, float thickness)\n{\n    float2 edge = min(uv, 1.0 - uv);\n    return smoothstep(thickness, 0.0, min(edge.x, edge.y));\n}\n\n// Coordenadas NDC (si se requiere)\nfloat2 NDCFromUV(float2 uv)\n{\n    return uv * 2.0 - 1.0;\n}\n\n// Mapa de direcci\u00f3n hacia el centro (vector unitario)\nfloat2 DirectionToCenter(float2 uv)\n{\n    return normalize(0.5 - uv);\n}\n\n//=========================================================================\n// 4. FRESNEL / CURVATURA\n//=========================================================================\n\n// Fresnel b\u00e1sico\nfloat FresnelBasic(float3 normal, float3 viewDir)\n{\n    return 1.0 - saturate(dot(normalize(normal), normalize(viewDir)));\n}\n\n// Fresnel con power y bias\nfloat FresnelAdvanced(float3 normal, float3 viewDir, float power, float bias)\n{\n    float f = 1.0 - saturate(dot(normalize(normal), normalize(viewDir)));\n    return pow(f, power) + bias;\n}\n\n// Curvatura simple usando diferencia entre normal y view\nfloat NormalCurvatureMask(float3 normal, float3 refNormal)\n{\n    return saturate(1.0 - dot(normalize(normal), normalize(refNormal)));\n}\n\n// Edge highlight por curvatura\nfloat EdgeHighlight(float3 normal, float3 viewDir, float power)\n{\n    float f = 1.0 - dot(normalize(normal), normalize(viewDir));\n    return pow(f, power);\n}\n\n//=========================================================================\n// 7. LUZ PROCEDURAL / SHADING CUSTOM\n//=========================================================================\n\n// Luz direccional simulada\nfloat SimulatedDirectionalLight(float3 normal, float3 lightDir)\n{\n    return saturate(dot(normalize(normal), normalize(lightDir)));\n}\n\n// Luz puntual simulada (basada en distancia)\nfloat SimulatedPointLight(float3 worldPos, float3 lightPos, float3 normal)\n{\n    float3 toLight = lightPos - worldPos;\n    float d = length(toLight);\n    float3 L = normalize(toLight);\n    float NdotL = saturate(dot(normal, L));\n    return NdotL / (d * d); // iluminaci\u00f3n realista con ca\u00edda\n}\n\n// Luz esf\u00e9rica suave (ideal para UI o FX en pantalla)\nfloat SphereLight(float2 uv, float2 center, float radius)\n{\n    float dist = distance(uv, center);\n    return smoothstep(radius, 0.0, dist);\n}\n\n// Sombra UV simulada\nfloat UVShadow(float2 uv, float2 lightDir, float softness)\n{\n    float n = dot(normalize(uv - 0.5), normalize(lightDir));\n    return smoothstep(0.0, softness, n);\n}\n\n//=========================================================================\n// 8. GLITCH FX / ERRORES VISUALES\n//=========================================================================\n\n// Separaci\u00f3n de canales RGB (glitch tipo VHS)\nfloat2 RGBOffset(float2 uv, float time, float intensity, float channelOffset)\n{\n    float offset = sin(time * 20.0 + uv.y * 100.0) * intensity;\n    return uv + float2(channelOffset * offset, 0.0);\n}\n\n// Salto UV (tipo flicker o salto de l\u00ednea)\nfloat2 UVJump(float2 uv, float time, float intensity)\n{\n    float glitch = step(0.95, frac(sin(dot(uv, float2(12.989, 78.233)) + time) * 43758.5453));\n    return uv + float2(0.0, glitch * intensity);\n}\n\n// Scanlines animadas\nfloat Scanlines(float2 uv, float time, float frequency, float thickness)\n{\n    float line = sin(uv.y * frequency + time * 20.0);\n    return smoothstep(thickness, 0.0, abs(line));\n}\n\n// Glitch temporal (fade in/out tipo error)\nfloat TemporalGlitch(float time, float speed, float duration)\n{\n    float t = frac(time * speed);\n    return step(t, duration);\n}\n\n#endif // VFX_MEGA_LIB_INCLUDED",
    "type": "c\u00f3digo"
  },
  {
    "id": "e0315988-7742-41bd-9e26-24a8ab9cb5b1",
    "title": "Utility Library",
    "created_at": "2025-04-01 21:56:28.250214+00",
    "content": "//====================================================================\n// HLSL UTILITY LIBRARY - TECHNICAL & VFX ARTISTS v2\n//====================================================================\n\n#ifndef VFX_UTILS_INCLUDED\n#define VFX_UTILS_INCLUDED\n\n//--------------------------------------------------\n// REMAP / INTERPOLACIONES\n//--------------------------------------------------\n\nfloat Remap(float v, float inMin, float inMax, float outMin, float outMax) {\n    return outMin + (v - inMin) * (outMax - outMin) / (inMax - inMin);\n}\n\nfloat RemapClamped(float v, float inMin, float inMax, float outMin, float outMax) {\n    float t = saturate((v - inMin) / (inMax - inMin));\n    return lerp(outMin, outMax, t);\n}\n\nfloat InverseLerp(float a, float b, float v) {\n    return saturate((v - a) / (b - a));\n}\n\nfloat EaseIn(float t)    { return t * t; }\nfloat EaseOut(float t)   { return 1.0 - pow(1.0 - t, 2.0); }\nfloat EaseInOut(float t) { return lerp(t*t, 1.0 - pow(1.0 - t, 2.0), step(0.5, t)); }\n\nfloat SmoothLerp(float a, float b, float t) {\n    t = t * t * (3.0 - 2.0 * t); // Hermite\n    return lerp(a, b, t);\n}\n\n//--------------------------------------------------\n// PROYECCIONES UV\n//--------------------------------------------------\n\n// Planar Projection\nfloat2 ProjectPlanar(float3 pos, float3 axisU, float3 axisV) {\n    return float2(dot(pos, axisU), dot(pos, axisV));\n}\n\n// Triplanar Projection (sin blending)\nfloat2 TriplanarUV(float3 pos, float3 normal, out float3 weights) {\n    float3 absN = abs(normal);\n    weights = absN / (absN.x + absN.y + absN.z);\n    return pos.yz; // ejemplo para eje Y, ajusta seg\u00fan blend deseado\n}\n\n// Cylindrical Projection\nfloat2 ProjectCylindrical(float3 pos) {\n    float angle = atan2(pos.z, pos.x);\n    float u = (angle + 3.14159) / (2.0 * 3.14159);\n    float v = pos.y;\n    return float2(u, v);\n}\n\n// Spherical Projection\nfloat2 ProjectSpherical(float3 pos) {\n    float3 n = normalize(pos);\n    float u = 0.5 + atan2(n.z, n.x) / (2.0 * 3.14159);\n    float v = 0.5 - asin(n.y) / 3.14159;\n    return float2(u, v);\n}\n\n//--------------------------------------------------\n// RUIDOS - ORDENADOS DE M\u00c1S BARATO A M\u00c1S CARO\n//--------------------------------------------------\n\n//--- 1. Hash noise (barato, sin continuidad) ---\nfloat Hash21(float2 p) {\n    p = frac(p * float2(123.34, 456.21));\n    p += dot(p, p + 45.32);\n    return frac(p.x * p.y);\n}\n\n//--- 2. Value Noise 2D (barato, interpolado) ---\nfloat ValueNoise(float2 uv) {\n    float2 i = floor(uv);\n    float2 f = frac(uv);\n    float a = Hash21(i);\n    float b = Hash21(i + float2(1, 0));\n    float c = Hash21(i + float2(0, 1));\n    float d = Hash21(i + float2(1, 1));\n    float2 u = f * f * (3.0 - 2.0 * f);\n    return lerp(lerp(a, b, u.x), lerp(c, d, u.x), u.y);\n}\n\n//--- 3. Perlin Noise 2D (m\u00e1s costoso, continuo) ---\nfloat2 Fade(float2 t) {\n    return t * t * (3.0 - 2.0 * t);\n}\n\nfloat Grad2(float2 p, float2 ip) {\n    float2 gradient = normalize(frac(sin(dot(ip, float2(127.1, 311.7))) * 43758.5453) * 2.0 - 1.0);\n    return dot(p, gradient);\n}\n\nfloat PerlinNoise(float2 uv) {\n    float2 i = floor(uv);\n    float2 f = frac(uv);\n\n    float a = Grad2(f, i);\n    float b = Grad2(f - float2(1, 0), i + float2(1, 0));\n    float c = Grad2(f - float2(0, 1), i + float2(0, 1));\n    float d = Grad2(f - float2(1, 1), i + float2(1, 1));\n\n    float2 u = Fade(f);\n    return lerp(lerp(a, b, u.x), lerp(c, d, u.x), u.y);\n}\n\n//--- 4. Gaussian Noise (para desenfoques o distorsi\u00f3n sutil) ---\nfloat Gaussian(float2 uv, float2 center, float sigma) {\n    float2 diff = uv - center;\n    float r2 = dot(diff, diff);\n    return exp(-r2 / (2.0 * sigma * sigma));\n}\n\n//--------------------------------------------------\n// M\u00c1SCARAS / FORMAS\n//--------------------------------------------------\n\nfloat CircleMask(float2 uv, float2 center, float radius, float softness) {\n    float d = distance(uv, center);\n    return smoothstep(radius, radius - softness, d);\n}\n\nfloat RingMask(float2 uv, float2 center, float radius, float thickness, float softness) {\n    float d = distance(uv, center);\n    float outer = smoothstep(radius, radius - softness, d);\n    float inner = smoothstep(radius - thickness, radius - thickness - softness, d);\n    return outer * (1.0 - inner);\n}\n\nfloat SoftMask(float mask, float threshold, float softness) {\n    return smoothstep(threshold, threshold - softness, mask);\n}\n\n//--------------------------------------------------\n// ANIMACIONES / EFECTOS TIEMPO\n//--------------------------------------------------\n\nfloat Oscillate(float minVal, float maxVal, float time, float speed) {\n    float t = sin(time * speed) * 0.5 + 0.5;\n    return lerp(minVal, maxVal, t);\n}\n\nfloat TriangleWave(float t) {\n    return abs(frac(t + 0.5) * 2.0 - 1.0);\n}\n\nfloat Pulse(float edge0, float edge1, float x) {\n    return step(edge0, x) - step(edge1, x);\n}\n\n//--------------------------------------------------\n// COLOR\n//--------------------------------------------------\n\nfloat3 HSVtoRGB(float3 hsv) {\n    float3 K = float3(1.0, 2.0 / 3.0, 1.0 / 3.0);\n    float3 P = abs(frac(hsv.xxx + K.xyz) * 6.0 - 3.0);\n    return hsv.z * lerp(K.xxx, saturate(P - K.xxx), hsv.y);\n}\n\nfloat3 RGBtoHSV(float3 c) {\n    float4 K = float4(0., -1./3., 2./3., -1.);\n    float4 p = (c.g < c.b) ? float4(c.bg, K.wz) : float4(c.gb, K.xy);\n    float4 q = (c.r < p.x) ? float4(p.xyw, c.r) : float4(c.r, p.yzx);\n    float d = q.x - min(q.w, q.y);\n    float e = 1e-10;\n    return float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n#endif // VFX_UTILS_INCLUDED",
    "type": "c\u00f3digo"
  }
]

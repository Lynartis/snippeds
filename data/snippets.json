[
  {
    "id": "252638e7-5e53-4818-b01b-f9d62a154af2",
    "title": "Nubeslocas",
    "created_at": "2025-08-11T14:02:23.733823+00:00",
    "content": "// ------------------------------------------------------------\n// Sky Dome Clouds (procedural 3D noise, single-layer plane hit)\n// Author: tú + yo :)\n// Notes:\n// - No textures. Uses hash33-based value noise -> FBM.\n// - Parallax by ray/plane intersection at fCloudLayerY.\n// - Clean naming: globals f*/v*, locals snake_case.\n// - Comments in English.\n// ------------------------------------------------------------\n\nstruct VSInput\n{\n    float3 vPos   : POSITION;\n    float3 vNorm  : NORMAL;     // not used but common in domes\n    float2 vTex0  : TEXCOORD0;\n};\n\nstruct PSInput\n{\n    float4 vPos   : SV_POSITION;\n    float3 vWorld : TEXCOORD0;  // world-space position of the dome surface point\n    float2 vTex0  : TEXCOORD1;  // passthrough if you need it\n};\n\n// ------------------------------------------------------------\n// Globals (engine supplies these):\n// Positions\nfloat3 g_vViewerPos;     // camera world-space position\n\n// Time & wind\nfloat  fTime;            // seconds\nfloat3 vWindDir;         // wind direction (will be normalized internally)\nfloat  fWindIntensity;   // wind speed scalar (units/sec)\n\n// Cloud layer & shaping\nfloat  fCloudLayerY;     // Y height of the cloud layer (world units)\nfloat  fCloudScale;      // base spatial scale for noise (bigger = larger features)\nfloat  fCloudCoverage;   // 0..1, higher = more clouds\nfloat  fCloudSharpness;  // >1 to sharpen, ~1 soft\nfloat  fCloudThickness;  // optical thickness multiplier (0..2 typical)\n\n// Lighting\nfloat3 vSunDir;          // normalized sun direction (world)\nfloat  fSunStrength;     // sun intensity multiplier\n\n// Colors\nfloat3 vSkyTopColor;       // clear sky zenith\nfloat3 vSkyHorizonColor;   // clear sky horizon\nfloat3 vCloudLightColor;   // lit cloud color\nfloat3 vCloudShadowColor;  // shadowed cloud color\n\n// Tuning (octaves)\nint    g_NoiseOctaves   = 5;\nfloat  g_Lacunarity     = 2.0;\nfloat  g_Gain           = 0.5;\n\n// ------------------------------------------------------------\n// Hash wrapper(s)\n// Expecting hash33(float3) -> float3 in [0,1]. If your hash returns -1..1, remap accordingly.\nfloat3 rand3(float3 p)\n{\n    // If your hash is named differently, adapt here.\n    // Example assumes: float3 hash33(float3 p);\n    return hash33(p);\n}\n\n// Quintic fade for smooth interpolation\nfloat3 fade3(float3 t)\n{\n    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\n\n// Trilinear interpolation\nfloat trilerp(float c000, float c100, float c010, float c110,\n              float c001, float c101, float c011, float c111, float3 t)\n{\n    float c00 = lerp(c000, c100, t.x);\n    float c10 = lerp(c010, c110, t.x);\n    float c01 = lerp(c001, c101, t.x);\n    float c11 = lerp(c011, c111, t.x);\n\n    float c0 = lerp(c00, c10, t.y);\n    float c1 = lerp(c01, c11, t.y);\n\n    return lerp(c0, c1, t.z);\n}\n\n// Value noise in 3D using hash33 at cell corners\nfloat value_noise_3d(float3 p)\n{\n    float3 pi = floor(p);\n    float3 pf = p - pi;\n\n    float3 w = fade3(pf);\n\n    float3 c000 = rand3(pi + float3(0,0,0));\n    float3 c100 = rand3(pi + float3(1,0,0));\n    float3 c010 = rand3(pi + float3(0,1,0));\n    float3 c110 = rand3(pi + float3(1,1,0));\n    float3 c001 = rand3(pi + float3(0,0,1));\n    float3 c101 = rand3(pi + float3(1,0,1));\n    float3 c011 = rand3(pi + float3(0,1,1));\n    float3 c111 = rand3(pi + float3(1,1,1));\n\n    // Use x component; already 0..1\n    float n = trilerp(c000.x, c100.x, c010.x, c110.x,\n                      c001.x, c101.x, c011.x, c111.x, w);\n\n    return n;\n}\n\n// Fractal Brownian Motion\nfloat fbm_3d(float3 p, int octaves, float lacunarity, float gain)\n{\n    float amplitude = 0.5;\n    float frequency = 1.0;\n    float sum = 0.0;\n\n    [unroll]\n    for (int o = 0; o < octaves; ++o)\n    {\n        float n = value_noise_3d(p * frequency);\n        // remap [0,1] -> [-1,1] to keep mean near 0\n        n = n * 2.0 - 1.0;\n\n        sum += n * amplitude;\n        frequency *= lacunarity;\n        amplitude *= gain;\n    }\n\n    // bring back to [0,1]\n    return saturate(sum * 0.5 + 0.5);\n}\n\n// Cheap shadowing by sampling a second, offset FBM along sun dir\nfloat compute_light_factor(float3 sample_pos, float3 sun_dir)\n{\n    float offset = 30.0; // larger = longer shadow sample\n    float3 shadow_sample_pos = sample_pos - sun_dir * offset;\n\n    float base = fbm_3d(sample_pos, g_NoiseOctaves, g_Lacunarity, g_Gain);\n    float shade = fbm_3d(shadow_sample_pos, g_NoiseOctaves, g_Lacunarity, g_Gain);\n\n    // If there's denser noise \"in front of the light\", darken\n    float light = saturate(base - shade * 0.5 + 0.5);\n    return light;\n}\n\n// Plane intersection: origin + t*dir with y = fCloudLayerY\nbool ray_plane_hit_y(float3 origin, float3 dir, float plane_y, out float t_hit)\n{\n    // Avoid division by ~0\n    if (abs(dir.y) < 1e-4)\n    {\n        t_hit = 1e9;\n        return false;\n    }\n    t_hit = (plane_y - origin.y) / dir.y;\n    return t_hit > 0.0;\n}\n\n// Sky gradient (clean sky under the clouds)\nfloat3 sky_color(float y01)\n{\n    // y01 ~ 0 at horizon, ~1 at zenith\n    return lerp(vSkyHorizonColor, vSkyTopColor, saturate(y01));\n}\n\n// Dome VS passthrough (use your engine's VS if you already have one)\nPSInput VSMain(VSInput i)\n{\n    PSInput o;\n    o.vPos   = float4(i.vPos, 1.0);\n    o.vWorld = i.vPos;     // If your pipeline provides actual world pos, replace here.\n    o.vTex0  = i.vTex0;\n    return o;\n}\n\n// Main pixel shader\nfloat4 PSMain(PSInput i) : SV_Target\n{\n    // --------------------------------------------------------\n    // 1) View ray from camera to this pixel's world position\n    // --------------------------------------------------------\n    float3 ray_dir = normalize(i.vWorld - g_vViewerPos);\n\n    // Horizon factor to fade density near horizon (more realistic)\n    float horizon_strength = saturate((ray_dir.y - 0.03) * 8.0); // tweakable\n\n    // --------------------------------------------------------\n    // 2) Intersect with the cloud layer plane at fCloudLayerY\n    // --------------------------------------------------------\n    float t_intersect;\n    bool has_hit = ray_plane_hit_y(g_vViewerPos, ray_dir, fCloudLayerY, t_intersect);\n\n    // If no forward hit (looking parallel or below layer), just show clear sky\n    if (!has_hit)\n    {\n        float y01 = saturate(ray_dir.y * 0.5 + 0.5);\n        return float4(sky_color(y01), 1.0);\n    }\n\n    float3 plane_hit_pos = g_vViewerPos + ray_dir * t_intersect;\n\n    // --------------------------------------------------------\n    // 3) Build 3D noise sample position with wind & scale\n    // --------------------------------------------------------\n    float3 wind_dir_n = (length(vWindDir) > 1e-3) ? normalize(vWindDir) : float3(1,0,0);\n    float  wind_travel = fWindIntensity * fTime;\n\n    // sampling domain in world units scaled down by fCloudScale\n    float3 sample_pos = plane_hit_pos / max(fCloudScale, 1e-3) + wind_dir_n * wind_travel;\n\n    // --------------------------------------------------------\n    // 4) FBM noise -> density, coverage, shaping\n    // --------------------------------------------------------\n    float base_fbm   = fbm_3d(sample_pos, g_NoiseOctaves, g_Lacunarity, g_Gain);\n\n    // Coverage: shift threshold; more coverage -> more cloud area\n    float coverage_bias = 1.0 - saturate(fCloudCoverage);\n    float density = saturate((base_fbm - coverage_bias) * fCloudSharpness);\n\n    // Fade near horizon to avoid hard cuts & reduce stretching artifacts\n    density *= horizon_strength;\n\n    // Optical thickness control\n    density *= saturate(fCloudThickness);\n\n    // Early out if basically clear\n    if (density < 1e-3)\n    {\n        float y01_clear = saturate(ray_dir.y * 0.5 + 0.5);\n        float3 sky_clr  = sky_color(y01_clear);\n        return float4(sky_clr, 0.0); // alpha 0 -> fully sky\n    }\n\n    // --------------------------------------------------------\n    // 5) Simple lighting (self-shadow approximation)\n    // --------------------------------------------------------\n    float3 sun_dir_n = (length(vSunDir) > 1e-3) ? normalize(vSunDir) : float3(0,1,0);\n    float  light_factor = compute_light_factor(sample_pos, sun_dir_n);\n\n    float3 cloud_light = lerp(vCloudShadowColor, vCloudLightColor, light_factor) * fSunStrength;\n\n    // --------------------------------------------------------\n    // 6) Sky background & compositing\n    // --------------------------------------------------------\n    float y01 = saturate(ray_dir.y * 0.5 + 0.5);\n    float3 sky_clr = sky_color(y01);\n\n    // Soft energy-conserving blend (premultiplied style feel)\n    float  alpha = saturate(density);\n    float3 final_rgb = lerp(sky_clr, cloud_light, alpha);\n\n    return float4(final_rgb, alpha);\n}\n\n// Technique/pass glue (adapt to your engine)\ntechnique11 SkyDomeClouds\n{\n    pass P0\n    {\n        SetVertexShader( CompileShader( vs_5_0, VSMain() ) );\n        SetPixelShader ( CompileShader( ps_5_0, PSMain() ) );\n    }\n}",
    "type": "código"
  },
  {
    "id": "67fd17a0-eb18-4eb7-a86f-ce1d3f056e5d",
    "title": "Nlue noise",
    "created_at": "2025-08-11T11:33:09.598599+00:00",
    "content": "// White noise from hash\nfloat WhiteNoise(float2 p)\n{\n    // hash -> [0,1]\n    return frac(sin(dot(p, float2(127.1, 311.7))) * 43758.5453);\n}\n\n// \"Blue-ish\" noise: subtract blurred noise to kill low frequencies\nfloat BlueNoiseApprox(float2 p)\n{\n    float n  = WhiteNoise(p);\n    float nb = (\n        WhiteNoise(p + float2(1,0)) +\n        WhiteNoise(p + float2(-1,0)) +\n        WhiteNoise(p + float2(0,1)) +\n        WhiteNoise(p + float2(0,-1))\n    ) * 0.25;\n\n    // high-pass filter\n    float b = n - nb;\n    // normalize to [0,1]\n    return saturate(b * 2.0 + 0.5);\n}",
    "type": "código"
  },
  {
    "id": "6fa7c817-7618-4de2-b8ce-5f718529807f",
    "title": "Mejorado",
    "created_at": "2025-08-11T10:41:27.185433+00:00",
    "content": "cbuffer Globals : register(b0)\n{\n    float  iTime;           // segundos\n    float2 iResolution;     // (width, height)\n    float2 iMouse;          // (x,y) en píxeles\n}\n\n// Textura de ruido (ideal 256x256 blue-noise). Filtrado point para texel estable\nTexture2D    BlueNoiseTex : register(t0);\nSamplerState SamplerPoint : register(s0);\n\n// Dirección del sol (normalizada)\nstatic const float3 SUN_DIR = normalize(float3(-0.7071, 0.0, -0.7071));\n\n//======================\n// Utilidades de ruido\n//======================\n\n// Interpolación cúbica suave para value noise\nfloat3 smooth3(float3 t)\n{\n    return t * t * (3.0 - 2.0 * t);\n}\n\n// Hash continuo (value-noise friendly) -> [0,1]\nfloat hash31(float3 p)\n{\n    // Solo float: uso frac y dot para “decorrelacionar”\n    p = frac(p * 0.1031);\n    p += dot(p, p.yzx + 33.33);\n    return frac((p.x + p.y) * p.z);\n}\n\n// Value noise 3D en [0,1]\nfloat noise3D(float3 p)\n{\n    float3 ip = floor(p);       // celda\n    float3 fp = frac(p);        // dentro de la celda\n\n    // 8 esquinas\n    float n000 = hash31(ip + float3(0.0,0.0,0.0));\n    float n100 = hash31(ip + float3(1.0,0.0,0.0));\n    float n010 = hash31(ip + float3(0.0,1.0,0.0));\n    float n110 = hash31(ip + float3(1.0,1.0,0.0));\n    float n001 = hash31(ip + float3(0.0,0.0,1.0));\n    float n101 = hash31(ip + float3(1.0,0.0,1.0));\n    float n011 = hash31(ip + float3(0.0,1.0,1.0));\n    float n111 = hash31(ip + float3(1.0,1.0,1.0));\n\n    float3 w = smooth3(fp);\n\n    float nx00 = lerp(n000, n100, w.x);\n    float nx10 = lerp(n010, n110, w.x);\n    float nx01 = lerp(n001, n101, w.x);\n    float nx11 = lerp(n011, n111, w.x);\n\n    float nxy0 = lerp(nx00, nx10, w.y);\n    float nxy1 = lerp(nx01, nx11, w.y);\n\n    return lerp(nxy0, nxy1, w.z);\n}\n\n//======================\n// Blue-noise sin enteros\n//======================\n// Emula texelFetch(iChannel1, px&255, 0).x pero usando UV normalizadas.\n// - Asume textura 256x256 (o cualquier tamaño); usamos mod 1 con frac.\n// - No se usan int/bitwise; filtrado Point para evitar bleeding.\nfloat BlueNoiseUV(float2 fragCoord)\n{\n    // Convertimos a “texel space” y hacemos wrap con frac\n    // Si la textura es 256x256, fragCoord/256 da UV. Con frac, repetimos cada 256 px.\n    float2 uv = frac(fragCoord / 256.0);\n    // SampleLevel con mip 0 para emular fetch exacto\n    return BlueNoiseTex.SampleLevel(SamplerPoint, uv, 0.0).r;\n}\n\n//======================\n// Cámara lookAt + roll\n//======================\nfloat3x3 setCamera(float3 ro, float3 ta, float roll)\n{\n    float3 fw = normalize(ta - ro);\n    float3 up = float3(0.0, 1.0, 0.0);\n    float3 rt = normalize(cross(fw, up));\n    up = normalize(cross(rt, fw));\n\n    float c = cos(roll), s = sin(roll);\n    float3 rt2 = c*rt + s*up;\n    float3 up2 = -s*rt + c*up;\n\n    // Matriz columnas [rt up fw]\n    return float3x3(rt2, up2, fw);\n}\n\n//======================\n// Densidad de nubes (LOD)\n//======================\nfloat3 flowOffset() { return float3(0.0, 0.1, 1.0) * iTime; }\n\n// Fórmula base: clamp( 1.5 - p.y - 2.0 + 1.75*f , 0, 1 )\nfloat map2(float3 p)\n{\n    float3 q = p - flowOffset();\n    float f = 0.0;\n    f += 0.50 * noise3D(q); q *= 2.02;\n    f += 0.25 * noise3D(q); q *= 2.03;\n    return saturate(1.5 - p.y - 2.0 + 1.75*f);\n}\n\nfloat map3(float3 p)\n{\n    float3 q = p - flowOffset();\n    float f = 0.0;\n    f += 0.50 * noise3D(q);  q *= 2.02;\n    f += 0.25 * noise3D(q);  q *= 2.03;\n    f += 0.125* noise3D(q);  q *= 2.01;\n    return saturate(1.5 - p.y - 2.0 + 1.75*f);\n}\n\nfloat map4(float3 p)\n{\n    float3 q = p - flowOffset();\n    float f = 0.0;\n    f += 0.50   * noise3D(q); q *= 2.02;\n    f += 0.25   * noise3D(q); q *= 2.03;\n    f += 0.125  * noise3D(q); q *= 2.01;\n    f += 0.0625 * noise3D(q); q *= 2.00;\n    return saturate(1.5 - p.y - 2.0 + 1.75*f);\n}\n\nfloat map5(float3 p)\n{\n    float3 q = p - flowOffset();\n    float f = 0.0;\n    f += 0.50    * noise3D(q); q *= 2.02;\n    f += 0.25    * noise3D(q); q *= 2.03;\n    f += 0.125   * noise3D(q); q *= 2.01;\n    f += 0.0625  * noise3D(q); q *= 2.00;\n    f += 0.03125 * noise3D(q); q *= 2.00;\n    return saturate(1.5 - p.y - 2.0 + 1.75*f);\n}\n\n//======================\n// Raymarch (solo floats)\n//======================\nfloat4 Raymarch(float3 ro, float3 rd, float3 bgcol, float2 fragCoord)\n{\n    float4 sum = float4(0.0,0.0,0.0,0.0);\n\n    // Jitter inicial equivalente a 0.05 * texelFetch(...).x\n    float t = 0.05 * BlueNoiseUV(fragCoord);\n\n    // Límites verticales del volumen\n    const float yMin = -3.0;\n    const float yMax =  2.0;\n\n    // Avance de paso: t += max(0.06, 0.05*t)\n    // Nota: todos los bucles usan float como contador y límite float.\n\n    // -------- LOD: map5, 40 pasos\n    for (float s = 0.0; s < 40.0; s += 1.0)\n    {\n        float3 pos = ro + t * rd;\n        if (pos.y < yMin || pos.y > yMax || sum.a > 0.99) break;\n\n        float den = map5(pos);\n        if (den > 0.01)\n        {\n            float denAhead = map5(pos + 0.3 * SUN_DIR);\n            float dif = clamp((den - denAhead) / 0.6, 0.0, 1.0);\n            float3 lin = float3(1.0, 0.6, 0.3) * dif + float3(0.91, 0.98, 1.05);\n            float3 cloudAlbedo = lerp(float3(1.0, 0.95, 0.8), float3(0.25, 0.3, 0.35), den);\n\n            float4 col = float4(cloudAlbedo, den);\n            col.rgb *= lin;\n\n            float fog = 1.0 - exp(-0.003 * t * t);\n            col.rgb = lerp(col.rgb, bgcol, fog);\n\n            col.a *= 0.4;\n            col.rgb *= col.a;\n            sum += col * (1.0 - sum.a);\n        }\n        t += max(0.06, 0.05 * t);\n    }\n\n    // -------- LOD: map4, 40 pasos\n    for (float s = 0.0; s < 40.0; s += 1.0)\n    {\n        float3 pos = ro + t * rd;\n        if (pos.y < yMin || pos.y > yMax || sum.a > 0.99) break;\n\n        float den = map4(pos);\n        if (den > 0.01)\n        {\n            float denAhead = map4(pos + 0.3 * SUN_DIR);\n            float dif = clamp((den - denAhead) / 0.6, 0.0, 1.0);\n            float3 lin = float3(1.0, 0.6, 0.3) * dif + float3(0.91, 0.98, 1.05);\n            float3 cloudAlbedo = lerp(float3(1.0, 0.95, 0.8), float3(0.25, 0.3, 0.35), den);\n\n            float4 col = float4(cloudAlbedo, den);\n            col.rgb *= lin;\n\n            float fog = 1.0 - exp(-0.003 * t * t);\n            col.rgb = lerp(col.rgb, bgcol, fog);\n\n            col.a *= 0.4;\n            col.rgb *= col.a;\n            sum += col * (1.0 - sum.a);\n        }\n        t += max(0.06, 0.05 * t);\n    }\n\n    // -------- LOD: map3, 30 pasos\n    for (float s = 0.0; s < 30.0; s += 1.0)\n    {\n        float3 pos = ro + t * rd;\n        if (pos.y < yMin || pos.y > yMax || sum.a > 0.99) break;\n\n        float den = map3(pos);\n        if (den > 0.01)\n        {\n            float denAhead = map3(pos + 0.3 * SUN_DIR);\n            float dif = clamp((den - denAhead) / 0.6, 0.0, 1.0);\n            float3 lin = float3(1.0, 0.6, 0.3) * dif + float3(0.91, 0.98, 1.05);\n            float3 cloudAlbedo = lerp(float3(1.0, 0.95, 0.8), float3(0.25, 0.3, 0.35), den);\n\n            float4 col = float4(cloudAlbedo, den);\n            col.rgb *= lin;\n\n            float fog = 1.0 - exp(-0.003 * t * t);\n            col.rgb = lerp(col.rgb, bgcol, fog);\n\n            col.a *= 0.4;\n            col.rgb *= col.a;\n            sum += col * (1.0 - sum.a);\n        }\n        t += max(0.06, 0.05 * t);\n    }\n\n    // -------- LOD: map2, 30 pasos\n    for (float s = 0.0; s < 30.0; s += 1.0)\n    {\n        float3 pos = ro + t * rd;\n        if (pos.y < yMin || pos.y > yMax || sum.a > 0.99) break;\n\n        float den = map2(pos);\n        if (den > 0.01)\n        {\n            float denAhead = map2(pos + 0.3 * SUN_DIR);\n            float dif = clamp((den - denAhead) / 0.6, 0.0, 1.0);\n            float3 lin = float3(1.0, 0.6, 0.3) * dif + float3(0.91, 0.98, 1.05);\n            float3 cloudAlbedo = lerp(float3(1.0, 0.95, 0.8), float3(0.25, 0.3, 0.35), den);\n\n            float4 col = float4(cloudAlbedo, den);\n            col.rgb *= lin;\n\n            float fog = 1.0 - exp(-0.003 * t * t);\n            col.rgb = lerp(col.rgb, bgcol, fog);\n\n            col.a *= 0.4;\n            col.rgb *= col.a;\n            sum += col * (1.0 - sum.a);\n        }\n        t += max(0.06, 0.05 * t);\n    }\n\n    return saturate(sum);\n}\n\n//======================\n// Cielo + sol + glare\n//======================\nfloat4 Render(float3 ro, float3 rd, float2 fragCoord)\n{\n    // Cielo base (gradiente)\n    float sun = saturate(dot(SUN_DIR, rd));\n    float3 col = float3(0.6, 0.71, 0.75) - rd.y * 0.2 * float3(1.0, 0.5, 1.0) + 0.075;\n\n    // Halo solar\n    col += 0.2 * float3(1.0, 0.6, 0.1) * pow(sun, 8.0);\n\n    // Nubes\n    float4 res = Raymarch(ro, rd, col, fragCoord);\n    col = col * (1.0 - res.a) + res.rgb;\n\n    // Glare adicional\n    col += float3(0.2, 0.08, 0.04) * pow(sun, 3.0);\n\n    return float4(col, 1.0);\n}\n\n//======================\n// Fullscreen VS/PS\n//======================\nstruct VSIn  { float3 pos : POSITION; float2 uv : TEXCOORD0; };\nstruct VSOut { float4 pos : SV_Position; float2 uv : TEXCOORD0; };\n\nVSOut VSMain(VSIn vin)\n{\n    VSOut o;\n    o.pos = float4(vin.pos.xy, 0.0, 1.0);\n    o.uv  = vin.uv;\n    return o;\n}\n\nfloat4 PSMain(VSOut pin) : SV_Target\n{\n    // Coordenadas estilo Shadertoy\n    float2 fragCoord = pin.uv * iResolution;\n    float2 p = (2.0 * fragCoord - iResolution) / iResolution.y;\n    float2 m = iMouse / iResolution;\n\n    // Cámara orbital + roll animado\n    float angle = 3.0 * m.x;\n    float elev  = 0.8 * m.y;\n\n    float3 ro = 4.0 * normalize(float3(sin(angle), elev, cos(angle))) - float3(0.0, 0.1, 0.0);\n    float3 ta = float3(0.0, -1.0, 0.0);\n    float  roll = 0.07 * cos(0.25 * iTime);\n\n    float3x3 cam = setCamera(ro, ta, roll);\n\n    // Rayo (fov implícito con z=1.5)\n    float3 rd = mul(cam, normalize(float3(p.xy, 1.5)));\n\n    return Render(ro, rd, fragCoord);\n}\n",
    "type": "código"
  },
  {
    "id": "18e8cf69-fc15-4d61-8060-9b37700e7a96",
    "title": "Sugarcandle",
    "created_at": "2025-08-11T07:56:04.475008+00:00",
    "content": "// -------------------------------------------------------------\n// Volumetric Clouds on Sky Dome (HLSL) - bright look\n// - Usa g_vViewerPos.xyz como cámara (tu motor).\n// - Dibuja sobre un domo en el mundo (usa i.v_world por vértice).\n// - Ruido procedural (value noise 3D) sin texturas.\n// - Nombres en snake_case y sin defines de GLSL.\n// -------------------------------------------------------------\n\n// ===== Constantes de objeto/cámara ============================\n\ncbuffer object_params : register(b1)\n{\n    float4x4 uWorld;\n    float4x4 uViewProj;\n}\n\ncbuffer camera_params : register(b0)\n{\n    float4 g_vViewerPos;      // xyz = posición de la cámara (tu motor)\n    float   i_time;           // segundos\n    float3  _pad_cam0;\n\n    // Dirección del sol y parámetros de nubes (ajustables)\n    float3  sun_dir_ws;       // normalizada; ej: (-0.7071, 0, -0.7071)\n    float   wind_speed;       // m/s (desplazamiento animado del patrón)\n\n    float3  wind_dir_ws;      // dirección del viento (normalizada)\n    float   _pad_cam1;\n\n    float3  cloud_space_scale;// escala mundo→ruido (ej: 0.0015,0.002,0.0015)\n    float   _pad_cam2;\n}\n\n// ===== VS/PS I/O ==============================================\n\nstruct vs_in\n{\n    float3 pos : POSITION;\n    float3 nrm : NORMAL;      // opcional (no se usa)\n    float2 uv  : TEXCOORD0;   // opcional (no se usa)\n};\n\nstruct vs_out\n{\n    float4 sv_pos  : SV_Position;\n    float3 v_world : TEXCOORD0;  // posición en mundo del vértice\n};\n\n// ===== Vertex Shader para domo ================================\n\nvs_out vs_dome(vs_in i)\n{\n    vs_out o;\n    float4 wpos = mul(float4(i.pos, 1.0), uWorld);\n    o.v_world = wpos.xyz;\n    o.sv_pos  = mul(wpos, uViewProj);\n    return o;\n}\n\n// ===== Utilidades / Hash / Ruido ==============================\n\nfloat3 smooth3(float3 f) { return f * f * (3.0 - 2.0 * f); }\n\nuint  hash_u(uint x){ x^=2747636419u; x*=2654435769u; x^=x>>16; x*=2654435769u; x^=x>>16; return x; }\nuint  hash_u2(uint2 v){ return hash_u(v.x ^ (v.y * 1597334677u + 0x9E3779B9u)); }\nuint  hash_u3(uint3 v){ uint h=v.x*374761393u+v.y*668265263u+v.z*2246822519u+0x9E3779B9u; return hash_u(h); }\nfloat hash01(uint h){ return (hash_u(h) >> 8) * (1.0 / 16777216.0); }\n\nfloat hash01_f3(float3 p, uint seed)\n{\n    int3 ip = (int3)floor(p);\n    uint3 up = (uint3)(ip) ^ uint3(seed, seed * 1664525u + 1013904223u, seed * 747796405u + 2891336453u);\n    return hash01(hash_u3(up));\n}\n\n// Dithering por píxel (sustituye iChannel1)\nfloat dither01(int2 px, uint seed)\n{\n    uint2 id = (uint2)(px) ^ uint2(seed, seed * 747796405u);\n    return hash01(hash_u2(id));\n}\n\n// Value noise 3D en [-1,1] (sin tablas)\nfloat value_noise_3d(float3 x, uint seed)\n{\n    float3 p = floor(x);\n    float3 f = frac(x);\n    float3 w = smooth3(f);\n\n    float n000 = hash01_f3(p + float3(0,0,0), seed);\n    float n100 = hash01_f3(p + float3(1,0,0), seed);\n    float n010 = hash01_f3(p + float3(0,1,0), seed);\n    float n110 = hash01_f3(p + float3(1,1,0), seed);\n    float n001 = hash01_f3(p + float3(0,0,1), seed);\n    float n101 = hash01_f3(p + float3(1,0,1), seed);\n    float n011 = hash01_f3(p + float3(0,1,1), seed);\n    float n111 = hash01_f3(p + float3(1,1,1), seed);\n\n    float n00 = lerp(n000, n100, w.x);\n    float n10 = lerp(n010, n110, w.x);\n    float n01 = lerp(n001, n101, w.x);\n    float n11 = lerp(n011, n111, w.x);\n\n    float n0  = lerp(n00,  n10,  w.y);\n    float n1  = lerp(n01,  n11,  w.y);\n\n    float n   = lerp(n0,   n1,   w.z);\n    return n * 2.0 - 1.0;\n}\n\n// ===== Densidad de nubes (LOOK 1 - bright) ====================\n// Replican map5/map4/map3/map2 del shader original (pesos fijos)\n\nfloat map5(float3 p)\n{\n    // Espacio de nubes: escala + desplazamiento por viento\n    float3 q = (p + wind_dir_ws * wind_speed * i_time) * cloud_space_scale;\n\n    float f = 0.0;\n    f  = 0.50000 * value_noise_3d(q, 1337u); q *= 2.02;\n    f += 0.25000 * value_noise_3d(q, 1338u); q *= 2.03;\n    f += 0.12500 * value_noise_3d(q, 1339u); q *= 2.01;\n    f += 0.06250 * value_noise_3d(q, 1340u); q *= 2.02;\n    f += 0.03125 * value_noise_3d(q, 1341u);\n\n    // Altura: capa entre ~y∈[-3,2] (ver marching)\n    return clamp(1.5 - p.y - 2.0 + 1.75 * f, 0.0, 1.0);\n}\n\nfloat map4(float3 p)\n{\n    float3 q = (p + wind_dir_ws * wind_speed * i_time) * cloud_space_scale;\n\n    float f = 0.0;\n    f  = 0.50000 * value_noise_3d(q, 1337u); q *= 2.02;\n    f += 0.25000 * value_noise_3d(q, 1338u); q *= 2.03;\n    f += 0.12500 * value_noise_3d(q, 1339u); q *= 2.01;\n    f += 0.06250 * value_noise_3d(q, 1340u);\n\n    return clamp(1.5 - p.y - 2.0 + 1.75 * f, 0.0, 1.0);\n}\n\nfloat map3(float3 p)\n{\n    float3 q = (p + wind_dir_ws * wind_speed * i_time) * cloud_space_scale;\n\n    float f = 0.0;\n    f  = 0.50000 * value_noise_3d(q, 1337u); q *= 2.02;\n    f += 0.25000 * value_noise_3d(q, 1338u); q *= 2.03;\n    f += 0.12500 * value_noise_3d(q, 1339u);\n\n    return clamp(1.5 - p.y - 2.0 + 1.75 * f, 0.0, 1.0);\n}\n\nfloat map2(float3 p)\n{\n    float3 q = (p + wind_dir_ws * wind_speed * i_time) * cloud_space_scale;\n\n    float f = 0.0;\n    f  = 0.50000 * value_noise_3d(q, 1337u); q *= 2.02;\n    f += 0.25000 * value_noise_3d(q, 1338u);\n\n    return clamp(1.5 - p.y - 2.0 + 1.75 * f, 0.0, 1.0);\n}\n\n// ===== Marcha volumétrica =====================================\n\nfloat4 raymarch(float3 ro, float3 rd, float3 bg_col, int2 px)\n{\n    float4 acc = float4(0,0,0,0);\n    float t = 0.05 * dither01(px & int2(255,255), 777u);\n\n    // Bloque 1 (40 pasos, map5)\n    [loop] for (int i = 0; i < 40; ++i)\n    {\n        float3 pos = ro + t * rd;\n        if (pos.y < -3.0 || pos.y > 2.0 || acc.a > 0.99) break;\n\n        float den = map5(pos);\n        if (den > 0.01)\n        {\n            float dif = clamp((den - map5(pos + 0.3 * sun_dir_ws)) / 0.6, 0.0, 1.0);\n            float3 lin = float3(1.0, 0.6, 0.3) * dif + float3(0.91, 0.98, 1.05);\n            float4 col = float4( lerp(float3(1.0, 0.95, 0.8), float3(0.25, 0.3, 0.35), den), den );\n            col.rgb *= lin;\n            col.rgb = lerp(col.rgb, bg_col, 1.0 - exp(-0.003 * t * t));\n            col.a  *= 0.4;\n            col.rgb *= col.a;\n            acc += col * (1.0 - acc.a);\n        }\n        t += max(0.06, 0.05 * t);\n    }\n\n    // Bloque 2 (40 pasos, map4)\n    [loop] for (int i = 0; i < 40; ++i)\n    {\n        float3 pos = ro + t * rd;\n        if (pos.y < -3.0 || pos.y > 2.0 || acc.a > 0.99) break;\n\n        float den = map4(pos);\n        if (den > 0.01)\n        {\n            float dif = clamp((den - map4(pos + 0.3 * sun_dir_ws)) / 0.6, 0.0, 1.0);\n            float3 lin = float3(1.0, 0.6, 0.3) * dif + float3(0.91, 0.98, 1.05);\n            float4 col = float4( lerp(float3(1.0, 0.95, 0.8), float3(0.25, 0.3, 0.35), den), den );\n            col.rgb *= lin;\n            col.rgb = lerp(col.rgb, bg_col, 1.0 - exp(-0.003 * t * t));\n            col.a  *= 0.4;\n            col.rgb *= col.a;\n            acc += col * (1.0 - acc.a);\n        }\n        t += max(0.06, 0.05 * t);\n    }\n\n    // Bloque 3 (30 pasos, map3)\n    [loop] for (int i = 0; i < 30; ++i)\n    {\n        float3 pos = ro + t * rd;\n        if (pos.y < -3.0 || pos.y > 2.0 || acc.a > 0.99) break;\n\n        float den = map3(pos);\n        if (den > 0.01)\n        {\n            float dif = clamp((den - map3(pos + 0.3 * sun_dir_ws)) / 0.6, 0.0, 1.0);\n            float3 lin = float3(1.0, 0.6, 0.3) * dif + float3(0.91, 0.98, 1.05);\n            float4 col = float4( lerp(float3(1.0, 0.95, 0.8), float3(0.25, 0.3, 0.35), den), den );\n            col.rgb *= lin;\n            col.rgb = lerp(col.rgb, bg_col, 1.0 - exp(-0.003 * t * t));\n            col.a  *= 0.4;\n            col.rgb *= col.a;\n            acc += col * (1.0 - acc.a);\n        }\n        t += max(0.06, 0.05 * t);\n    }\n\n    // Bloque 4 (30 pasos, map2)\n    [loop] for (int i = 0; i < 30; ++i)\n    {\n        float3 pos = ro + t * rd;\n        if (pos.y < -3.0 || pos.y > 2.0 || acc.a > 0.99) break;\n\n        float den = map2(pos);\n        if (den > 0.01)\n        {\n            float dif = clamp((den - map2(pos + 0.3 * sun_dir_ws)) / 0.6, 0.0, 1.0);\n            float3 lin = float3(1.0, 0.6, 0.3) * dif + float3(0.91, 0.98, 1.05);\n            float4 col = float4( lerp(float3(1.0, 0.95, 0.8), float3(0.25, 0.3, 0.35), den), den );\n            col.rgb *= lin;\n            col.rgb = lerp(col.rgb, bg_col, 1.0 - exp(-0.003 * t * t));\n            col.a  *= 0.4;\n            col.rgb *= col.a;\n            acc += col * (1.0 - acc.a);\n        }\n        t += max(0.06, 0.05 * t);\n    }\n\n    return saturate(acc);\n}\n\n// ===== Fondo + composición final (sobre domo) =================\n\nfloat4 ps_dome(vs_out i) : SV_Target\n{\n    // Ray en espacio mundo: desde la cámara hacia el fragmento del domo\n    float3 ro = g_vViewerPos.xyz;\n    float3 rd = normalize(i.v_world - ro);\n\n    // Cielo base (bright look) + halo solar\n    float sun_f = saturate(dot(sun_dir_ws, rd));\n    float3 bg = float3(0.6, 0.71, 0.75)\n              - rd.y * 0.2 * float3(1.0, 0.5, 1.0)\n              + 0.15 * 0.5;\n    bg += 0.2 * float3(1.0, 0.6, 0.1) * pow(sun_f, 8.0);\n\n    // Dithering por píxel usando SV_Position\n    int2 px = (int2)i.sv_pos.xy;\n\n    // Nubes volumétricas\n    float4 res = raymarch(ro, rd, bg, px);\n    float3 col = bg * (1.0 - res.w) + res.xyz;\n\n    // Glare adicional\n    col += float3(0.2, 0.08, 0.04) * pow(sun_f, 3.0);\n\n    return float4(col, 1.0);\n}",
    "type": "código"
  },
  {
    "id": "6e98ede0-7094-4992-ad48-0c6f3bb39b18",
    "title": "Shdhd",
    "created_at": "2025-08-08T13:24:21.838607+00:00",
    "content": "//------------------------------------------------------------------------------\n// NUBES RAYMARCH HLSL (SIN #define, TODO HARD-CODEADO)\n// LODs: 40 pasos (map5), 40 (map4), 30 (map3), 30 (map2)\n//------------------------------------------------------------------------------\n\ncbuffer Globals : register(b0)\n{\n    float  iTime;           // segundos\n    float2 iResolution;     // (width, height)\n    float2 iMouse;          // (x,y) en píxeles\n}\n\nTexture2D    BlueNoiseTex : register(t0);   // 256x256\nSamplerState SamplerPoint : register(s0);   // Point/Clamp\n\n// Dirección del sol fija (normalizada)\nstatic const float3 SUN_DIR = normalize(float3(-0.7071, 0.0, -0.7071));\n\n//----------------------\n// Utilidades\n//----------------------\nfloat3 smooth3(float3 t) { return t*t*(3.0 - 2.0*t); }\n\nfloat hash31(float3 p)\n{\n    p = frac(p * 0.1031);\n    p += dot(p, p.yzx + 33.33);\n    return frac((p.x + p.y) * p.z);\n}\n\n// Value noise 3D en [0,1]\nfloat noise3D(float3 p)\n{\n    float3 ip = floor(p);\n    float3 fp = frac(p);\n    float n000 = hash31(ip + float3(0,0,0));\n    float n100 = hash31(ip + float3(1,0,0));\n    float n010 = hash31(ip + float3(0,1,0));\n    float n110 = hash31(ip + float3(1,1,0));\n    float n001 = hash31(ip + float3(0,0,1));\n    float n101 = hash31(ip + float3(1,0,1));\n    float n011 = hash31(ip + float3(0,1,1));\n    float n111 = hash31(ip + float3(1,1,1));\n\n    float3 w = smooth3(fp);\n\n    float nx00 = lerp(n000, n100, w.x);\n    float nx10 = lerp(n010, n110, w.x);\n    float nx01 = lerp(n001, n101, w.x);\n    float nx11 = lerp(n011, n111, w.x);\n\n    float nxy0 = lerp(nx00, nx10, w.y);\n    float nxy1 = lerp(nx01, nx11, w.y);\n\n    return lerp(nxy0, nxy1, w.z);\n}\n\nfloat BlueNoiseAtInt(int2 px)\n{\n    int2 wrapped = px & 255; // 256x256\n    return BlueNoiseTex.Load(int3(wrapped, 0)).r;\n}\n\n// Cámara lookAt con roll\nfloat3x3 setCamera(float3 ro, float3 ta, float roll)\n{\n    float3 fw = normalize(ta - ro);\n    float3 up = float3(0,1,0);\n    float3 rt = normalize(cross(fw, up));\n    up = normalize(cross(rt, fw));\n    float c = cos(roll), s = sin(roll);\n    float3 rt2 = c*rt + s*up;\n    float3 up2 = -s*rt + c*up;\n    return float3x3(rt2, up2, fw); // columnas: rt, up, fw\n}\n\n// Desplazamiento animado (viento)\nfloat3 flowOffset() { return float3(0.0, 0.1, 1.0) * iTime; }\n\n// Densidades por LOD (misma fórmula, +octavas según nivel)\nfloat map2(float3 p)\n{\n    float3 q = p - flowOffset();\n    float f = 0.0;\n    f += 0.50 * noise3D(q); q *= 2.02;\n    f += 0.25 * noise3D(q); q *= 2.03;\n    float d = 1.5 - p.y - 2.0 + 1.75*f;\n    return saturate(d);\n}\n\nfloat map3(float3 p)\n{\n    float3 q = p - flowOffset();\n    float f = 0.0;\n    f += 0.50 * noise3D(q); q *= 2.02;\n    f += 0.25 * noise3D(q); q *= 2.03;\n    f += 0.125* noise3D(q); q *= 2.01;\n    float d = 1.5 - p.y - 2.0 + 1.75*f;\n    return saturate(d);\n}\n\nfloat map4(float3 p)\n{\n    float3 q = p - flowOffset();\n    float f = 0.0;\n    f += 0.50   * noise3D(q); q *= 2.02;\n    f += 0.25   * noise3D(q); q *= 2.03;\n    f += 0.125  * noise3D(q); q *= 2.01;\n    f += 0.0625 * noise3D(q); q *= 2.00;\n    float d = 1.5 - p.y - 2.0 + 1.75*f;\n    return saturate(d);\n}\n\nfloat map5(float3 p)\n{\n    float3 q = p - flowOffset();\n    float f = 0.0;\n    f += 0.50    * noise3D(q); q *= 2.02;\n    f += 0.25    * noise3D(q); q *= 2.03;\n    f += 0.125   * noise3D(q); q *= 2.01;\n    f += 0.0625  * noise3D(q); q *= 2.00;\n    f += 0.03125 * noise3D(q); q *= 2.00;\n    float d = 1.5 - p.y - 2.0 + 1.75*f;\n    return saturate(d);\n}\n\n// Raymarch “duro”: 4 bucles con pasos fijos (40/40/30/30), sin macros\nfloat4 Raymarch(float3 ro, float3 rd, float3 bgcol, int2 px)\n{\n    float4 sum = float4(0,0,0,0);\n    float t = 0.05 * BlueNoiseAtInt(px); // jitter inicial\n\n    // límites verticales del volumen\n    const float yMin = -3.0;\n    const float yMax =  2.0;\n\n    // Helpers locales para sombreado\n    auto stepBody = [&](float den, float3 pos)\n    {\n        float denAhead = den; // evitar doble cómputo cuando no toca\n        denAhead = map5(pos + 0.3 * SUN_DIR); // se sobreescribe por LOD en cada bucle\n\n        // difuso/gradiente hacia el sol\n        float dif = clamp((den - denAhead) / 0.6, 0.0, 1.0);\n        float3 lin = float3(1.0, 0.6, 0.3) * dif + float3(0.91, 0.98, 1.05);\n        float3 cloudAlbedo = lerp(float3(1.0, 0.95, 0.8), float3(0.25, 0.3, 0.35), den);\n        float4 col = float4(cloudAlbedo, den);\n        col.rgb *= lin;\n\n        float fog = 1.0 - exp(-0.003 * t * t);\n        col.rgb = lerp(col.rgb, bgcol, fog);\n\n        col.a *= 0.4;\n        col.rgb *= col.a;\n        sum += col * (1.0 - sum.a);\n    };\n\n    // -------- LOD: map5, 40 pasos\n    [loop] for (int i=0; i<40; i++)\n    {\n        float3 pos = ro + t*rd;\n        if (pos.y < yMin || pos.y > yMax || sum.a > 0.99) break;\n\n        float den = map5(pos);\n        if (den > 0.01)\n        {\n            float denAhead = map5(pos + 0.3 * SUN_DIR);\n            float dif = clamp((den - denAhead) / 0.6, 0.0, 1.0);\n            float3 lin = float3(1.0, 0.6, 0.3) * dif + float3(0.91, 0.98, 1.05);\n            float3 cloudAlbedo = lerp(float3(1.0, 0.95, 0.8), float3(0.25, 0.3, 0.35), den);\n            float4 col = float4(cloudAlbedo, den);\n            col.rgb *= lin;\n            float fog = 1.0 - exp(-0.003 * t * t);\n            col.rgb = lerp(col.rgb, bgcol, fog);\n            col.a *= 0.4;\n            col.rgb *= col.a;\n            sum += col * (1.0 - sum.a);\n        }\n        t += max(0.06, 0.05 * t);\n    }\n\n    // -------- LOD: map4, 40 pasos\n    [loop] for (int i=0; i<40; i++)\n    {\n        float3 pos = ro + t*rd;\n        if (pos.y < yMin || pos.y > yMax || sum.a > 0.99) break;\n\n        float den = map4(pos);\n        if (den > 0.01)\n        {\n            float denAhead = map4(pos + 0.3 * SUN_DIR);\n            float dif = clamp((den - denAhead) / 0.6, 0.0, 1.0);\n            float3 lin = float3(1.0, 0.6, 0.3) * dif + float3(0.91, 0.98, 1.05);\n            float3 cloudAlbedo = lerp(float3(1.0, 0.95, 0.8), float3(0.25, 0.3, 0.35), den);\n            float4 col = float4(cloudAlbedo, den);\n            col.rgb *= lin;\n            float fog = 1.0 - exp(-0.003 * t * t);\n            col.rgb = lerp(col.rgb, bgcol, fog);\n            col.a *= 0.4;\n            col.rgb *= col.a;\n            sum += col * (1.0 - sum.a);\n        }\n        t += max(0.06, 0.05 * t);\n    }\n\n    // -------- LOD: map3, 30 pasos\n    [loop] for (int i=0; i<30; i++)\n    {\n        float3 pos = ro + t*rd;\n        if (pos.y < yMin || pos.y > yMax || sum.a > 0.99) break;\n\n        float den = map3(pos);\n        if (den > 0.01)\n        {\n            float denAhead = map3(pos + 0.3 * SUN_DIR);\n            float dif = clamp((den - denAhead) / 0.6, 0.0, 1.0);\n            float3 lin = float3(1.0, 0.6, 0.3) * dif + float3(0.91, 0.98, 1.05);\n            float3 cloudAlbedo = lerp(float3(1.0, 0.95, 0.8), float3(0.25, 0.3, 0.35), den);\n            float4 col = float4(cloudAlbedo, den);\n            col.rgb *= lin;\n            float fog = 1.0 - exp(-0.003 * t * t);\n            col.rgb = lerp(col.rgb, bgcol, fog);\n            col.a *= 0.4;\n            col.rgb *= col.a;\n            sum += col * (1.0 - sum.a);\n        }\n        t += max(0.06, 0.05 * t);\n    }\n\n    // -------- LOD: map2, 30 pasos\n    [loop] for (int i=0; i<30; i++)\n    {\n        float3 pos = ro + t*rd;\n        if (pos.y < yMin || pos.y > yMax || sum.a > 0.99) break;\n\n        float den = map2(pos);\n        if (den > 0.01)\n        {\n            float denAhead = map2(pos + 0.3 * SUN_DIR);\n            float dif = clamp((den - denAhead) / 0.6, 0.0, 1.0);\n            float3 lin = float3(1.0, 0.6, 0.3) * dif + float3(0.91, 0.98, 1.05);\n            float3 cloudAlbedo = lerp(float3(1.0, 0.95, 0.8), float3(0.25, 0.3, 0.35), den);\n            float4 col = float4(cloudAlbedo, den);\n            col.rgb *= lin;\n            float fog = 1.0 - exp(-0.003 * t * t);\n            col.rgb = lerp(col.rgb, bgcol, fog);\n            col.a *= 0.4;\n            col.rgb *= col.a;\n            sum += col * (1.0 - sum.a);\n        }\n        t += max(0.06, 0.05 * t);\n    }\n\n    return saturate(sum);\n}\n\n// Cielo + sol + glare (igual que GLSL)\nfloat4 Render(float3 ro, float3 rd, int2 px)\n{\n    float sun = saturate(dot(SUN_DIR, rd));\n    float3 col = float3(0.6, 0.71, 0.75) - rd.y * 0.2 * float3(1.0, 0.5, 1.0) + 0.075;\n    col += 0.2 * float3(1.0, 0.6, 0.1) * pow(sun, 8.0);\n\n    float4 res = Raymarch(ro, rd, col, px);\n    col = col * (1.0 - res.a) + res.rgb;\n    col += float3(0.2, 0.08, 0.04) * pow(sun, 3.0);\n    return float4(col, 1.0);\n}\n\n//----------------------\n// Fullscreen VS/PS\n//----------------------\nstruct VSIn  { float3 pos : POSITION; float2 uv : TEXCOORD0; };\nstruct VSOut { float4 pos : SV_Position; float2 uv : TEXCOORD0; };\n\nVSOut VSMain(VSIn vin)\n{\n    VSOut o;\n    o.pos = float4(vin.pos.xy, 0.0, 1.0);\n    o.uv  = vin.uv;\n    return o;\n}\n\nfloat4 PSMain(VSOut pin) : SV_Target\n{\n    float2 fragCoord = pin.uv * iResolution;\n    float2 p = (2.0*fragCoord - iResolution) / iResolution.y;\n    float2 m = iMouse / iResolution;\n\n    // Cámara orbital + roll\n    float angle = 3.0 * m.x;\n    float elev  = 0.8 * m.y;\n    float3 ro = 4.0 * normalize(float3(sin(angle), elev, cos(angle))) - float3(0.0, 0.1, 0.0);\n    float3 ta = float3(0.0, -1.0, 0.0);\n    float  roll = 0.07 * cos(0.25 * iTime);\n    float3x3 cam = setCamera(ro, ta, roll);\n\n    float3 rd = mul(cam, normalize(float3(p.xy, 1.5)));\n    int2   px = int2(fragCoord - 0.5);\n\n    return Render(ro, rd, px);\n}",
    "type": "código"
  },
  {
    "id": "f42e5793-209e-48b4-bb83-cfc43b1ed5e9",
    "title": "Clouds",
    "created_at": "2025-08-08T12:06:31.838945+00:00",
    "content": "// ============================================================================\n// Volumetric Cloud / Noise Utilities — HLSL Port (DX11+)\n// Original GLSL snippet converted to HLSL with full comments.\n// This file includes:\n//   - Constants (mirroring your GLSL consts)\n//   - sRGB <-> Linear helpers\n//   - hash13 (float3 -> float) helper\n//   - Worley noise (with a fast Texture3D path and a pure-procedural fallback)\n//   - fbm() built from worley()\n//   - A tiny sample VS/PS to visualize the fbm\n//\n// Notes:\n// - The original GLSL used `texture(iChannel0, p * 0.02)`; here we provide a\n//   Texture3D path because `p` is 3D. If you only have a 2D noise texture,\n//   swap the sampler to Texture2D and pass a 2D coord.\n// - `bool` uniforms aren’t great in cbuffers; we expose them as ints (0/1).\n// - The rest of your cloud raymarch isn’t included (not provided). This gives\n//   you a solid, commented base to plug into your marcher.\n// ============================================================================\n\n#define PI 3.14159265359\n\n// ----------------------------------------------------------------------------\n// Resources\n// ----------------------------------------------------------------------------\n\n// If you have a 3D value-noise texture, bind it here. (Fast path for Worley.)\nTexture3D<float> gNoiseTex3D : register(t0);\n// Sampler for all texture fetches.\nSamplerState      gSampler    : register(s0);\n\n// ----------------------------------------------------------------------------\n// Tunable parameters (mirroring your GLSL constants)\n// In practice, you'd likely move these to a cbuffer so you can tweak at runtime.\n// We’ll keep them as static const to mirror \"const\" from the GLSL.\n// ----------------------------------------------------------------------------\nstatic const float softness           = 0.8;    // Density -> transmittance smoothing\nstatic const float extinction         = 2.0;    // Extinction coefficient for Beer-Lambert\nstatic const float amount             = 0.33;   // Density scalar\nstatic const float height             = 1000.0; // Base cloud layer height (world units)\nstatic const float thickness          = 6000.0; // Cloud layer thickness (world units)\nstatic const float cloud_scale        = 1.0;    // Global scale for noise domain\n\nstatic const float ambient            = 0.2;    // Ambient light term\nstatic const float light_step_factor  = 0.5;    // Secondary march step multiplier\nstatic const float sun_absorb         = 0.9;    // Absorption towards sun light\nstatic const float sky_absorb         = 0.3;    // Absorption towards sky light\nstatic const float forward_scatter    = 0.5;    // Phase approx: forward bias [0..1]\nstatic const float brightness         = 1.0;    // Final brightness scalar\nstatic const int   skylight_enable    = 1;      // Use skylight? (1 = true)\nstatic const int   sunlight_enable    = 1;      // Use sunlight? (1 = true)\n\nstatic const int   iter               = 64;     // Primary march steps (not used in this demo PS)\nstatic const int   light_iter         = 4;      // Light march steps      (not used in this demo PS)\nstatic const float time_scale         = 1.0;    // Time multiplier (animate domain if desired)\n\nstatic const float3 sun_color         = float3(1.1, 0.73, 0.46);\nstatic const float  sun_power         = 0.8;\nstatic const float3 sky_color_base    = float3(0.3, 0.6, 1.3);\nstatic const float  sky_power         = 0.2;\n\nstatic const float  fov_degrees       = 80.0;   // Camera FOV (not used in this demo PS)\nstatic const float  FAR               = 25000.0;// Far plane (not used in this demo PS)\n\n// ----------------------------------------------------------------------------\n// Utility: sRGB <-> Linear conversions (approximate 2.2 gamma)\n// ----------------------------------------------------------------------------\nfloat3 srgb2lrgb(float3 srgb)\n{\n    // Convert sRGB to linear space by raising to ~2.2\n    return pow(srgb, 2.2);\n}\n\nfloat3 lrgb2srgb(float3 lrgb)\n{\n    // Convert linear to sRGB space by raising to ~1/2.2\n    return pow(lrgb, 1.0 / 2.2);\n}\n\n// ----------------------------------------------------------------------------\n// hash13: maps a 3D point to a pseudo-random [0,1) float.\n// Mirrors your GLSL version, adapted to HLSL intrinsics.\n// ----------------------------------------------------------------------------\nfloat hash13(float3 p3)\n{\n    // frac == fract, swizzles use .zxy or .zyx etc.\n    p3 = frac(p3 / 0.1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return frac((p3.x + p3.y) * p3.z);\n}\n\n// ----------------------------------------------------------------------------\n// Worley noise\n// Two paths:\n//   FAST  (recommended): sample a precomputed 3D value/noise texture.\n//   PURE  (fallback):    procedural cell (Worley-like) evaluation.\n//\n// Select path with WORLEY_USE_3D_TEX (1 = Texture3D, 0 = pure-procedural).\n// ----------------------------------------------------------------------------\n#ifndef WORLEY_USE_3D_TEX\n#define WORLEY_USE_3D_TEX 1\n#endif\n\n// Frequency for the texture path (matches your \"* 0.02\" idea).\nstatic const float WORLEY_TEX_FREQ = 0.02;\n\n// PURE path scale (just a tastefully small scale).\nstatic const float WORLEY_PURE_SCALE = 0.5;\n\nfloat worley(float3 p)\n{\n#if WORLEY_USE_3D_TEX\n    // --- FAST PATH -----------------------------------------------------------\n    // Expectation: gNoiseTex3D contains value-noise in [0,1].\n    // We can smooth it slightly to emulate your smoothstep usage.\n    float n = gNoiseTex3D.SampleLevel(gSampler, p * WORLEY_TEX_FREQ, 0.0f);\n    // Smoothstep(0,1,x) == x*x*(3-2*x); but the texture should already be normalized.\n    // You can tweak this curve further if you want harder/softer cells.\n    float s = saturate(n * n * (3 - 2 * n));\n    return s;\n#else\n    // --- PURE PROCEDURAL PATH -----------------------------------------------\n    // A tiny 3x3x3 neighborhood cell evaluation (not strictly canonical Worley,\n    // but close enough for cloud breakup and keeps the spirit of your fallback).\n    p *= WORLEY_PURE_SCALE;\n\n    float3 i = floor(p);\n    float3 f = p - i;\n\n    float w = 1e9;\n    // Unrolled-ish triple loop for clarity.\n    [unroll]\n    for (int x = -1; x <= 1; ++x)\n    {\n        [unroll]\n        for (int y = -1; y <= 1; ++y)\n        {\n            [unroll]\n            for (int z = -1; z <= 1; ++z)\n            {\n                float3 cell = float3(x, y, z);\n                // Random feature point inside the neighbor cell:\n                float3 h = frac(i + cell + hash13(i + cell));\n                float3 d = f - cell - h;\n                w = min(w, dot(d, d));\n            }\n        }\n    }\n\n    // Classic \"distance to nearest feature\" variant: smaller = nearer.\n    // Invert + sqrt to get a 0..1-ish feel similar to GLSL’s return.\n    return 1.0 - sqrt(max(w, 0.0));\n#endif\n}\n\n// ----------------------------------------------------------------------------\n// fbm (fractal brownian motion) built from worley()\n// Mirrors your partial GLSL; adds reasonable domain warp & octave accumulation.\n// ----------------------------------------------------------------------------\nfloat fbm(float3 p)\n{\n    const int octaves = 6;\n\n    float s = 0.0;  // Sum\n    float m = 0.0;  // Sum of weights (to normalize)\n    float a = 1.0;  // Amplitude\n\n    // Basic octave accumulation with slight domain offset per octave\n    [unroll]\n    for (int o = 0; o < octaves; ++o)\n    {\n        s += a * worley(p);\n        m += a;\n\n        // Prepare next octave:\n        // Increase frequency and reduce amplitude\n        p = p * 2.0 + float3(37.0, 17.0, 11.0);\n        a *= 0.5;\n    }\n\n    // Normalize to ~[0,1]\n    return (m > 0.0) ? (s / m) : 0.0;\n}\n\n// ============================================================================\n// Minimal VS/PS to visualize the noise quickly\n// (Replace with your own pipeline / raymarcher as needed.)\n// ============================================================================\n\n// Simple vertex input (pos, uv).\nstruct VSIn\n{\n    float3 pos : POSITION;\n    float2 uv  : TEXCOORD0;\n};\n\nstruct VSOut\n{\n    float4 posH : SV_Position;\n    float2 uv   : TEXCOORD0;\n};\n\n// Pass-through full-screen triangle/quad VS\nVSOut VSMain(VSIn v)\n{\n    VSOut o;\n    o.posH = float4(v.pos, 1.0);\n    o.uv   = v.uv;\n    return o;\n}\n\n// A small constants buffer for time (e.g., to animate domain)\ncbuffer FrameCB : register(b0)\n{\n    float gTime;       // seconds\n    float3 _pad0;\n}\n\n// Pixel shader: visualize fbm noise in sRGB.\n// Replace p construction with your world-space domain in a real cloud shader.\nfloat4 PSMain(VSOut i) : SV_Target\n{\n    // Build a 3D point for fbm:\n    // - xy from screen uv, zoomed a bit\n    // - z from time (so it crawls)\n    float3 p = float3(i.uv * 200.0, gTime * time_scale * 0.25);\n\n    // Evaluate fbm in [0..1]\n    float n = fbm(p * cloud_scale);\n\n    // Optional soft-contrast curve to mimic cloud-ish look\n    float d = saturate(pow(n, softness));\n\n    // Tint a bit towards sky/sun palette to hint how you’d mix lighting later\n    float3 base = lerp(sky_color_base * sky_power, sun_color * sun_power, d);\n\n    // Apply global brightness and go to sRGB for display\n    float3 color = lrgb2srgb(saturate(base * brightness));\n\n    return float4(color, 1.0);\n}",
    "type": "código"
  },
  {
    "id": "023b92e0-a79c-496a-861e-16a18d418f8a",
    "title": "float4 PS_Main(VS_OUTPUT input) : SV_TARGET {     float t = input.lifeT;      // Fade in/out suave     float fade = smoothstep(0.0, 0.1, t) * (1.0 - smoothstep(0.9, 1.0, t));      return float4(1, 1, 1, fade); // RGB blanco con alpha animado }",
    "created_at": "2025-08-06T12:15:30.461417+00:00",
    "content": "Fade",
    "type": "código"
  },
  {
    "id": "ae902862-fa46-4c23-b854-7e0594753062",
    "title": "Statelessmagic",
    "created_at": "2025-08-06T10:28:51.810504+00:00",
    "content": "cbuffer Params : register(b0)\n{\n    float3 boxSize;         // Tamaño del volumen de spawn (ej: float3(200,200,100))\n    float3 moveDirection;   // Dirección de movimiento (normalizada, ej: float3(0,1,0))\n    float  moveSpeed;       // Velocidad base del movimiento (ej: 50.0)\n    float  minLife;         // Vida mínima (ej: 2.0)\n    float  maxLife;         // Vida máxima (ej: 5.0)\n    float  time;            // Tiempo global (segundos)\n    float4x4 WorldViewProj; // Matriz de transformación completa\n};\n\nstruct VS_INPUT\n{\n    float3 position : POSITION; // Posición local (centrado en 0,0,0)\n    float4 color    : COLOR;    // Alpha = semilla random única por card\n};\n\nstruct VS_OUTPUT\n{\n    float4 position : SV_POSITION;\n    float4 color    : COLOR;\n};\n\n// Devuelve un valor random entre 0–1 desde una semilla\nfloat Random1(float seed)\n{\n    return frac(sin(seed * 12.9898) * 43758.5453);\n}\n\n// Devuelve un vector3 random entre 0–1 desde una semilla\nfloat3 Random3(float seed)\n{\n    return frac(sin(float3(seed, seed + 31.1, seed + 72.7)) * 43758.5453);\n}\n\nVS_OUTPUT VS_Main(VS_INPUT input)\n{\n    VS_OUTPUT output;\n\n    float rand = input.color.a; // Valor random único por card (bakeado)\n\n    // 1. Vida de la carta\n    float lifeRange = maxLife - minLife;\n    float lifeSpan = minLife + Random1(rand * 123.456) * lifeRange;\n\n    // 2. Número de ciclo actual (cuántas veces ha \"respawneado\")\n    float cycles = floor((time + rand * 10.0) / lifeSpan);\n    float cycleStartTime = cycles * lifeSpan;\n    float localTime = time - cycleStartTime;\n\n    // 3. Nueva semilla por ciclo (para que cada ciclo tenga diferente spawn)\n    float uniqueCycleSeed = rand + cycles * 0.731;\n\n    // 4. Posición random dentro de la box\n    float3 randOffset = (Random3(uniqueCycleSeed) - 0.5f) * boxSize;\n\n    // 5. Movimiento hacia la dirección con velocidad\n    float3 motion = moveDirection * moveSpeed * localTime;\n\n    // 6. Posición final en mundo\n    float3 finalPos = randOffset + motion + input.position; // input.position = offset local del quad\n\n    // 7. Transformar a clip space\n    output.position = mul(float4(finalPos, 1.0), WorldViewProj);\n\n    // 8. Fade según vida (opcional)\n    float fade = saturate(1.0 - (localTime / lifeSpan));\n    output.color = float4(fade, fade, fade, fade); // RGB igual, o solo usar .a si el pixel shader lo usa\n\n    return output;\n}",
    "type": "código"
  },
  {
    "id": "701ecb76-5e78-4969-9d76-3f281e6ada85",
    "title": "Helpme",
    "created_at": "2025-08-06T09:36:07.337135+00:00",
    "content": "struct VS_INPUT\n{\n    float3 position : POSITION;\n    float4 color    : COLOR; // alpha = random\n};\n\nstruct VS_OUTPUT\n{\n    float4 position : SV_POSITION;\n    float4 color    : COLOR;\n};\n\nfloat3 Random3(float seed)\n{\n    // Simple 3D noise from scalar (you can improve this)\n    return frac(sin(float3(seed, seed + 13.1, seed + 37.7)) * 43758.5453);\n}\n\nVS_OUTPUT VS_Main(VS_INPUT input)\n{\n    VS_OUTPUT output;\n\n    float rand = input.color.a;\n\n    // Aleatorio 3D por elemento\n    float3 rand3 = Random3(rand);\n\n    // Spawn position inside box centered at pivot\n    float3 halfBox = boxSize * 0.5;\n    float3 localOffset = (rand3 - 0.5) * boxSize; // rango -0.5 a 0.5\n    float3 spawnPos = pivot + localOffset;\n\n    // Movimiento\n    float3 motion = moveDirection * (rand * time * moveAmount);\n\n    // Posición final\n    float3 worldPos = spawnPos + motion;\n\n    output.position = mul(float4(worldPos, 1.0), WorldViewProj);\n    output.color = input.color;\n    return output;\n}",
    "type": "Chat"
  },
  {
    "id": "a688b5ee-ef45-48db-a7ba-6b38958a1d86",
    "title": "Billiegin",
    "created_at": "2025-08-06T09:26:36.512006+00:00",
    "content": "cbuffer Params : register(b0)\n{\n    float3 bboxMin;        // bounding box minimum\n    float3 bboxMax;        // bounding box maximum\n    float3 moveDirection;  // normalized direction vector\n    float  moveAmount;     // movement strength multiplier\n    float  time;           // global time\n};\n\nstruct VS_INPUT\n{\n    float3 position : POSITION;\n    float4 color    : COLOR; // alpha = random per element\n};\n\nstruct VS_OUTPUT\n{\n    float4 position : SV_POSITION;\n    float4 color    : COLOR;\n};\n\nVS_OUTPUT VS_Main(VS_INPUT input)\n{\n    VS_OUTPUT output;\n\n    float rand = input.color.a;\n\n    // Position inside bounding box\n    float3 bboxRange = bboxMax - bboxMin;\n    float3 localOffset = frac(rand * float3(12.9898, 78.233, 37.719)) * bboxRange;\n    float3 spawnPos = bboxMin + localOffset;\n\n    // Motion over time\n    float3 motion = moveDirection * (rand * time * moveAmount);\n\n    // Final position\n    float3 worldPos = spawnPos + motion;\n\n    // Output\n    output.position = mul(float4(worldPos, 1.0), WorldViewProj); // or your WVP matrix\n    output.color = input.color;\n    return output;\n}",
    "type": "código"
  },
  {
    "id": "b5413cb6-f15f-4beb-b5b4-7f0c28054100",
    "title": "Thunder",
    "created_at": "2025-06-17T13:42:19.11855+00:00",
    "content": "float hash(float x) {\n    return frac(sin(x * 123.456) * 45678.123);\n}\n\n// Devuelve intensidad de un flash basado en el tiempo\nfloat lightningFlash(float time, float seed) {\n    float t = frac(time * 10.0 + seed);\n    float flash = exp(-50.0 * t); // caída rápida de intensidad\n    flash *= step(t, 0.1);        // solo activa en el primer tramo\n    return flash;\n}\n\n// Genera una secuencia de rayos (flashes) con tiempos aleatorios\nfloat simulateLightning(float time, float stormSeed) {\n    float intensity = 0.0;\n    for (int i = 0; i < 4; i++) {\n        float offset = floor(time) + i * 0.73;\n        float seed = hash(offset + stormSeed);\n        float flashTime = offset + seed * 1.5;\n        intensity += lightningFlash(time - flashTime, seed);\n    }\n\n    return saturate(intensity * 2.5); // intensifica el resultado\n}",
    "type": "código"
  },
  {
    "id": "98b55917-382e-4bbf-b6ad-bcfb3e688191",
    "title": "Uview",
    "created_at": "2025-06-16T12:10:19.655255+00:00",
    "content": "// Vertex local del quad (por ejemplo -0.5, -0.5, 0)\nfloat3 localPos = v.Position;\n\n// 1. Extrae rotación de la instancia como matriz 3x3\nfloat3x3 instanceRot = (float3x3)instanceWorld;\n\n// 2. Rota el vértice local del quad\nfloat3 rotatedLocalPos = mul(instanceRot, localPos); // respetar rotación Y\n\n// 3. Saca ejes de la cámara desde mul(instanceWorld, uView)\nfloat4x4 worldview = mul(instanceWorld, uView);\n\n// Cada columna de la matriz contiene el eje en view space, transformado por la instancia\nfloat3 camRight = normalize(float3(worldview[0][0], worldview[1][0], worldview[2][0]));\nfloat3 camUp    = normalize(float3(worldview[0][1], worldview[1][1], worldview[2][1]));\n\n// 4. Usa esos ejes para construir la posición del vértice en espacio mundo\nfloat3 worldPos = instanceWorld[3].xyz\n                + camRight * rotatedLocalPos.x\n                + camUp    * rotatedLocalPos.y;\n\n// 5. Transforma a clip space\nfloat4 posView = mul(float4(worldPos, 1.0), uView);\nfloat4 posClip = mul(posView, uProj);",
    "type": "código"
  },
  {
    "id": "68d14500-411d-4609-925e-a6fb07b71a62",
    "title": "Wrap",
    "created_at": "2025-06-16T09:09:07.556853+00:00",
    "content": "// Textura de entrada (gradiente lineal)\nTexture2D gradientTex : register(t0);\nSamplerState samplerState : register(s0);\n\n// Parámetros de animación\nfloat time;             // Tiempo externo (puede venir del motor)\nfloat lightWidth = 0.2; // Ancho de la \"ventana\" de luz (0 a 1)\nfloat speed = 0.5;      // Velocidad de paneo\n\n// Entrada UV por fragmento/píxel\nfloat2 uv : TEXCOORD0;\n\nfloat4 main(float2 uv : TEXCOORD0) : SV_Target\n{\n    // Color base del gradiente (asumimos que va en eje X)\n    float base = gradientTex.Sample(samplerState, uv).r;\n\n    // Centro de la luz que se mueve de 0 a 1 en bucle\n    float lightCenter = frac(time * speed);\n\n    // Distancia entre uv.x y la luz, considerando envolvimiento cíclico\n    float dist = abs(uv.x - lightCenter);\n    dist = min(dist, 1.0 - dist); // wrap-around: el gradiente \"conecta\" en los bordes\n\n    // Creamos una máscara suave de luz según esa distancia\n    float halfWidth = lightWidth * 0.5;\n    float mask = smoothstep(halfWidth, halfWidth - 0.01, dist);\n\n    // Resultado: solo se ilumina la parte dentro de la ventana de luz\n    float lit = base * mask;\n\n    return float4(lit.xxx, 1.0); // RGB gris con alpha 1\n}",
    "type": "código"
  },
  {
    "id": "a22fbdb7-9e91-47e4-9db4-b9e307d8520a",
    "title": "Este",
    "created_at": "2025-06-13T12:34:23.798792+00:00",
    "content": "// Inputs\nTexture2D gradientTex : register(t0);\nSamplerState samplerState : register(s0);\n\n// Parámetros de animación\nfloat time;             // Tiempo externo\nfloat lightWidth = 0.2; // Tamaño de la \"ventana de luz\"\nfloat speed = 0.5;      // Velocidad de paneo\n\n// Entrada de UV\nfloat2 uv : TEXCOORD0;\n\nfloat4 main(float2 uv : TEXCOORD0) : SV_Target\n{\n    // Leemos el color base de la textura (asumimos un gradiente horizontal en UV.x)\n    float baseColor = gradientTex.Sample(samplerState, uv).r;\n\n    // Calculamos la posición del centro de la luz en [0, 1]\n    float lightCenter = frac(time * speed);\n\n    // Borde de la luz\n    float halfWidth = lightWidth * 0.5;\n    float lightStart = lightCenter - halfWidth;\n    float lightEnd   = lightCenter + halfWidth;\n\n    // Creamos una máscara suave de luz usando smoothstep para bordes suaves\n    float mask = smoothstep(lightStart, lightStart + 0.01, uv.x) * \n                 (1.0 - smoothstep(lightEnd - 0.01, lightEnd, uv.x));\n\n    // Resultado: base del gradiente afectado solo por la luz que se mueve\n    float lit = baseColor * mask;\n\n    return float4(lit.xxx, 1.0); // Gris iluminado\n}",
    "type": "código"
  },
  {
    "id": "0382f24b-044f-43c1-b7f9-2f5c2735f4e8",
    "title": "Paner",
    "created_at": "2025-06-13T12:06:50.506951+00:00",
    "content": "// Parámetros\nTexture2D gradientTex : register(t0); // Gradiente lineal en X\nSamplerState samplerState : register(s0);\n\nfloat time;             // Tiempo para animación\nfloat lightWidth = 0.2; // Ancho del paneo (porcentaje del gradiente)\nfloat speed = 0.5;      // Velocidad de paneo\n\n// Entrada UV por píxel\nfloat2 uv : TEXCOORD0;\n\nfloat4 main(float2 uv : TEXCOORD0) : SV_Target\n{\n    // Gradiente base\n    float gradient = gradientTex.Sample(samplerState, uv).r;\n\n    // Paneo de luz\n    float lightCenter = frac(time * speed); // Ciclo de 0 a 1\n    float lightStart  = lightCenter - lightWidth * 0.5;\n    float lightEnd    = lightCenter + lightWidth * 0.5;\n\n    // Comprobar si estamos dentro de la zona iluminada\n    float lightMask = smoothstep(lightStart, lightStart + 0.01, uv.x) *\n                      (1.0 - smoothstep(lightEnd - 0.01, lightEnd, uv.x));\n\n    // Composición final\n    float result = gradient * lightMask;\n\n    return float4(result.xxx, 1.0);\n}",
    "type": "código"
  },
  {
    "id": "a65be69f-9ecc-4994-8e59-0225797ba9f9",
    "title": "Queee",
    "created_at": "2025-06-13T09:41:57.065589+00:00",
    "content": "float ComputeLightMask(float3 worldPos, float3 lightPos, float2 uv, Texture2D mask01, Texture2D mask02, SamplerState sampl)\n{\n    float3 lightDir = lightPos - worldPos; // Dirección desde el píxel hacia la luz\n\n    // Muestrea las máscaras\n    float4 mask01Val = mask01.Sample(sampl, uv); // RGBA = Up, Down, Left, Right\n    float4 mask02Val = mask02.Sample(sampl, uv); // R = Front, B = Back\n\n    // Determina qué canal usar según la dirección\n    float xMask = (lightDir.x > 0.0f) ? mask01Val.a : mask01Val.b; // Right : Left\n    float yMask = (lightDir.y > 0.0f) ? mask01Val.r : mask01Val.g; // Up : Down\n    float zMask = (lightDir.z > 0.0f) ? mask02Val.b : mask02Val.r; // Z > 0 = hacia cámara (Back), Z < 0 = adelante (Front)\n\n    // Ponderación por dirección al cuadrado (blending Pythagoras style)\n    float lightMask =\n        xMask * (lightDir.x * lightDir.x) +\n        yMask * (lightDir.y * lightDir.y) +\n        zMask * (lightDir.z * lightDir.z);\n\n    return lightMask;\n}",
    "type": "código"
  },
  {
    "id": "e791bfa1-27e4-4e16-a74d-289f4fcd6292",
    "title": "Ligh",
    "created_at": "2025-06-13T09:35:41.441393+00:00",
    "content": "// Inputs\nfloat3 worldPos;   // posición del píxel\nfloat3 lightPos;   // posición de la luz\nfloat2 uv;         // coordenadas UV\nTexture2D mask01;  // RGBA = up, down, left, right\nTexture2D mask02;  // R = front, B = back\nSamplerState sampl;\n\n// Parámetros configurables\nfloat3 directionWeights = float3(1.0, 1.0, 1.0); // x = left/right, y = up/down, z = front/back\nfloat blendSoftness = 0.5; // distancia en unidades a partir de la cual empieza el blending\n\n// Vector de diferencia\nfloat3 delta = worldPos - lightPos;\n\n// Blending suave por eje (a más distancia en una dirección, más contribuye ese lado)\nfloat up     = saturate( delta.y / blendSoftness);   // +Y\nfloat down   = saturate(-delta.y / blendSoftness);   // -Y\nfloat right  = saturate( delta.x / blendSoftness);   // +X\nfloat left   = saturate(-delta.x / blendSoftness);   // -X\nfloat back   = saturate( delta.z / blendSoftness);   // +Z (hacia la cámara)\nfloat front  = saturate(-delta.z / blendSoftness);   // -Z (hacia adelante)\n\n// Aplicar pesos de importancia por eje\nup    *= directionWeights.y;\ndown  *= directionWeights.y;\nleft  *= directionWeights.x;\nright *= directionWeights.x;\nfront *= directionWeights.z;\nback  *= directionWeights.z;\n\n// Samplear las máscaras\nfloat4 m1 = mask01.Sample(sampl, uv); // RGBA = up, down, left, right\nfloat4 m2 = mask02.Sample(sampl, uv); // R = front, B = back\n\n// Mezclar usando los pesos suaves\nfloat finalMask =\n    m1.r * up +\n    m1.g * down +\n    m1.b * left +\n    m1.a * right +\n    m2.r * front +\n    m2.b * back;",
    "type": "código"
  },
  {
    "id": "5613f718-6d78-49fb-857b-a5bdf9fb6b56",
    "title": "Aswagh",
    "created_at": "2025-06-13T07:11:27.136802+00:00",
    "content": "VertexOutput VS_Main(VertexInput input)\n{\n    VertexOutput o;\n\n    float4 worldPos = mul(instanceTransform, float4(input.position, 1.0));\n    o.worldPos = worldPos.xyz;\n\n    float3x3 rotationScale = (float3x3)instanceTransform;\n    float3x3 normalMatrix = transpose(inverse(rotationScale));\n\n    o.normal = normalize(mul(normalMatrix, input.normal));\n    o.tangent = normalize(mul(rotationScale, input.tangent));\n    o.uv = input.uv;\n\n    o.position = mul(ViewProjectionMatrix, worldPos);\n    return o;\n}",
    "type": "código"
  },
  {
    "id": "1381a8fe-d089-4a51-a65d-8d92ff46eef8",
    "title": "Circular",
    "created_at": "2025-06-12T07:47:57.607233+00:00",
    "content": "cbuffer TimeBuffer : register(b0)\n{\n    float Time;           // Global time in seconds\n    float Radius;         // Radius of circular motion\n    float Speed;          // Rotation speed in radians/sec\n    float Padding;\n};\n\nstruct VS_INPUT\n{\n    float3 position : POSITION;  // Local position of vertex\n    float2 uv       : TEXCOORD0; // UV coordinates\n    float3 center   : TEXCOORD1; // World-space center of the cloud card\n};\n\nstruct VS_OUTPUT\n{\n    float4 position : SV_POSITION;\n    float2 uv       : TEXCOORD0;\n};\n\nVS_OUTPUT main(VS_INPUT input)\n{\n    VS_OUTPUT output;\n\n    // Calculate current angle\n    float angle = Time * Speed;\n\n    // Compute new XZ position around Y axis\n    float x = input.center.x + cos(angle) * Radius;\n    float z = input.center.z + sin(angle) * Radius;\n\n    // Apply the circular motion to the card's center\n    float3 rotatedCenter = float3(x, input.center.y, z);\n\n    // Final world position of the vertex\n    float3 worldPos = rotatedCenter + input.position;\n\n    // Transform to clip space (assume you have a matrix somewhere)\n    extern float4x4 WorldViewProjection;\n    output.position = mul(float4(worldPos, 1.0), WorldViewProjection);\n\n    output.uv = input.uv;\n    return output;\n}",
    "type": "código"
  },
  {
    "id": "32a2879e-33b8-491d-8e8a-ce7114c2a8bf",
    "title": "Mall",
    "created_at": "2025-06-05T13:24:13.021895+00:00",
    "content": "float3 GetDirectionPreset_Compare(float3 dir)\n{\n    // Define your presets\n    float3 presetXPos = float3(5.0, 6.0, 3.0);\n    float3 presetXNeg = float3(7.0, 5.2, 8.9);\n    float3 presetYPos = float3(1.0, 2.0, 3.0);\n    float3 presetYNeg = float3(4.0, 5.0, 6.0);\n    float3 presetZPos = float3(0.1, 0.2, 0.3);\n    float3 presetZNeg = float3(0.9, 0.8, 0.7);\n\n    // Compare explicitly\n    if (dir.x > 0.0) return presetXPos;\n    if (dir.x < 0.0) return presetXNeg;\n    if (dir.y > 0.0) return presetYPos;\n    if (dir.y < 0.0) return presetYNeg;\n    if (dir.z > 0.0) return presetZPos;\n    if (dir.z < 0.0) return presetZNeg;\n\n    // Fallback if dir is zero (optional)\n    return float3(0, 0, 0);\n}",
    "type": "código"
  },
  {
    "id": "30838638-1bf5-47ae-b22c-279be04fd5d8",
    "title": "Comparj",
    "created_at": "2025-06-05T13:23:23.163268+00:00",
    "content": "// Preset float3 values\nfloat3 presetXPos = float3(5.0, 6.0, 3.0);\nfloat3 presetXNeg = float3(7.0, 5.2, 8.9);\nfloat3 presetYPos = float3(1.0, 2.0, 3.0);\nfloat3 presetYNeg = float3(4.0, 5.0, 6.0);\nfloat3 presetZPos = float3(0.1, 0.2, 0.3);\nfloat3 presetZNeg = float3(0.9, 0.8, 0.7);\n\n// Direction input — only one component should be non-zero at a time\nfloat3 dir = inputDirection; // e.g. float3(0, -1, 0)\n\n// Compute weights branchlessly\nfloat xPosW = max(0, dir.x);\nfloat xNegW = max(0, -dir.x);\nfloat yPosW = max(0, dir.y);\nfloat yNegW = max(0, -dir.y);\nfloat zPosW = max(0, dir.z);\nfloat zNegW = max(0, -dir.z);\n\n// Final output without branching\nfloat3 result =\n    presetXPos * xPosW +\n    presetXNeg * xNegW +\n    presetYPos * yPosW +\n    presetYNeg * yNegW +\n    presetZPos * zPosW +\n    presetZNeg * zNegW;",
    "type": "código"
  },
  {
    "id": "63d4fb4d-b6b0-4cd0-904e-39d055d9a563",
    "title": "Line",
    "created_at": "2025-06-05T08:05:52.130017+00:00",
    "content": "float GetMaskFromLine(float3 point, float3 center, float3 target, float radius)\n{\n    float3 lineDir = target - center;\n    float lineLen = length(lineDir);\n    float3 dirNorm = lineDir / (lineLen + 1e-5);\n\n    float3 vecToPoint = point - center;\n    float t = dot(vecToPoint, dirNorm); // project onto the line direction\n\n    // Clamp to the segment range\n    t = clamp(t, 0.0, lineLen);\n\n    float3 closestPoint = center + dirNorm * t;\n    float dist = distance(point, closestPoint);\n\n    // Mask: 1 if within radius, 0 otherwise\n    return step(dist, radius); // outputs 1 if dist < radius, 0 if not\n}",
    "type": "código"
  },
  {
    "id": "e08dea1c-4a92-4afc-9d16-fac1e9ffa0de",
    "title": "Sinusoi",
    "created_at": "2025-05-26T12:00:51.011401+00:00",
    "content": "float2 uv = input.uv; // UVs de 0 a 1, ya mapeadas para dar la vuelta\nfloat timeSpeed = 0.5; // velocidad del paneo\nfloat sharpness = 2.0; // controla qué tan definida es la ola\n\n// Movimiento cíclico a lo largo de la U (puedes añadir offset con el tiempo)\nfloat uAnim = frac(uv.x - time * timeSpeed);\n\n// Ola simétrica: una sinusoide absoluta\nfloat wave = abs(sin(uAnim * 2 * 3.14159));\n\n// Ajuste de contraste (más recortada la ola si se desea)\nfloat mask = pow(wave, sharpness);\n\n// Resultado: una máscara que da vueltas al modelo y se repite infinitamente\nreturn mask;",
    "type": "código"
  },
  {
    "id": "51b68a45-da24-4759-9f04-0532bc679e56",
    "title": "Test",
    "created_at": "2025-05-22T12:04:17.746561+00:00",
    "content": "cbuffer Params : register(b0)\n{\n    float time;\n    float waveAmplitude;\n    float waveFrequency;\n    float waveSpeed;\n}\n\nstruct VSInput\n{\n    float3 position : POSITION;\n    float3 normal   : NORMAL;\n    float2 uv       : TEXCOORD0;\n};\n\nstruct VSOutput\n{\n    float4 position : SV_POSITION;\n    float2 uv       : TEXCOORD0;\n};\n\nVSOutput VSMain(VSInput input)\n{\n    VSOutput output;\n\n    float u = input.uv.x;\n\n    // Wave function based on UV.x and time\n    float wave = sin((u + time * waveSpeed) * 2.0 * 3.14159 * waveFrequency);\n\n    // Final displacement mask: UV-based wave * amplitude\n    float displacement = wave * waveAmplitude;\n\n    // Move along normal\n    float3 displacedPosition = input.position + input.normal * displacement;\n\n    output.position = mul(float4(displacedPosition, 1.0), WorldViewProjection);\n    output.uv = input.uv;\n\n    return output;\n}",
    "type": "código"
  },
  {
    "id": "e131238d-1b21-4921-986f-3a81ffc409e4",
    "title": "Vscode",
    "created_at": "2025-05-19T07:53:40.402043+00:00",
    "content": "{\n    // See https://go.microsoft.com/fwlink/?LinkId=733558\n    // for the documentation about the tasks.json format\n    \"version\": \"2.0.0\",\n    \"tasks\": [\n       {\n          \"label\": \"Execute Script in 3ds Max\",\n          \"type\": \"shell\",\n          \"command\": \"C:\\\\Program Files\\\\MXSPyCOM\\\\MXSPyCOM-master\\\\bin\\\\Release\\\\net6.0-windows\\\\win-x64\\\\MXSPyCOM.exe\",\n          \"args\": [\n             \"-s\",\n             \"${file}\"\n          ],\n          \"presentation\": {\n             \"echo\": false,\n             \"reveal\": \"never\",\n             \"focus\": false,\n             \"panel\": \"dedicated\"\n          },\n          \"problemMatcher\": [],\n       }\n    ]\n}",
    "type": "código"
  },
  {
    "id": "3a9a14c6-5f08-47de-b79a-0df475c32eb5",
    "title": "Heyy",
    "created_at": "2025-05-13T07:21:18.494524+00:00",
    "content": "float hash(float n) {\n    return frac(sin(n) * 43758.5453123);\n}\n\nfloat lightningMask(float time, float frequency) {\n    // Ajusta el tiempo según la frecuencia deseada\n    float t = time * frequency;\n\n    float a = sin(t * 3.1 + hash(floor(t * 0.2) + 1.23) * 6.28);\n    float b = sin(t * 7.3 + hash(floor(t * 0.1) + 4.56) * 6.28);\n    float c = sin(t * 13.7 + hash(floor(t * 0.07) + 7.89) * 6.28);\n\n    float combined = (a + b * 0.5 + c * 0.25) * 0.4 + 0.5;\n\n    // Umbral puede ajustarse también si quieres más o menos sensibilidad\n    return step(0.98, combined);\n}",
    "type": "código"
  },
  {
    "id": "d0e82104-0ee1-4794-8d5c-cd0b4868a8c4",
    "title": "Rempa",
    "created_at": "2025-05-12T16:31:52.605533+00:00",
    "content": "float lightning(float t) {\n    // Escala del tiempo para frecuencia base\n    float baseTime = t * 0.5;\n\n    // Combinamos ondas para dar variedad y pseudoaleatoriedad\n    float wave = sin(baseTime * 3.0 + sin(baseTime * 1.7) * 6.2831);\n    wave *= sin(baseTime * 1.3 + cos(baseTime * 2.1) * 4.0);\n\n    // Aumentar picos: elevar al cubo y recortar negativos\n    wave = max(0.0, pow(wave, 3.0));\n\n    // Umbral para activar relámpago\n    float trigger = step(0.8, wave); // Solo cuando el pico es alto\n\n    // Pulso suave (apagado tipo \"fade\")\n    float fade = smoothstep(0.8, 0.0, wave); // va de 1 a 0\n\n    // Combinamos: activo con fade-out\n    return max(trigger, fade);\n}",
    "type": "código"
  },
  {
    "id": "2a9938d6-ae0f-4a03-9846-d191c3e5cec5",
    "title": "Hah",
    "created_at": "2025-05-12T15:03:03.370846+00:00",
    "content": "// Project the 3D world position to clip space\nfloat4 clipPos = mul(float4(playerWorldPos, 1.0), ViewProjMatrix);\n\n// Convert to NDC (Normalized Device Coordinates)\nclipPos.xyz /= clipPos.w;\n\n// Convert NDC [-1,1] to UV [0,1]\nfloat2 playerScreenUV = clipPos.xy * 0.5 + 0.5;\n\n// Now compare screen-space UVs to player screen UV\nfloat dist = distance(uv, playerScreenUV);\n\n// Create a circle mask using distance\nfloat radius = 0.1; // Adjust to your desired size\nfloat softness = 0.01; // Optional: feathered edge\n\n// Circle mask: 1.0 inside the circle, 0.0 outside, with smooth edge\nfloat circleMask = smoothstep(radius, radius - softness, dist);\n\n// Use this mask to affect color or opacity\nreturn float4(circleMask, circleMask, circleMask, 1.0);",
    "type": "código"
  },
  {
    "id": "710a9b5c-8e53-4484-8d75-b18251502fbb",
    "title": "Snep",
    "created_at": "2025-05-12T13:18:35.804275+00:00",
    "content": "float mist = z.mist;\n\n// Tramo 1: [0.25, 0.35] mapeado a [0.0, 0.5]\nfloat a = saturate((mist - 0.25) / (0.35 - 0.25)) * 0.5;\n\n// Tramo 2: [0.35, 1.0] mapeado a [0.5, 1.0]\nfloat b = saturate((mist - 0.35) / (1.0 - 0.35)) * 0.5 + 0.5;\n\n// Combinar ambos, el segundo tramo sobrescribe al primero si mist > 0.35\nfloat result = max(a, b);",
    "type": "código"
  },
  {
    "id": "78e26758-c10a-4be9-a40c-8285858e071b",
    "title": "Snipp",
    "created_at": "2025-05-12T13:11:20.573803+00:00",
    "content": "float mist = z.mist;\nfloat result = 0.0;\n\nif (mist < 0.25)\n{\n    result = 0.0;\n}\nelse if (mist < 0.35)\n{\n    // Remapea de [0.25, 0.35] a [0.0, 0.5]\n    result = (mist - 0.25) / (0.35 - 0.25) * 0.5;\n}\nelse\n{\n    // Remapea de [0.35, 1.0] a [0.5, 1.0]\n    result = 0.5 + (mist - 0.35) / (1.0 - 0.35) * 0.5;\n}\n\n// Ahora `result` va de 0 a 1 con la forma que querías",
    "type": "código"
  },
  {
    "id": "7945c34f-a344-4e73-92e5-77e4e439c132",
    "title": "Sphere",
    "created_at": "2025-05-09T14:23:20.425599+00:00",
    "content": "float3 dir = normalize(pos); // Position in object or world space, normalized\n\n// 1. Accurate spherical projection (uses trig)\nfloat u1 = 0.5 + atan2(dir.z, dir.x) / (2.0 * 3.14159265); // longitude\nfloat v1 = 0.5 - asin(dir.y) / 3.14159265;                 // latitude\nfloat2 uvAccurate = float2(u1, v1);\n\n// 2. Medium-cost version (skip asin)\nfloat u2 = 0.5 + atan2(dir.z, dir.x) / (2.0 * 3.14159265); // longitude\nfloat v2 = dir.y * 0.5 + 0.5;                              // approximation of latitude\nfloat2 uvMedium = float2(u2, v2);\n\n// 3. Cheap version (only normalize + scale)\nfloat2 uvCheap = dir.xy * 0.5 + 0.5; // crude projection\n\n// Use any of the above:\n// return uvAccurate;\n// return uvMedium;\n// return uvCheap;",
    "type": "código"
  },
  {
    "id": "14432464-eb47-4e87-86fe-4f59d77d3b19",
    "title": "Max03",
    "created_at": "2025-04-27T20:42:20.334336+00:00",
    "content": "rollout ImportFBXRollout \"DemBones Importer FBX\"\r\n(\r\n    editText edtName \"Geometry name:\" text:\"\" width:220\r\n    button btnImport \"Select and Import FBX\" width:220 height:40\r\n\r\n    on btnImport pressed do\r\n    (\r\n        local fbxFile = getOpenFileName caption:\"Select FBX File\" types:\"FBX Files (*.fbx)|*.fbx|All Files (*.*)|*.*|\"\r\n\r\n        if fbxFile != undefined do\r\n        (\r\n            local layerName = \"dembones\"\r\n            local dembonesLayer = LayerManager.getLayerFromName layerName\r\n            if dembonesLayer == undefined do\r\n                dembonesLayer = LayerManager.newLayerFromName layerName\r\n\r\n            local existingNodes = objects as array\r\n\r\n            importFile fbxFile #noPrompt using:FBXIMP\r\n\r\n            local allNodes = objects as array\r\n            local geoName = edtName.text\r\n            if geoName == \"\" do geoName = getFilenameFile maxFileName\r\n\r\n -- Create DC_Root dummy at origin\r\n            local dcRoot = Dummy name:\"DC_Root\"\r\n            dcRoot.position = [0,0,0]\r\n            dembonesLayer.addNode dcRoot\r\n\r\n            local importedObjects = #()\r\n\r\n            for n in allNodes do\r\n            (\r\n                if findItem existingNodes n == 0 do\r\n                (\r\n                    dembonesLayer.addNode n\r\n                    append importedObjects n\r\n\r\n                    if isKindOf n GeometryClass do\r\n                        n.name = geoName\r\n\r\n-- Adjust Skin Bone Affect Limit to 4\r\n                    for m in n.modifiers do\r\n                    (\r\n                        if classof m == Skin do\r\n                        (\r\n                            local currentLimit = getProperty m #bone_Limit\r\n                            local targetLimit = 4\r\n\r\n                            while currentLimit > targetLimit do\r\n                            (\r\n                                currentLimit -= 1\r\n                                setProperty m #bone_Limit currentLimit\r\n                                forceCompleteRedraw()\r\n                                sleep 0.01\r\n                            )\r\n                        )\r\n                    )\r\n                )\r\n            )\r\n\r\n -- Parent all imported objects to DC_Root\r\n            for obj in importedObjects do\r\n                obj.parent = dcRoot\r\n\r\n            messageBox (\"Created: \" + geoName) title:\"Done\"\r\n        )\r\n    )\r\n)\r\n\r\ncreateDialog ImportFBXRollout width:250 height:160\r\nImportFBXRollout.edtName.text = getFilenameFile maxFileName\r\n",
    "type": "código"
  },
  {
    "id": "9dda6689-92a7-43dc-bb0a-910d9a206b2e",
    "title": "Max02",
    "created_at": "2025-04-27T20:41:07.148517+00:00",
    "content": "-- Auxiliary functions\r\nfn pointMin a b = [amin a.x b.x, amin a.y b.y, amin a.z b.z]\r\nfn pointMax a b = [amax a.x b.x, amax a.y b.y, amax a.z b.z]\r\n\r\nrollout GradientVertexPainter \"Gradient Vertex Painter\"\r\n(\r\n    groupBox grpSettings \"Channels\" pos:[10,10] width:220 height:70\r\n    checkbox chkRed \"Red\" pos:[20,30] checked:false\r\n    checkbox chkGreen \"Green\" pos:[80,30] checked:false\r\n    checkbox chkBlue \"Blue\" pos:[140,30] checked:false\r\n    checkbox chkAlpha \"Alpha\" pos:[20,50] checked:true\r\n\r\n    groupBox grpSpace \"Coordinate Space\" pos:[10,90] width:220 height:50\r\n    radiobuttons rbSpace \"\" labels:#(\"World\", \"Local\") pos:[20,110] columns:2 default:1\r\n\r\n    checkbox chkInvert \"Invert Gradient\" pos:[20,150] checked:false\r\n    button btnPaint \"Paint Gradient\" pos:[20,180] width:200 height:40\r\n\r\n    on btnPaint pressed do\r\n    (\r\n        if selection.count == 0 then\r\n        (\r\n            messageBox \"Please select at least one object.\" title:\"No Selection\"\r\n        )\r\n        else\r\n        (\r\n            for obj in selection do\r\n            (\r\n                if isKindOf obj GeometryClass then\r\n                (\r\n                    -- Save original rotation\r\n                    local originalRotation = obj.rotation\r\n\r\n                    if rbSpace.state == 2 do\r\n                    (\r\n                        -- If Local mode: reset rotation temporarily\r\n                        obj.rotation = quat 0 0 0 1\r\n                    )\r\n\r\n                    -- Convert to Editable Mesh\r\n                    convertToMesh obj\r\n                    update obj\r\n\r\n                    local numVerts = getNumVerts obj\r\n\r\n                    -- Ensure vertex color and alpha support\r\n                    if not meshop.getMapSupport obj 0 do meshop.setMapSupport obj 0 true\r\n                    meshop.setNumMapVerts obj 0 numVerts\r\n                    if not meshop.getMapSupport obj -2 do meshop.setMapSupport obj -2 true\r\n                    meshop.setNumMapVerts obj -2 numVerts\r\n\r\n                    -- Calculate bounding range\r\n                    local minVal = 1e9\r\n                    local maxVal = -1e9\r\n                    local localZ = normalize obj.objecttransform.row3\r\n\r\n                    for v = 1 to numVerts do\r\n                    (\r\n                        local pos = getVert obj v\r\n                        local worldPos = pos * obj.objecttransform\r\n                        local value = if rbSpace.state == 1 then (worldPos.z) else (dot worldPos localZ)\r\n                        minVal = amin minVal value\r\n                        maxVal = amax maxVal value\r\n                    )\r\n\r\n                    local bboxHeight = maxVal - minVal\r\n                    if bboxHeight == 0 then bboxHeight = 0.001\r\n\r\n                    -- Paint vertices\r\n                    for v = 1 to numVerts do\r\n                    (\r\n                        local pos = getVert obj v\r\n                        local worldPos = pos * obj.objecttransform\r\n                        local value = if rbSpace.state == 1 then (worldPos.z) else (dot worldPos localZ)\r\n\r\n                        local normalized = (value - minVal) / bboxHeight\r\n                        if chkInvert.checked then normalized = 1.0 - normalized\r\n\r\n                        if chkAlpha.checked and not (chkRed.checked or chkGreen.checked or chkBlue.checked) then\r\n                        (\r\n                            meshop.setMapVert obj -2 v [normalized, normalized, normalized]\r\n                        )\r\n                        else\r\n                        (\r\n                            local color = meshop.getMapVert obj 0 v\r\n                            if chkRed.checked then color.x = normalized\r\n                            if chkGreen.checked then color.y = normalized\r\n                            if chkBlue.checked then color.z = normalized\r\n                            meshop.setMapVert obj 0 v color\r\n                        )\r\n                    )\r\n\r\n                    -- Set map faces properly\r\n                    for f = 1 to getNumFaces obj do\r\n                    (\r\n                        local verts = getFace obj f\r\n                        if chkAlpha.checked and not (chkRed.checked or chkGreen.checked or chkBlue.checked) then\r\n                        (\r\n                            meshop.setMapFace obj -2 f verts\r\n                        )\r\n                        else\r\n                        (\r\n                            meshop.setMapFace obj 0 f verts\r\n                        )\r\n                    )\r\n\r\n                    -- Restore original rotation\r\n                    if rbSpace.state == 2 do\r\n                    (\r\n                        obj.rotation = originalRotation\r\n                    )\r\n\r\n                    -- Convert back to Editable Poly\r\n                    convertToPoly obj\r\n                    update obj\r\n                )\r\n                else\r\n                (\r\n                    messageBox \"Selected object must be a geometry.\" title:\"Invalid Object\"\r\n                )\r\n            )\r\n        )\r\n    )\r\n)\r\n\r\ncreateDialog GradientVertexPainter width:260 height:260\r\n",
    "type": "código"
  },
  {
    "id": "4d584218-1b56-4541-865b-6ef89b638951",
    "title": "Ful",
    "created_at": "2025-04-22T09:01:58.162753+00:00",
    "content": "// Parámetros\nfloat3 _CameraWorldPos;   // posición actual de la cámara\nfloat cellSize = 10.0;     // tamaño del bloque (salto en chunks)\nfloat scale = 0.1;         // escala del ruido\n\n// Ruido base (hash, noise3D, fbm) — igual que antes\nfloat hash(float3 p) {\n    p = frac(p * 0.3183099 + 0.1);\n    p *= 17.0;\n    return frac(p.x * p.y * p.z * (p.x + p.y + p.z));\n}\n\nfloat noise3D(float3 p) {\n    float3 i = floor(p);\n    float3 f = frac(p);\n    f = f * f * (3.0 - 2.0 * f);\n\n    float n000 = hash(i + float3(0,0,0));\n    float n100 = hash(i + float3(1,0,0));\n    float n010 = hash(i + float3(0,1,0));\n    float n110 = hash(i + float3(1,1,0));\n    float n001 = hash(i + float3(0,0,1));\n    float n101 = hash(i + float3(1,0,1));\n    float n011 = hash(i + float3(0,1,1));\n    float n111 = hash(i + float3(1,1,1));\n\n    float n00 = lerp(n000, n100, f.x);\n    float n10 = lerp(n010, n110, f.x);\n    float n01 = lerp(n001, n101, f.x);\n    float n11 = lerp(n011, n111, f.x);\n\n    float n0 = lerp(n00, n10, f.y);\n    float n1 = lerp(n01, n11, f.y);\n\n    return lerp(n0, n1, f.z);\n}\n\nfloat fbm(float3 p) {\n    float v = 0.0;\n    float a = 0.5;\n    for (int i = 0; i < 5; ++i) {\n        v += a * noise3D(p);\n        p *= 2.0;\n        a *= 0.5;\n    }\n    return v;\n}\n\n// Estructura del fragment shader\nstruct V2F {\n    float4 pos : SV_POSITION;\n    float3 vWorld : TEXCOORD0; // posición del fragmento en el mundo\n};\n\n// Shader principal\nfloat4 PS_CameraCompensatedNoise(V2F i) : SV_Target {\n    float3 worldPos = i.vWorld;\n\n    // 1. Snapea la posición de la cámara a una celda del mundo\n    float3 chunkOrigin = floor(_CameraWorldPos / cellSize) * cellSize;\n\n    // 2. Desplazamiento de la cámara dentro de esa celda\n    float3 offset = _CameraWorldPos - chunkOrigin;\n\n    // 3. Compensación del movimiento: mover el ruido en sentido contrario a la cámara\n    float3 samplePos = worldPos - chunkOrigin + offset;\n\n    // 4. Evaluar ruido\n    float density = fbm(samplePos * scale);\n    float clouds = smoothstep(0.4, 0.6, density);\n\n    float3 color = lerp(float3(0.5, 0.6, 0.8), float3(1.0, 1.0, 1.0), clouds);\n    return float4(color, 1.0);\n}",
    "type": "código"
  },
  {
    "id": "2b20a0bd-6130-4000-8798-a1b15ec4009a",
    "title": "Idk man",
    "created_at": "2025-04-22T08:50:29.764036+00:00",
    "content": "// Parámetros globales\nfloat3 _CameraWorldPos;   // posición de la cámara (jugador)\nfloat cellSize = 10.0;     // tamaño del voxel o celda\nfloat scale = 0.1;         // escala del ruido\n\n// Funciones de ruido\nfloat hash(float3 p) {\n    p = frac(p * 0.3183099 + 0.1);\n    p *= 17.0;\n    return frac(p.x * p.y * p.z * (p.x + p.y + p.z));\n}\n\nfloat noise3D(float3 p) {\n    float3 i = floor(p);\n    float3 f = frac(p);\n    f = f * f * (3.0 - 2.0 * f);\n\n    float n000 = hash(i + float3(0,0,0));\n    float n100 = hash(i + float3(1,0,0));\n    float n010 = hash(i + float3(0,1,0));\n    float n110 = hash(i + float3(1,1,0));\n    float n001 = hash(i + float3(0,0,1));\n    float n101 = hash(i + float3(1,0,1));\n    float n011 = hash(i + float3(0,1,1));\n    float n111 = hash(i + float3(1,1,1));\n\n    float n00 = lerp(n000, n100, f.x);\n    float n10 = lerp(n010, n110, f.x);\n    float n01 = lerp(n001, n101, f.x);\n    float n11 = lerp(n011, n111, f.x);\n\n    float n0 = lerp(n00, n10, f.y);\n    float n1 = lerp(n01, n11, f.y);\n\n    return lerp(n0, n1, f.z);\n}\n\nfloat fbm(float3 p) {\n    float v = 0.0;\n    float a = 0.5;\n    for (int i = 0; i < 5; ++i) {\n        v += a * noise3D(p);\n        p *= 2.0;\n        a *= 0.5;\n    }\n    return v;\n}\n\n// Entrada del fragment shader (ajústalo a tu sistema)\nstruct V2F {\n    float4 pos : SV_POSITION;\n    float3 vWorld : TEXCOORD0; // posición del fragmento en el mundo\n};\n\nfloat4 PS_WorldAnchoredNoise(V2F i) : SV_Target {\n    float3 worldPos = i.vWorld;\n\n    // Paso 1: celda mundial en la que está la cámara\n    float3 snappedChunkOrigin = floor(_CameraWorldPos / cellSize) * cellSize;\n\n    // Paso 2: evalúa la posición relativa al centro de la celda actual\n    float3 localPos = worldPos - snappedChunkOrigin;\n\n    // Ahora el ruido se queda fijo en el mundo\n    float3 staticNoisePos = localPos;\n\n    // Evaluación del ruido\n    float density = fbm(staticNoisePos * scale);\n    float clouds = smoothstep(0.4, 0.6, density);\n\n    float3 baseColor = lerp(float3(0.5, 0.6, 0.8), float3(1.0, 1.0, 1.0), clouds);\n\n    return float4(baseColor, 1.0);\n}",
    "type": "código"
  },
  {
    "id": "126d5af9-be8a-4b4d-ba5c-932f3a63aa4d",
    "title": "Redde",
    "created_at": "2025-04-22T08:32:39.089043+00:00",
    "content": "// Parámetros globales\nfloat3 _CameraWorldPos;   // posición de la cámara en el mundo\nfloat3 _ObjectWorldPos;   // posición del objeto (la esfera)\nfloat cellSize = 10.0;    // tamaño del bloque en unidades del mundo\nfloat scale = 0.1;        // escala del ruido 3D\n\n// Funciones de ruido\nfloat hash(float3 p) {\n    p = frac(p * 0.3183099 + 0.1);\n    p *= 17.0;\n    return frac(p.x * p.y * p.z * (p.x + p.y + p.z));\n}\n\nfloat noise3D(float3 p) {\n    float3 i = floor(p);\n    float3 f = frac(p);\n    f = f * f * (3.0 - 2.0 * f); // smoothstep de Perlin\n\n    float n000 = hash(i + float3(0,0,0));\n    float n100 = hash(i + float3(1,0,0));\n    float n010 = hash(i + float3(0,1,0));\n    float n110 = hash(i + float3(1,1,0));\n    float n001 = hash(i + float3(0,0,1));\n    float n101 = hash(i + float3(1,0,1));\n    float n011 = hash(i + float3(0,1,1));\n    float n111 = hash(i + float3(1,1,1));\n\n    float n00 = lerp(n000, n100, f.x);\n    float n10 = lerp(n010, n110, f.x);\n    float n01 = lerp(n001, n101, f.x);\n    float n11 = lerp(n011, n111, f.x);\n\n    float n0 = lerp(n00, n10, f.y);\n    float n1 = lerp(n01, n11, f.y);\n\n    return lerp(n0, n1, f.z);\n}\n\nfloat fbm(float3 p) {\n    float v = 0.0;\n    float a = 0.5;\n    for (int i = 0; i < 5; ++i) {\n        v += a * noise3D(p);\n        p *= 2.0;\n        a *= 0.5;\n    }\n    return v;\n}\n\n// Estructura de entrada del pixel shader (ajústala según tu pipeline)\nstruct V2F {\n    float4 pos : SV_POSITION;\n    float3 vWorld : TEXCOORD0; // posición del fragmento en mundo\n};\n\n// Pixel shader\nfloat4 PS_AnchoredNoise(V2F i) : SV_Target {\n    float3 worldPos = i.vWorld;\n\n    // Paso 1: obtener el bloque \"snappeado\" al que pertenece el objeto\n    float3 snappedChunkOrigin = floor(_ObjectWorldPos / cellSize) * cellSize;\n\n    // Paso 2: obtener el desplazamiento del objeto dentro del bloque\n    float3 objectOffset = _ObjectWorldPos - snappedChunkOrigin;\n\n    // Paso 3: ajustar la posición para que el ruido no se mueva dentro del bloque\n    float3 localPos = worldPos - snappedChunkOrigin;\n    float3 staticNoisePos = localPos + objectOffset;\n\n    // Paso 4: evaluar el ruido\n    float density = fbm(staticNoisePos * scale);\n    float clouds = smoothstep(0.4, 0.6, density);\n\n    // Color base (puedes cambiarlo)\n    float3 baseColor = lerp(float3(0.5, 0.6, 0.8), float3(1.0, 1.0, 1.0), clouds);\n\n    return float4(baseColor, 1.0);\n}",
    "type": "código"
  },
  {
    "id": "a398a505-cc6d-4df4-aff1-7dbf8c0a9950",
    "title": "Redemption2",
    "created_at": "2025-04-22T07:24:29.221727+00:00",
    "content": "float4 PS_AnchoredNoise(V2F i) : SV_Target {\n    float cellSize = 10.0;\n    float scale = 0.1;\n\n    // Posición del fragmento en el mundo (i.vWorld)\n    float3 worldPos = i.vWorld.xyz;\n\n    // Calcula a qué celda pertenece el objeto (jugador/esfera)\n    float3 snappedChunkOrigin = floor(_ObjectWorldPos / cellSize) * cellSize;\n\n    // Esta es la celda \"actual\", fija\n    // Ahora restamos esta celda al fragmento para obtener una posición RELATIVA A LA CELDA\n    float3 localPos = worldPos - snappedChunkOrigin;\n\n    // Pero aquí viene la clave: también restamos el movimiento del objeto DENTRO de su celda\n    float3 offset = _ObjectWorldPos - snappedChunkOrigin;\n\n    // Así el ruido se \"ancla\" y no se mueve aunque el objeto se mueva dentro del chunk\n    float3 staticNoisePos = localPos + offset;\n\n    // Evalúa el ruido mundialmente fijo\n    float density = fbm(staticNoisePos * scale);\n    float clouds = smoothstep(0.4, 0.6, density);\n    float3 color = lerp(float3(0.5, 0.6, 0.8), float3(1.0, 1.0, 1.0), clouds);\n\n    return float4(color, 1.0);\n}",
    "type": "código"
  },
  {
    "id": "1b54c6e5-38d7-4676-bec6-5ec77a19aec5",
    "title": "Redemption",
    "created_at": "2025-04-22T07:24:03.477777+00:00",
    "content": "float3 worldPos = i.vWorld.xyz;\nfloat3 cellSize = float3(10.0, 10.0, 10.0);\n\n// Posición fraccional dentro de la celda\nfloat3 cellCoord = worldPos / cellSize;\nfloat3 cellBase = floor(cellCoord);\nfloat3 frac = frac(cellCoord);\n\n// Inicializar el valor de ruido interpolado\nfloat noiseValue = 0.0;\n\n// Iterar sobre los 8 vértices del cubo\nfor (int x = 0; x <= 1; x++) {\n    for (int y = 0; y <= 1; y++) {\n        for (int z = 0; z <= 1; z++) {\n            float3 offset = float3(x, y, z);\n            float3 samplePos = (cellBase + offset) * cellSize;\n            float weight = (x == 0 ? 1.0 - frac.x : frac.x) *\n                           (y == 0 ? 1.0 - frac.y : frac.y) *\n                           (z == 0 ? 1.0 - frac.z : frac.z);\n            noiseValue += fbm(samplePos * scale) * weight;\n        }\n    }\n}\n\n// Aplicar el valor de ruido interpolado\nfloat clouds = smoothstep(0.4, 0.6, noiseValue);\nfloat3 color = lerp(float3(0.5, 0.6, 0.8), float3(1.0, 1.0, 1.0), clouds);\nreturn float4(color, 1.0);",
    "type": "código"
  },
  {
    "id": "45d5aa8d-7d48-4376-b765-34b003342950",
    "title": "Concentric",
    "created_at": "2025-04-21T12:12:39.506295+00:00",
    "content": "float hash(float3 p) {\n    p = frac(p * 0.3183099 + 0.1);\n    p *= 17.0;\n    return frac(p.x * p.y * p.z * (p.x + p.y + p.z));\n}\n\nfloat noise3D(float3 p) {\n    float3 i = floor(p);\n    float3 f = frac(p);\n    f = f * f * (3.0 - 2.0 * f); // smoothstep\n\n    float n000 = hash(i + float3(0,0,0));\n    float n100 = hash(i + float3(1,0,0));\n    float n010 = hash(i + float3(0,1,0));\n    float n110 = hash(i + float3(1,1,0));\n    float n001 = hash(i + float3(0,0,1));\n    float n101 = hash(i + float3(1,0,1));\n    float n011 = hash(i + float3(0,1,1));\n    float n111 = hash(i + float3(1,1,1));\n\n    float n00 = lerp(n000, n100, f.x);\n    float n10 = lerp(n010, n110, f.x);\n    float n01 = lerp(n001, n101, f.x);\n    float n11 = lerp(n011, n111, f.x);\n\n    float n0 = lerp(n00, n10, f.y);\n    float n1 = lerp(n01, n11, f.y);\n\n    return lerp(n0, n1, f.z);\n}\n\nfloat fbm(float3 p) {\n    float v = 0.0;\n    float a = 0.5;\n    for (int i = 0; i < 4; ++i) {\n        v += a * noise3D(p);\n        p *= 2.0;\n        a *= 0.5;\n    }\n    return v;\n}\n\nfloat4 PS_CloudSphereParallax(V2F i) : SV_Target {\n    float3 worldPos = i.vWorld.xyz;\n\n    float3 sphereCenter = float3(0.0, 0.0, 0.0); // o pon la posición real del centro\n    float3 dirFromCenter = normalize(worldPos - sphereCenter);\n    float distFromCenter = length(worldPos - sphereCenter);\n\n    float scaleBase = 0.03;\n    float finalClouds = 0.0;\n\n    int layers = 6;\n    float layerSpacing = 0.1; // cuán separadas están las capas\n\n    for (int l = 0; l < layers; ++l) {\n        float scale = 1.0 + l * layerSpacing; // esferas más grandes\n        float3 samplePos = sphereCenter + dirFromCenter * (distFromCenter * scale);\n        float3 noiseCoord = samplePos * scaleBase;\n\n        float d = fbm(noiseCoord);\n        float cloudLayer = smoothstep(0.45, 0.6, d);\n\n        float fade = 1.0 - (float)l / (float)(layers); // lejanía = menos opaco\n        finalClouds += cloudLayer * fade;\n    }\n\n    finalClouds = saturate(finalClouds);\n\n    float3 col = lerp(float3(0.6, 0.7, 1.0), float3(1.0, 1.0, 1.0), finalClouds);\n    return float4(col, 1.0);\n}",
    "type": "código"
  },
  {
    "id": "c7c8bbf7-afa6-4a4c-80e7-2d0150b9458f",
    "title": "Layers",
    "created_at": "2025-04-21T11:48:45.234254+00:00",
    "content": "float hash(float3 p) {\n    p = frac(p * 0.3183099 + 0.1);\n    p *= 17.0;\n    return frac(p.x * p.y * p.z * (p.x + p.y + p.z));\n}\n\nfloat noise3D(float3 p) {\n    float3 i = floor(p);\n    float3 f = frac(p);\n    f = f * f * (3.0 - 2.0 * f); // smoothstep\n\n    float n000 = hash(i + float3(0,0,0));\n    float n100 = hash(i + float3(1,0,0));\n    float n010 = hash(i + float3(0,1,0));\n    float n110 = hash(i + float3(1,1,0));\n    float n001 = hash(i + float3(0,0,1));\n    float n101 = hash(i + float3(1,0,1));\n    float n011 = hash(i + float3(0,1,1));\n    float n111 = hash(i + float3(1,1,1));\n\n    float n00 = lerp(n000, n100, f.x);\n    float n10 = lerp(n010, n110, f.x);\n    float n01 = lerp(n001, n101, f.x);\n    float n11 = lerp(n011, n111, f.x);\n\n    float n0 = lerp(n00, n10, f.y);\n    float n1 = lerp(n01, n11, f.y);\n\n    return lerp(n0, n1, f.z);\n}\n\nfloat fbm(float3 p) {\n    float v = 0.0;\n    float a = 0.5;\n    for (int i = 0; i < 4; ++i) {\n        v += a * noise3D(p);\n        p *= 2.0;\n        a *= 0.5;\n    }\n    return v;\n}\n\nfloat4 PS_CloudParallax(V2F i) : SV_Target {\n    float3 worldPos = i.vWorld.xyz;\n    float3 basePos = worldPos * 0.05; // escala general\n\n    float parallaxIntensity = 0.3;\n    int layers = 5;\n    float layerDepth = 1.0;\n\n    float finalClouds = 0.0;\n\n    for (int l = 0; l < layers; ++l) {\n        float depth = l * layerDepth;\n        float3 offset = float3(0, 0, -depth * parallaxIntensity); // hacia delante en tu sistema\n        float3 p = basePos + offset;\n\n        float d = fbm(p);\n        float cloudLayer = smoothstep(0.45, 0.6, d);\n        float fade = 1.0 - (float)l / (float)(layers); // más lejano = más suave\n        finalClouds += cloudLayer * fade;\n    }\n\n    finalClouds = saturate(finalClouds);\n\n    float3 col = lerp(float3(0.6, 0.7, 1.0), float3(1.0, 1.0, 1.0), finalClouds);\n    return float4(col, 1.0);\n}",
    "type": "código"
  },
  {
    "id": "797327a4-deeb-43b2-861a-f03f8ade643d",
    "title": "Clouds2",
    "created_at": "2025-04-21T08:34:33.140994+00:00",
    "content": "float hash(float3 p) {\n    p = frac(p * 0.3183099 + 0.1);\n    p *= 17.0;\n    return frac(p.x * p.y * p.z * (p.x + p.y + p.z));\n}\n\nfloat noise3D(float3 p) {\n    float3 i = floor(p);\n    float3 f = frac(p);\n    f = f * f * (3.0 - 2.0 * f); // smoothstep\n\n    float n000 = hash(i + float3(0,0,0));\n    float n100 = hash(i + float3(1,0,0));\n    float n010 = hash(i + float3(0,1,0));\n    float n110 = hash(i + float3(1,1,0));\n    float n001 = hash(i + float3(0,0,1));\n    float n101 = hash(i + float3(1,0,1));\n    float n011 = hash(i + float3(0,1,1));\n    float n111 = hash(i + float3(1,1,1));\n\n    float n00 = lerp(n000, n100, f.x);\n    float n10 = lerp(n010, n110, f.x);\n    float n01 = lerp(n001, n101, f.x);\n    float n11 = lerp(n011, n111, f.x);\n\n    float n0 = lerp(n00, n10, f.y);\n    float n1 = lerp(n01, n11, f.y);\n\n    return lerp(n0, n1, f.z);\n}\n\nfloat fbm(float3 p) {\n    float v = 0.0;\n    float a = 0.5;\n    for (int i = 0; i < 5; ++i) {\n        v += a * noise3D(p);\n        p *= 2.0;\n        a *= 0.5;\n    }\n    return v;\n}\n\nfloat4 PS_Clouds(V2F i) : SV_Target {\n    float3 worldPos = i.vWorld.xyz;\n    float3 p = worldPos * 0.1; // escala del ruido\n\n    float density = fbm(p + float3(0, 0, _Time.y * 0.1)); // animación en Z\n    float clouds = smoothstep(0.4, 0.6, density); // umbral de nubes\n\n    float3 cloudColor = lerp(float3(0.7, 0.8, 1.0), float3(1.0, 1.0, 1.0), clouds);\n    return float4(cloudColor, 1.0);\n}",
    "type": "código"
  },
  {
    "id": "7e9769a1-36f6-4e53-ab1c-f30ebb0a793a",
    "title": "Noise",
    "created_at": "2025-04-21T08:33:59.53177+00:00",
    "content": "float noise3(float3 p) {\n    float3 i = floor(p);\n    float3 f = frac(p);\n    f = f * f * (3.0 - 2.0 * f);\n\n    float n = dot(i, float3(1.0, 57.0, 113.0));\n    float res = lerp(\n        lerp(\n            lerp(frac(sin(n + 0.0) * 43758.5453), frac(sin(n + 1.0) * 43758.5453), f.x),\n            lerp(frac(sin(n + 57.0) * 43758.5453), frac(sin(n + 58.0) * 43758.5453), f.x),\n            f.y),\n        lerp(\n            lerp(frac(sin(n + 113.0) * 43758.5453), frac(sin(n + 114.0) * 43758.5453), f.x),\n            lerp(frac(sin(n + 170.0) * 43758.5453), frac(sin(n + 171.0) * 43758.5453), f.x),\n            f.y),\n        f.z\n    );\n    return res;\n}\n\nfloat cloudNoise3D(float3 p) {\n    float d = 0;\n    float amp = 0.5;\n    float freq = 1.0;\n    for (int i = 0; i < 4; i++) {\n        d += amp * noise3(p * freq);\n        freq *= 2.0;\n        amp *= 0.5;\n    }\n    return smoothstep(0.4, 0.6, d);\n}\n\nfloat4 PS_CloudsCheap(V2F i) : SV_Target {\n    float3 p = i.vWorld.xyz * 0.05;\n    float n = cloudNoise3D(p + float3(0, 0, _Time.y * 0.05));\n    return float4(lerp(float3(0.7, 0.8, 1.0), float3(1.0, 1.0, 1.0), n), 1.0);\n}",
    "type": "código"
  },
  {
    "id": "aaa9e953-3e3b-4eb8-9273-57c0aacd3435",
    "title": "Mask",
    "created_at": "2025-04-11T08:45:03.074477+00:00",
    "content": "float mask = ...;         // 1 at center, 0 at border\nfloat noise = ...;        // sampled noise in [0,1]\nfloat threshold = 0.5;    // where noise starts to apply\nfloat invThreshold = 1.0 / threshold; // precomputed on CPU or outside shader\nfloat noiseStrength = 1.0; // full noise\n\n// Compute blend factor with multiplication only\nfloat t = saturate((1.0 - mask) * invThreshold); // t = 0 when mask=1, t=1 when mask=0\n\n// Blend noise in\nfloat noisyMask = lerp(mask, mask * noise, t * noiseStrength);",
    "type": "código"
  },
  {
    "id": "f52549fd-30a6-4a4f-b677-6a917ba40c3b",
    "title": "Paintdevert",
    "created_at": "2025-04-10T20:50:00.489176+00:00",
    "content": "-- Utility functions\r\nfn pointMin a b = [amin a.x b.x, amin a.y b.y, amin a.z b.z]\r\nfn pointMax a b = [amax a.x b.x, amax a.y b.y, amax a.z b.z]\r\n\r\n-- Function 1: Bake Element Centers into Vertex Color\r\nfn bakeElementCenters obj =\r\n(\r\n    if isKindOf obj Editable_Poly or classof obj == Editable_Mesh do\r\n    (\r\n        local theMesh = snapshotAsMesh obj\r\n\r\n        local bboxMin = [1e9,1e9,1e9]\r\n        local bboxMax = [-1e9,-1e9,-1e9]\r\n        for v = 1 to theMesh.numverts do\r\n        (\r\n            local pos = getVert theMesh v\r\n            bboxMin = pointMin bboxMin pos\r\n            bboxMax = pointMax bboxMax pos\r\n        )\r\n        local bboxSize = bboxMax - bboxMin\r\n        if bboxSize.x == 0 then bboxSize.x = 0.001\r\n        if bboxSize.y == 0 then bboxSize.y = 0.001\r\n        if bboxSize.z == 0 then bboxSize.z = 0.001\r\n\r\n        local numFaces = theMesh.numfaces\r\n        local faceProcessed = #{}\r\n        local faceElemMap = #()\r\n        local elemID = 0\r\n\r\n        while faceProcessed.numberSet < numFaces do\r\n        (\r\n            local startFace = (for i = 1 to numFaces where not faceProcessed[i] collect i)[1]\r\n            local connected = meshop.getElementsUsingFace theMesh #{startFace}\r\n            elemID += 1\r\n            for f in connected do faceElemMap[f] = elemID\r\n            faceProcessed += connected\r\n        )\r\n\r\n        local elemVerts = for i = 1 to elemID collect #{}\r\n        for f = 1 to numFaces do\r\n        (\r\n            local verts = getFace theMesh f\r\n            local id = faceElemMap[f]\r\n            elemVerts[id][verts.x] = true\r\n            elemVerts[id][verts.y] = true\r\n            elemVerts[id][verts.z] = true\r\n        )\r\n\r\n        meshop.setMapSupport theMesh 0 true\r\n        meshop.setNumMapVerts theMesh 0 theMesh.numverts\r\n\r\n        for i = 1 to elemID do\r\n        (\r\n            local verts = elemVerts[i]\r\n            local center = [0,0,0]\r\n            for v in verts do center += getVert theMesh v\r\n            center /= verts.numberSet\r\n\r\n            local localColor = (center - bboxMin) / bboxSize\r\n            local convertedColor = [localColor.x, localColor.z, 1.0 - localColor.y]\r\n\r\n            format \"Element % â Center: % | Normalized Color (Engine): %\\n\" i center convertedColor\r\n\r\n            for v in verts do\r\n                meshop.setMapVert theMesh 0 v convertedColor\r\n        )\r\n\r\n        for f = 1 to numFaces do\r\n            meshop.setMapFace theMesh 0 f (getFace theMesh f)\r\n\r\n        convertToMesh obj\r\n        obj.mesh = theMesh\r\n        convertToPoly obj\r\n        update obj\r\n    )\r\n)\r\n\r\n-- Function 2: Print real position from selected vertex\r\nfn printSelectedVertexColorPosition obj =\r\n(\r\n    if isKindOf obj Editable_Poly then\r\n    (\r\n        local selVerts = polyOp.getVertSelection obj\r\n        if selVerts.numberSet == 0 then\r\n        (\r\n            messageBox \"No vertex selected!\" title:\"Info\"\r\n        )\r\n        else\r\n        (\r\n            local vertIndex = (selVerts as array)[1]\r\n            local mesh = snapshotAsMesh obj\r\n            local color = meshop.getMapVert mesh 0 vertIndex\r\n\r\n            local bboxMin = [1e9,1e9,1e9]\r\n            local bboxMax = [-1e9,-1e9,-1e9]\r\n            for v = 1 to mesh.numverts do\r\n            (\r\n                local pos = getVert mesh v\r\n                bboxMin = pointMin bboxMin pos\r\n                bboxMax = pointMax bboxMax pos\r\n            )\r\n\r\n            local bboxSize = bboxMax - bboxMin\r\n            if bboxSize.x == 0 then bboxSize.x = 0.001\r\n            if bboxSize.y == 0 then bboxSize.y = 0.001\r\n            if bboxSize.z == 0 then bboxSize.z = 0.001\r\n\r\n            -- Convert color to position using engine axis\r\n            local engineColor = [color.x, color.y, color.z]\r\n            local position = [engineColor.x * bboxSize.x,\r\n                              engineColor.y * bboxSize.y,\r\n                              (1.0 - engineColor.z) * bboxSize.z] + bboxMin\r\n\r\n            format \"Vertex % â Color: % â Reconstructed Position: %\\n\" vertIndex color position\r\n        )\r\n    )\r\n    else\r\n    (\r\n        messageBox \"Select only one Editable Poly Vertex.\" title:\"Error\"\r\n    )\r\n)\r\n\r\n-- UI Tool\r\nrollout ElementCenterPainter \"Element Center Tool\" width:240\r\n(\r\n    button btnBake \"ð¦ Bake Element Centers to Vertex Color\" width:220 height:40\r\n    button btnPrint \"ð¨ Print Selected Vertex Position\" width:220 height:40\r\n\r\n    on btnBake pressed do\r\n    (\r\n        if selection.count > 0 then\r\n        (\r\n            for obj in selection do bakeElementCenters obj\r\n        )\r\n        else\r\n        (\r\n            messageBox \"Please select at least one object.\" title:\"No Selection\"\r\n        )\r\n    )\r\n\r\n    on btnPrint pressed do\r\n    (\r\n        if selection.count == 1 then\r\n        (\r\n            printSelectedVertexColorPosition selection[1]\r\n        )\r\n        else\r\n        (\r\n            messageBox \"Only one editable Poly Object.\" title:\"Error\"\r\n        )\r\n    )\r\n)\r\n\r\ncreateDialog ElementCenterPainter style:#(#style_titlebar, #style_sysmenu, #style_toolwindow)\r\n",
    "type": "código"
  },
  {
    "id": "01df1d56-e986-4ec8-830d-cdee81290c85",
    "title": "Uv lib",
    "created_at": "2025-04-09T21:43:54.866467+00:00",
    "content": "// ==============================\n// UV TRANSFORMATION & FX LIBRARY (HLSL)\n// Librería para manipular coordenadas UV en shaders\n// ==============================\n\n#ifndef UV_TRANSFORM_LIB\n#define UV_TRANSFORM_LIB\n\n//-------------------------------------\n// TRANSFORMACIONES BÁSICAS\n//-------------------------------------\n\n// Escala UV desde su centro\nfloat2 ScaleUV(float2 uv, float2 scale) {\n    return (uv - 0.5) * scale + 0.5;\n}\n\n// Rota las UV alrededor del centro (ángulo en radianes)\nfloat2 RotateUV(float2 uv, float angle) {\n    float2 centered = uv - 0.5;\n    float cosA = cos(angle);\n    float sinA = sin(angle);\n    float2 rotated = float2(\n        centered.x * cosA - centered.y * sinA,\n        centered.x * sinA + centered.y * cosA\n    );\n    return rotated + 0.5;\n}\n\n// Desplaza UV (scroll horizontal y vertical)\nfloat2 ScrollUV(float2 uv, float2 speed, float time) {\n    return uv + speed * time;\n}\n\n// Centro custom para transformar UVs\nfloat2 TransformUV(float2 uv, float2 pivot, float2 scale, float angle, float2 offset) {\n    uv -= pivot;\n    float cosA = cos(angle);\n    float sinA = sin(angle);\n    uv = float2(uv.x * cosA - uv.y * sinA, uv.x * sinA + uv.y * cosA);\n    uv *= scale;\n    uv += pivot + offset;\n    return uv;\n}\n\n//-------------------------------------\n// REPETICIÓN Y TILEADO\n//-------------------------------------\n\n// Tiling clásico\nfloat2 TileUV(float2 uv, float2 tiles) {\n    return frac(uv * tiles);\n}\n\n// Tiling con offset aleatorio por tile\nfloat2 RandomTileUV(float2 uv, float2 tiles, out float2 tileID) {\n    float2 uvTiled = uv * tiles;\n    tileID = floor(uvTiled);\n    return frac(uvTiled);\n}\n\n// Flip aleatorio por tile\nfloat2 RandomFlipTile(float2 uv, float2 tileID) {\n    float hash = frac(sin(dot(tileID, float2(12.9898, 78.233))) * 43758.5453);\n    if (hash < 0.5) uv.x = 1.0 - uv.x;\n    return uv;\n}\n\n//-------------------------------------\n// EFECTOS DE MOVIMIENTO\n//-------------------------------------\n\n// Desplazamiento sinusoidal horizontal/vertical\nfloat2 SinWaveUV(float2 uv, float frequency, float amplitude, float time, bool horizontal) {\n    if (horizontal) {\n        uv.x += sin(uv.y * frequency + time) * amplitude;\n    } else {\n        uv.y += sin(uv.x * frequency + time) * amplitude;\n    }\n    return uv;\n}\n\n// Ondas multidireccionales\nfloat2 MultiWaveUV(float2 uv, float time, float2 freq, float2 amp) {\n    uv.x += sin(uv.y * freq.x + time) * amp.x;\n    uv.y += cos(uv.x * freq.y + time) * amp.y;\n    return uv;\n}\n\n// Scroll en espiral\nfloat2 SpiralScrollUV(float2 uv, float speed, float time) {\n    float2 centered = uv - 0.5;\n    float angle = atan2(centered.y, centered.x) + time * speed;\n    float radius = length(centered);\n    return float2(cos(angle), sin(angle)) * radius + 0.5;\n}\n\n//-------------------------------------\n// DISTORSIONES Y WARPING\n//-------------------------------------\n\n// Warping radial\nfloat2 RadialWarpUV(float2 uv, float intensity) {\n    float2 centered = uv - 0.5;\n    float r = length(centered);\n    float angle = atan2(centered.y, centered.x);\n    r = pow(r, intensity);\n    return float2(cos(angle), sin(angle)) * r + 0.5;\n}\n\n// Warping tipo \"fisheye\"\nfloat2 FisheyeUV(float2 uv, float strength) {\n    float2 centered = uv * 2.0 - 1.0;\n    float r = dot(centered, centered);\n    float2 distorted = centered * (1.0 + strength * r);\n    return (distorted * 0.5 + 0.5);\n}\n\n// Distorsión polar\nfloat2 PolarDistortUV(float2 uv, float time, float strength) {\n    float2 centered = uv - 0.5;\n    float angle = atan2(centered.y, centered.x);\n    float radius = length(centered);\n    angle += sin(time + radius * 10.0) * strength;\n    return float2(cos(angle), sin(angle)) * radius + 0.5;\n}\n\n//-------------------------------------\n// EFECTOS AVANZADOS\n//-------------------------------------\n\n// Kaleidoscopio UV (reflejo en segmentos angulares)\nfloat2 KaleidoscopeUV(float2 uv, float segments) {\n    float2 centered = uv - 0.5;\n    float angle = atan2(centered.y, centered.x);\n    float radius = length(centered);\n    float mirrored = fmod(abs(angle), 2.0 * 3.14159 / segments);\n    angle = mirrored;\n    return float2(cos(angle), sin(angle)) * radius + 0.5;\n}\n\n// Flip UV por eje X o Y\nfloat2 FlipUV(float2 uv, bool flipX, bool flipY) {\n    return float2(flipX ? 1.0 - uv.x : uv.x, flipY ? 1.0 - uv.y : uv.y);\n}\n\n// Desplazamiento por ruido (requiere textura de ruido o función externa)\nfloat2 NoiseDistortUV(float2 uv, sampler2D noiseTex, float2 noiseScale, float2 strength, float time) {\n    float2 noiseUV = uv * noiseScale + time;\n    float2 n = tex2D(noiseTex, noiseUV).rg * 2.0 - 1.0;\n    return uv + n * strength;\n}\n\n//-------------------------------------\n// DEBUG / UTILIDADES VISUALES\n//-------------------------------------\n\n// Visualiza el checkerboard en UV space\nfloat CheckerUV(float2 uv, float2 scale) {\n    float2 check = floor(uv * scale);\n    return fmod(check.x + check.y, 2.0);\n}\n\n// Visualiza borde de UV (útil para detectar errores de distorsión)\nfloat BorderUV(float2 uv, float thickness) {\n    float border = step(uv.x, thickness) + step(uv.y, thickness) +\n                   step(1.0 - uv.x, thickness) + step(1.0 - uv.y, thickness);\n    return clamp(border, 0.0, 1.0);\n}\n\n#endif",
    "type": "código"
  },
  {
    "id": "0ffef3b9-a29f-4af5-a982-501f767fe5da",
    "title": "Movimiento",
    "created_at": "2025-04-09T21:31:46.675225+00:00",
    "content": "// ==============================\n// TRANSFORM & VFX UTILITY LIBRARY (HLSL)\n// Funciones útiles para distancias, rotaciones, órbitas, desplazamientos y efectos visuales\n// Para uso técnico y artístico\n// ==============================\n\n#ifndef TRANSFORM_VFX_LIB\n#define TRANSFORM_VFX_LIB\n\n// -------------------------------\n// BÁSICOS DE TRANSFORMACIÓN\n// -------------------------------\n\n// Distancia entre dos puntos 3D\nfloat Distance3D(float3 a, float3 b) {\n    return length(b - a);\n}\n\n// Distancia en plano XZ (2D)\nfloat Distance2D(float3 a, float3 b) {\n    return length(a.xz - b.xz);\n}\n\n// Dirección normalizada entre dos puntos\nfloat3 DirectionTo(float3 from, float3 to) {\n    return normalize(to - from);\n}\n\n// Mueve un punto en una dirección dada, con velocidad y tiempo\nfloat3 MovePoint(float3 pos, float3 dir, float speed, float time) {\n    return pos + normalize(dir) * speed * time;\n}\n\n// Interpolación suave entre dos puntos\nfloat3 SmoothMove(float3 a, float3 b, float t) {\n    return lerp(a, b, smoothstep(0.0, 1.0, t));\n}\n\n// Proyección de un punto sobre un plano definido por un punto y normal\nfloat3 ProjectOnPlane(float3 point, float3 planePoint, float3 planeNormal) {\n    float3 toPoint = point - planePoint;\n    return point - dot(toPoint, planeNormal) * planeNormal;\n}\n\n// Refleja un punto respecto a una normal\nfloat3 ReflectOverPlane(float3 point, float3 normal) {\n    return point - 2 * dot(point, normal) * normal;\n}\n\n// -------------------------------\n// ROTACIONES Y EJES\n// -------------------------------\n\n// Rota un punto alrededor del eje Y\nfloat3 RotateAroundY(float3 pos, float angleRadians) {\n    float cosA = cos(angleRadians);\n    float sinA = sin(angleRadians);\n    float3 result = pos;\n    result.x = pos.x * cosA - pos.z * sinA;\n    result.z = pos.x * sinA + pos.z * cosA;\n    return result;\n}\n\n// Rota un punto alrededor de un pivote en eje Y\nfloat3 RotateAroundPivotY(float3 pos, float3 pivot, float angleRadians) {\n    float3 local = pos - pivot;\n    local = RotateAroundY(local, angleRadians);\n    return pivot + local;\n}\n\n// Devuelve ejes ortogonales a partir de un vector \"forward\"\nvoid GetOrthogonalAxes(float3 forward, out float3 right, out float3 up) {\n    forward = normalize(forward);\n    float3 worldUp = float3(0, 1, 0);\n    right = normalize(cross(worldUp, forward));\n    up = normalize(cross(forward, right));\n}\n\n// -------------------------------\n// EFECTOS DE ÓRBITA Y MOVIMIENTO CIRCULAR\n// -------------------------------\n\n// Movimiento circular en el plano XZ\nfloat3 CircularOrbitXZ(float3 center, float radius, float angleRadians) {\n    float x = center.x + cos(angleRadians) * radius;\n    float z = center.z + sin(angleRadians) * radius;\n    return float3(x, center.y, z);\n}\n\n// Órbita elíptica con control de escala en X y Z\nfloat3 EllipticalOrbitXZ(float3 center, float2 radii, float angleRadians) {\n    float x = center.x + cos(angleRadians) * radii.x;\n    float z = center.z + sin(angleRadians) * radii.y;\n    return float3(x, center.y, z);\n}\n\n// Movimiento en espiral creciente\nfloat3 SpiralMotion(float3 center, float angleRadians, float radiusGrowth, float heightGrowth) {\n    float radius = angleRadians * radiusGrowth;\n    float height = angleRadians * heightGrowth;\n    return float3(\n        center.x + cos(angleRadians) * radius,\n        center.y + height,\n        center.z + sin(angleRadians) * radius\n    );\n}\n\n// Movimiento circular horizontal (XY)\nfloat2 CircularMotion2D(float2 center, float radius, float angleRadians) {\n    return center + float2(cos(angleRadians), sin(angleRadians)) * radius;\n}\n\n// -------------------------------\n// VFX OFFSET - RUIDO Y ONDAS\n// -------------------------------\n\n// Offset vertical con onda senoidal\nfloat3 SinWaveOffsetY(float3 pos, float frequency, float amplitude, float time) {\n    pos.y += sin(time * frequency + pos.x * 0.5) * amplitude;\n    return pos;\n}\n\n// Offset direccional con ondas en 3D\nfloat3 SineWaveDeform(float3 pos, float frequency, float amplitude, float time) {\n    pos.x += sin(pos.y * frequency + time) * amplitude;\n    pos.z += cos(pos.y * frequency + time) * amplitude;\n    return pos;\n}\n\n// Desplazamiento simple por ruido Perlin (requiere función noise)\nfloat3 NoiseOffset(float3 pos, float scale, float amplitude, float time) {\n    float n = noise(pos * scale + time);\n    return pos + n * amplitude;\n}\n\n// -------------------------------\n// TRANSFORMACIONES PERSONALIZADAS\n// -------------------------------\n\n// Mover un punto a lo largo de un eje local\nfloat3 MoveAlongAxis(float3 pos, float3 origin, float3 axisDir, float amount) {\n    return pos + normalize(axisDir) * amount;\n}\n\n// Aplica \"look-at\" rotación (devuelve matriz básica orientada)\nfloat3x3 LookAtMatrix(float3 from, float3 to, float3 upDir) {\n    float3 forward = normalize(to - from);\n    float3 right = normalize(cross(upDir, forward));\n    float3 up = cross(forward, right);\n    return float3x3(right, up, forward);\n}\n\n// -------------------------------\n// USO DE EJEMPLO (EN SHADER O FUNCIÓN)\n// -------------------------------\n/*\n\nfloat3 pos = float3(0, 0, 0);\nfloat time = _Time.y;\n\n// Movimiento en círculo\nfloat3 orbitPos = CircularOrbitXZ(float3(0, 0, 0), 2.0, time);\n\n// Onda vertical\nfloat3 wave = SinWaveOffsetY(pos, 3.0, 0.5, time);\n\n// Espiral ascendente\nfloat3 spiral = SpiralMotion(float3(0, 0, 0), time, 0.2, 0.1);\n\n// Rotación sobre eje\nfloat3 rotated = RotateAroundY(pos, time);\n\n// Offset de ruido (requiere función de ruido o textura)\nfloat3 noisy = NoiseOffset(pos, 1.0, 0.2, time);\n\n*/\n\n#endif",
    "type": "código"
  },
  {
    "id": "9dda9f77-957a-4285-950e-ea0a5c92eef9",
    "title": "Undefined 2",
    "created_at": "2025-04-09T21:25:19.776691+00:00",
    "content": "=== Parámetros globales configurables desde CPU ===\r\ncbuffer BoundingBoxData : register(b0)\r\n{\r\n    float3 boxMin;     // Esquina mínima del bounding box donde puede aparecer el rayo\r\n    float3 boxMax;     // Esquina máxima del bounding box\r\n    float g_fTime;     // Tiempo global en segundos, usado para animar los rayos\r\n}\r\n\r\n// === Funciones auxiliares ===\r\n\r\n// Hash simple: valor pseudoaleatorio en [0, 1) a partir de un número\r\nfloat hash(float n) \r\n{\r\n    return frac(sin(n) * 43758.5453);\r\n}\r\n\r\n// Genera un vector 3D pseudoaleatorio usando una semilla\r\nfloat3 rand3(float seed)\r\n{\r\n    return float3(\r\n        hash(seed),             // X\r\n        hash(seed + 19.1),      // Y\r\n        hash(seed + 73.7)       // Z\r\n    );\r\n}\r\n\r\n// Remapea linealmente t de un rango a otro: [inMin, inMax] → [outMin, outMax]\r\nfloat linearMap(float t, float inMin, float inMax, float outMin, float outMax)\r\n{\r\n    float f = saturate((t - inMin) / (inMax - inMin));\r\n    return lerp(outMin, outMax, f);\r\n}\r\n\r\n// === Genera un único punto de rayo y su intensidad actual (si está activo) ===\r\nvoid GetLightning(out float3 position, out float intensity)\r\n{\r\n    // Valores por defecto: rayo inactivo\r\n    position = float3(-9999.0, -9999.0, -9999.0); // Sentinel para rayo no activo\r\n    intensity = 0.0;\r\n\r\n    // Cada ~10 segundos se genera un nuevo ciclo de rayo\r\n    float cycleSeed = floor(g_fTime / 10.0);\r\n\r\n    // Intervalo aleatorio entre rayos (2.5 a 5.5 segundos)\r\n    float interval = 2.5 + hash(cycleSeed + 1.0) * 3.0;\r\n\r\n    // Duración del flash (0.15 a 0.4 segundos)\r\n    float lifeTime = 0.15 + hash(cycleSeed + 2.0) * 0.25;\r\n\r\n    // Offset aleatorio dentro del intervalo (evita sincronización)\r\n    float offset = hash(cycleSeed + 3.0) * interval;\r\n\r\n    // Tiempo normalizado dentro del intervalo actual (va de 0 a 1)\r\n    float localTime = frac((g_fTime + offset) / interval);\r\n\r\n    // Máscara para activar el rayo solo si está dentro de su vida útil\r\n    float isActive = step(localTime, lifeTime / interval); // 1 si activo, 0 si no\r\n\r\n    // Calculamos los valores solo si está activo (sin if real)\r\n    float t = localTime * (interval / lifeTime); // Normalizado 0–1 durante el flash\r\n    float fade = saturate(1.0 - abs(t * 2.0 - 1.0)); // Fade in/out en forma de triángulo\r\n\r\n    float3 randPos = rand3(cycleSeed);\r\n    float3 boxSize = boxMax - boxMin;\r\n    float3 generatedPos = boxMin + randPos * boxSize;\r\n\r\n    float minIntensity = 0.4;\r\n    float maxIntensity = 1.5;\r\n    float generatedIntensity = linearMap(fade, 0.0, 1.0, minIntensity, maxIntensity);\r\n\r\n    // Multiplicamos por la máscara en lugar de usar if\r\n    position = lerp(position, generatedPos, isActive);       // Si isActive = 1, usamos la posición generada\r\n    intensity = generatedIntensity * isActive;               // Si isActive = 0, se anula\r\n}\r\n\r\n\r\n\r\nUso en Pixel shader\r\n\r\n\r\nfloat4 PSMain(VertexInput i) : SV_Target\r\n{\r\n    float3 lightningPos;\r\n    float lightningIntensity;\r\n\r\n    // Obtener rayo actual (posición e intensidad)\r\n    GetLightning(lightningPos, lightningIntensity);\r\n\r\n    float3 smokeColor = float3(0.2, 0.2, 0.2); // Color base del humo\r\n    float3 light = 0;\r\n\r\n    // Creamos una máscara para saber si el rayo es válido (evitamos if)\r\n    float lightningActive = step(-9000.0, lightningPos.x); // 1 si activo, 0 si no\r\n\r\n    // Calcular distancia e intensidad si el rayo está activo\r\n    float dist = distance(i.worldPos.xyz, lightningPos);\r\n    float falloff = saturate(1.0 - dist * 5.0); // Luz disminuye con la distancia\r\n\r\n    // Aplicar luz solo si está activa\r\n    light += lightningActive * lightningIntensity * falloff;\r\n\r\n    // Color final del humo\r\n    float3 finalColor = smokeColor * light;\r\n    return float4(finalColor, 1.0);\r\n}\r\n",
    "type": "código"
  },
  {
    "id": "3ba6f2e5-5013-4714-b41a-72381230df45",
    "title": "Undefined1",
    "created_at": "2025-04-09T21:23:41.20958+00:00",
    "content": "// === INPUTS (por vértice o fragmento) ===\r\nfloat3 vertexPosWS;       // Posición del vértice del humo en espacio mundo\r\nfloat3 normalWS;          // Normal del plano en espacio mundo\r\nfloat3 tangentWS;         // Tangente (eje X local del plano)\r\nfloat3 bitangentWS;       // Bitangente (eje Y local del plano)\r\nfloat3 lightPosWS;        // Posición de la luz generada en espacio mundo\r\nfloat  maxLightDistance;  // Distancia máxima donde la luz puede afectar\r\nfloat3 smokeColor;        // Color base del humo (ej. gris)\r\n\r\nfloat2 uv;                // Coordenadas UV del plano\r\nTexture2D tex1RGBA;       // RGBA: left (R), right (G), top (B), bottom (A)\r\nTexture2D tex2RG;         // RG: back (R), front (G)\r\nSamplerState samplerState;\r\n\r\n// === 1. Vector desde el vértice hacia la luz ===\r\nfloat3 toLight = lightPosWS - vertexPosWS;\r\nfloat  lightDistance = length(toLight); // Distancia real\r\n\r\n// === 2. Crear máscara de activación de la luz ===\r\n// Estas máscaras reemplazan un if tradicional como:\r\n// if (lightDistance < maxLightDistance && lightPosWS.x > -9000.0)\r\nfloat distMask  = step(lightDistance, maxLightDistance);   // 1 si está dentro del rango\r\nfloat posMask   = step(-9000.0, lightPosWS.x);             // 1 si la luz está activa (no es -9999)\r\nfloat applyMask = distMask * posMask;                      // 1 si se aplica, 0 si no\r\n\r\n// === 3. Dirección de la luz en espacio tangente ===\r\n// Convierte el vector toLight a coordenadas locales del plano (tangent space)\r\nfloat3 toLightNorm = normalize(toLight + 1e-6); // evitar división por 0 con un numero muy pequeño 1e-6\r\nfloat3 lightDirTS = float3(\r\n    dot(toLightNorm, tangentWS),\r\n    dot(toLightNorm, bitangentWS),\r\n    dot(toLightNorm, normalWS)\r\n);\r\n\r\n// === 4. Samplear las texturas con los canales de iluminación ===\r\nfloat4 tex1 = tex1RGBA.Sample(samplerState, uv); // RGBA = L, R, T, B\r\nfloat2 tex2 = tex2RG.Sample(samplerState, uv);   // RG = Back, Front\r\n\r\n// === 5. Determinar eje dominante de la dirección ===\r\n// El eje con mayor componente absoluta será el que define la dirección principal\r\nfloat3 absDir = abs(lightDirTS);\r\n\r\nfloat xDominant = step(max(absDir.y, absDir.z), absDir.x); // 1 si X es el mayor\r\nfloat yDominant = step(max(absDir.x, absDir.z), absDir.y); // 1 si Y es el mayor\r\nfloat zDominant = 1.0 - xDominant - yDominant;              // lo que sobra (Z)\r\n\r\n// === 6. Determinar signo del eje dominante ===\r\n// Reemplaza ifs como: if (dir.x > 0) → derecha, else → izquierda\r\nfloat3 dir = normalize(lightDirTS + 1e-6);\r\n\r\nfloat xSign = step(0.0, dir.x); // 0 = izquierda, 1 = derecha\r\nfloat ySign = step(0.0, dir.y); // 0 = abajo,     1 = arriba\r\nfloat zSign = step(0.0, dir.z); // 0 = atrás,     1 = frente\r\n\r\n// === 7. Selección del canal de textura según la dirección ===\r\n// `lerp(a, b, s)` elige `a` si s=0 y `b` si s=1\r\nfloat leftRight   = lerp(tex1.r, tex1.g, xSign); // izquierda/derecha\r\nfloat topBottom   = lerp(tex1.a, tex1.b, ySign); // abajo/arriba\r\nfloat backFront   = lerp(tex2.r, tex2.g, zSign); // atrás/frente\r\n\r\n// === 8. Combinar solo el canal de dirección dominante ===\r\n// Esto reemplaza:\r\n// if (X domina) usar left/right\r\n// else if (Y domina) usar top/bottom\r\n// else usar back/front\r\nfloat lightingAmount = applyMask * (\r\n    xDominant * leftRight +\r\n    yDominant * topBottom +\r\n    zDominant * backFront\r\n);\r\n\r\n// === 9. Color final del humo ===\r\nfloat3 finalColor = smokeColor * lightingAmount;\r\n\r\n// === 10. Salida final ===\r\nreturn float4(finalColor, 1.0);",
    "type": "código"
  },
  {
    "id": "2547da6e-53c5-400b-a8e0-07e791dca0cf",
    "title": "Uv projection sphere",
    "created_at": "2025-04-07T14:27:59.338809+00:00",
    "content": "float3 dir = normalize(worldPosition - viewerPosition);\nfloat2 sphericalUV;\nsphericalUV.x = 0.5 + atan2(dir.z, dir.x) / (2.0 * PI);\nsphericalUV.y = 0.5 - asin(dir.y) / PI;",
    "type": "código"
  },
  {
    "id": "9bf4284f-5ee7-4bb8-938d-48b71db7b39c",
    "title": "Time waves",
    "created_at": "2025-04-03T18:47:17.691674+00:00",
    "content": "//=========================================================================\n// WAVE & FLICKER LIBRARY - HLSL VFX / TECHNICAL ARTISTS\n// Basado en variable 't' de tiempo (cíclica o continua)\n//=========================================================================\n\n#ifndef VFX_WAVES_INCLUDED\n#define VFX_WAVES_INCLUDED\n\n//-----------------------------------------------------------\n// ONDAS BÁSICAS (loop perfectos)\n//-----------------------------------------------------------\n\n// Onda seno normalizada [0,1]\nfloat Sin01(float t)\n{\n    return sin(t) * 0.5 + 0.5;\n}\n\n// Onda triangular [0,1]\nfloat TriangleWave(float t)\n{\n    return abs(frac(t + 0.5) * 2.0 - 1.0);\n}\n\n// Onda sierra ascendente (Sawtooth Up)\nfloat SawUp(float t)\n{\n    return frac(t);\n}\n\n// Onda sierra descendente (Sawtooth Down)\nfloat SawDown(float t)\n{\n    return 1.0 - frac(t);\n}\n\n// Onda cuadrada (Square wave)\nfloat SquareWave(float t, float threshold)\n{\n    return frac(t) < threshold ? 1.0 : 0.0;\n}\n\n// Onda seno cuadrada (Sine → Step)\nfloat SineSquare(float t, float threshold)\n{\n    return Sin01(t) > threshold ? 1.0 : 0.0;\n}\n\n//-----------------------------------------------------------\n// ONDAS MODIFICADAS / EXPONENCIALES\n//-----------------------------------------------------------\n\n// Onda exponencial rápida [0,1]\nfloat ExpSaw(float t, float k)\n{\n    return pow(frac(t), k);\n}\n\n// Onda con entrada lenta y salida rápida\nfloat EaseOutSaw(float t)\n{\n    float x = frac(t);\n    return 1.0 - pow(1.0 - x, 2.0);\n}\n\n// Onda blend senoidal-triangular\nfloat SineTriangleMix(float t, float blend)\n{\n    return lerp(TriangleWave(t), Sin01(t), blend);\n}\n\n// Oscilador entre dos valores\nfloat Oscillate(float minVal, float maxVal, float t)\n{\n    return lerp(minVal, maxVal, Sin01(t));\n}\n\n//-----------------------------------------------------------\n// FLICKERS Y RANDOM FX LOOPABLES\n//-----------------------------------------------------------\n\n// Hash simple loopable [0–1]\nfloat HashLoop(float t, float seed)\n{\n    float x = frac(t + seed);\n    return frac(sin(x * 42.376 + seed * 12.345) * 43758.5453);\n}\n\n// Flicker suave aleatorio (loop perfecto)\nfloat FlickerSmooth(float t, float seed)\n{\n    float a = HashLoop(floor(t), seed);\n    float b = HashLoop(floor(t) + 1.0, seed);\n    float f = frac(t);\n    return lerp(a, b, smoothstep(0.0, 1.0, f));\n}\n\n// Flicker agresivo / energía / fuego\nfloat FlickerFast(float t, float seed)\n{\n    return HashLoop(t * 20.0, seed);\n}\n\n// Sparkle \"mágico\" suave con curva\nfloat SparkleMagic(float t, float seed)\n{\n    float r = FlickerSmooth(t, seed);\n    return pow(r, 6.0); // muy oscuro con picos brillantes\n}\n\n// Flash aleatorio con on/off\nfloat RandomFlash(float t, float seed, float chance)\n{\n    return step(1.0 - chance, HashLoop(t * 10.0, seed));\n}\n\n//-----------------------------------------------------------\n// PATRONES MULTICAPA / RUIDOS DE LUZ\n//-----------------------------------------------------------\n\n// Luz pulsante tipo faro o lava\nfloat BeaconLight(float t, float base, float flicker, float speed, float seed)\n{\n    float wave = Sin01(t * speed);\n    float fx = FlickerSmooth(t * speed, seed);\n    return base + wave * 0.5 + fx * flicker;\n}\n\n// Luz fuego procedural\nfloat FireLight(float t, float base, float chaos, float seed)\n{\n    float f = FlickerFast(t, seed);\n    return base + pow(f, 3.0) * chaos;\n}\n\n// Electricidad / glitch\nfloat ElectricJitter(float t, float seed)\n{\n    return SquareWave(t * 10.0 + HashLoop(t, seed), 0.2) * HashLoop(t * 2.0, seed);\n}\n\n//-----------------------------------------------------------\n// SHAPES LOOPABLES COMO MÁSCARAS\n//-----------------------------------------------------------\n\n// Pulso loopable con rango\nfloat Pulse(float t, float width)\n{\n    return step(frac(t), width);\n}\n\n// Pulso suave loopable\nfloat PulseSmooth(float t, float width, float fade)\n{\n    float f = frac(t);\n    return smoothstep(0.0, fade, f) * (1.0 - smoothstep(width - fade, width, f));\n}\n\n#endif // VFX_WAVES_INCLUDED",
    "type": "código"
  },
  {
    "id": "14da0bf4-8597-4e75-a13e-5b077466c80c",
    "title": "Stars optimized",
    "created_at": "2025-04-03T18:35:52.437417+00:00",
    "content": "// === Optimized 3D Gradient Noise ===\nvec3 hash(vec3 p) {\n    p = fract(p * 0.3183099 + vec3(0.1, 0.2, 0.3));\n    p *= 17.0;\n    return -1.0 + 2.0 * fract(p * (p.yzx + 19.19));\n}\n\nfloat noise(vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    vec3 u = f * f * (3.0 - 2.0 * f);\n\n    vec3 g000 = hash(i + vec3(0,0,0));\n    vec3 g100 = hash(i + vec3(1,0,0));\n    vec3 g010 = hash(i + vec3(0,1,0));\n    vec3 g110 = hash(i + vec3(1,1,0));\n    vec3 g001 = hash(i + vec3(0,0,1));\n    vec3 g101 = hash(i + vec3(1,0,1));\n    vec3 g011 = hash(i + vec3(0,1,1));\n    vec3 g111 = hash(i + vec3(1,1,1));\n\n    float n000 = dot(g000, f - vec3(0,0,0));\n    float n100 = dot(g100, f - vec3(1,0,0));\n    float n010 = dot(g010, f - vec3(0,1,0));\n    float n110 = dot(g110, f - vec3(1,1,0));\n    float n001 = dot(g001, f - vec3(0,0,1));\n    float n101 = dot(g101, f - vec3(1,0,1));\n    float n011 = dot(g011, f - vec3(0,1,1));\n    float n111 = dot(g111, f - vec3(1,1,1));\n\n    float nx00 = mix(n000, n100, u.x);\n    float nx10 = mix(n010, n110, u.x);\n    float nx01 = mix(n001, n101, u.x);\n    float nx11 = mix(n011, n111, u.x);\n\n    float nxy0 = mix(nx00, nx10, u.y);\n    float nxy1 = mix(nx01, nx11, u.y);\n\n    return mix(nxy0, nxy1, u.z);\n}\n\n// === Main Shader ===\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 centeredUV = uv * 2.0 - 1.0;\n\n    // Curvatura angular (más bajo = más compresión en bordes)\n    float angularScale = 0.3;\n\n    // Zoom global del patrón\n    float zoom = 4.0;\n\n    // Dirección corregida\n    vec3 dir = normalize(vec3(centeredUV * angularScale, 1.0));\n    vec3 dir200 = dir * 200.0 * zoom;\n    vec3 dir100 = dir * 100.0 * zoom + vec3(iTime);\n\n    // Base noise\n    float baseNoise = clamp(noise(dir200), 0.0, 1.0);\n\n    // Más estrellas: usamos pow(x, 4) en lugar de pow(x, 8)\n    float n = baseNoise;\n    n *= n; // ^2\n    n *= n; // ^4\n\n    float flicker = mix(0.4, 1.4, noise(dir100));\n    float stars = n * 200.0 * flicker;\n\n    fragColor = vec4(vec3(stars), 1.0);\n}",
    "type": "código"
  },
  {
    "id": "7cc47bd6-fac6-4cde-8a82-772d4c0bf660",
    "title": "Vertex shader toolkit",
    "created_at": "2025-04-02T06:27:08.30053+00:00",
    "content": "//=========================================================================\n// VERTEX TRANSFORM UTILITY LIBRARY - VFX / TECHNICAL ARTISTS\n//=========================================================================\n\n#ifndef VFX_VERTEX_TRANSFORMS_INCLUDED\n#define VFX_VERTEX_TRANSFORMS_INCLUDED\n\n//-----------------------------------------------------------\n// ROTACIONES\n//-----------------------------------------------------------\n\n// Rotación en el eje Z\nfloat2 Rotate2D(float2 pos, float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return float2(pos.x * c - pos.y * s, pos.x * s + pos.y * c);\n}\n\n// Rotación alrededor de eje arbitrario\nfloat3 RotateAroundAxis(float3 pos, float3 axis, float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    float3x3 R =\n    {\n        c + axis.x * axis.x * (1 - c),\n        axis.x * axis.y * (1 - c) - axis.z * s,\n        axis.x * axis.z * (1 - c) + axis.y * s,\n\n        axis.y * axis.x * (1 - c) + axis.z * s,\n        c + axis.y * axis.y * (1 - c),\n        axis.y * axis.z * (1 - c) - axis.x * s,\n\n        axis.z * axis.x * (1 - c) - axis.y * s,\n        axis.z * axis.y * (1 - c) + axis.x * s,\n        c + axis.z * axis.z * (1 - c)\n    };\n    return mul(R, pos);\n}\n\n// Rotación alrededor de un pivote\nfloat3 RotateAroundPivot(float3 pos, float3 pivot, float3 axis, float angle)\n{\n    float3 local = pos - pivot;\n    float3 rotated = RotateAroundAxis(local, axis, angle);\n    return rotated + pivot;\n}\n\n//-----------------------------------------------------------\n// ESCALADO Y TRANSLACIÓN\n//-----------------------------------------------------------\n\nfloat3 ScaleAroundPivot(float3 pos, float3 pivot, float3 scale)\n{\n    return (pos - pivot) * scale + pivot;\n}\n\nfloat3 Translate(float3 pos, float3 offset)\n{\n    return pos + offset;\n}\n\n//-----------------------------------------------------------\n// DEFORMACIONES / OSCILACIONES\n//-----------------------------------------------------------\n\n// Onda senoidal en eje Y\nfloat3 SinWaveY(float3 pos, float frequency, float amplitude, float time)\n{\n    pos.y += sin(pos.x * frequency + time) * amplitude;\n    return pos;\n}\n\n// Wobble XYZ (3D sin wave)\nfloat3 Wobble(float3 pos, float3 freq, float3 amp, float time)\n{\n    pos += sin(pos * freq + time) * amp;\n    return pos;\n}\n\n// Morph entre dos posiciones\nfloat3 MorphPosition(float3 posA, float3 posB, float factor)\n{\n    return lerp(posA, posB, factor);\n}\n\n// Stretch hacia arriba con falloff (útil para FX tipo \"grow\")\nfloat3 VerticalStretch(float3 pos, float heightLimit, float intensity)\n{\n    float t = saturate(pos.y / heightLimit);\n    pos.y += t * intensity;\n    return pos;\n}\n\n//-----------------------------------------------------------\n// NOISE VERTEX OFFSET\n//-----------------------------------------------------------\n\n// Hash rápido\nfloat Hash21(float2 p)\n{\n    p = frac(p * float2(123.34, 456.21));\n    p += dot(p, p + 45.32);\n    return frac(p.x * p.y);\n}\n\n// Simple noise offset en Y\nfloat3 VertexNoiseOffset(float3 pos, float scale, float strength)\n{\n    float2 p = pos.xz * scale;\n    float noise = Hash21(p);\n    pos.y += (noise - 0.5) * strength;\n    return pos;\n}\n\n// Noise animado (ideal para fuego, lava, etc.)\nfloat3 VertexNoiseAnim(float3 pos, float scale, float strength, float time)\n{\n    float2 p = pos.xz * scale + time * 0.5;\n    float noise = Hash21(p);\n    pos.y += (noise - 0.5) * strength;\n    return pos;\n}\n\n//-----------------------------------------------------------\n// TAPER Y SHEAR\n//-----------------------------------------------------------\n\n// Taper: estrecha o ensancha según altura\nfloat3 TaperY(float3 pos, float height, float factor)\n{\n    float t = saturate(pos.y / height);\n    pos.xz *= lerp(1.0, factor, t);\n    return pos;\n}\n\n// Shear XZ basado en altura Y\nfloat3 ShearXZ(float3 pos, float height, float shearAmount)\n{\n    float t = saturate(pos.y / height);\n    pos.x += t * shearAmount;\n    pos.z += t * shearAmount;\n    return pos;\n}\n\n#endif // VFX_VERTEX_TRANSFORMS_INCLUDED",
    "type": "código"
  },
  {
    "id": "245ebab7-793f-4bda-b6c8-05ac1fcec3e7",
    "title": "Postprocess",
    "created_at": "2025-04-02T06:24:00.383718+00:00",
    "content": "//=========================================================================\n// VFX/TECH ARTISTS - HLSL LIBRARY 2 + 5 + 6 + 9\n// Shapes Procedurales + TBN/Parallax + Material FX + Post FX\n//=========================================================================\n\n#ifndef VFX_MATERIAL_UTILS_INCLUDED\n#define VFX_MATERIAL_UTILS_INCLUDED\n\n//=========================================================================\n// 2. SHAPES PROCEDURALES (sin texturas)\n//=========================================================================\n\n// Círculo centrado en UV\nfloat Circle(float2 uv, float2 center, float radius)\n{\n    float d = distance(uv, center);\n    return step(d, radius);\n}\n\n// Círculo suave\nfloat SoftCircle(float2 uv, float2 center, float radius, float softness)\n{\n    float d = distance(uv, center);\n    return smoothstep(radius, radius - softness, d);\n}\n\n// Estrella de 5 puntas\nfloat Star5(float2 uv, float2 center, float size, float sharpness)\n{\n    float2 p = uv - center;\n    float a = atan2(p.y, p.x);\n    float r = length(p);\n    float star = cos(5.0 * a) * sharpness + 0.5;\n    return smoothstep(star * size, star * size - 0.01, r);\n}\n\n// Polígono",
    "type": "código"
  },
  {
    "id": "dd29ea9a-dd13-4574-8106-6089b3a8d59e",
    "title": "Distortion and geo",
    "created_at": "2025-04-02T06:22:24.051298+00:00",
    "content": "//=========================================================================\n// VFX/TECH ARTISTS - MEGA HLSL LIBRARY\n// Distorsión UV + Geometría de Pantalla + Fresnel + Luz + Glitch FX\n//=========================================================================\n\n#ifndef VFX_MEGA_LIB_INCLUDED\n#define VFX_MEGA_LIB_INCLUDED\n\n//=========================================================================\n// 1. DISTORSIÓN UV / PROCEDURAL WARP\n//=========================================================================\n\n// Scroll UV básico\nfloat2 ScrollUV(float2 uv, float2 direction, float speed, float time)\n{\n    return uv + direction * speed * time;\n}\n\n// Onda senoidal\nfloat2 SinWaveDistort(float2 uv, float frequency, float amplitude, float time)\n{\n    uv.y += sin(uv.x * frequency + time) * amplitude;\n    return uv;\n}\n\n// Onda radial (turbulencia circular)\nfloat2 RadialWaveDistort(float2 uv, float2 center, float freq, float amp, float time)\n{\n    float2 offset = uv - center;\n    float r = length(offset);\n    float angle = atan2(offset.y, offset.x);\n    r += sin(angle * freq + time) * amp;\n    return center + float2(cos(angle), sin(angle)) * r;\n}\n\n// Distorsión con ruido simple\nfloat Hash21(float2 p)\n{\n    p = frac(p * float2(123.34, 456.21));\n    p += dot(p, p + 45.32);\n    return frac(p.x * p.y);\n}\n\nfloat ValueNoise(float2 uv)\n{\n    float2 i = floor(uv);\n    float2 f = frac(uv);\n    float a = Hash21(i);\n    float b = Hash21(i + float2(1, 0));\n    float c = Hash21(i + float2(0, 1));\n    float d = Hash21(i + float2(1, 1));\n    float2 u = f * f * (3.0 - 2.0 * f);\n    return lerp(lerp(a, b, u.x), lerp(c, d, u.x), u.y);\n}\n\nfloat2 NoiseWarpUV(float2 uv, float scale, float strength, float time)\n{\n    float2 n = float2(\n        ValueNoise(uv * scale + float2(0, time)),\n        ValueNoise(uv * scale + float2(5.2, time + 1.0))\n    );\n    return uv + (n - 0.5) * strength;\n}\n\n//=========================================================================\n// 3. GEOMETRÍA DE PANTALLA / UV TOOLS\n//=========================================================================\n\n// Coordenadas centradas (-1 a 1)\nfloat2 CenteredUV(float2 uv)\n{\n    return uv * 2.0 - 1.0;\n}\n\n// Distancia al centro\nfloat DistanceToCenter(float2 uv)\n{\n    return length(CenteredUV(uv));\n}\n\n// Máscara de borde (falloff hacia los lados)\nfloat EdgeMask(float2 uv, float thickness)\n{\n    float2 edge = min(uv, 1.0 - uv);\n    return smoothstep(thickness, 0.0, min(edge.x, edge.y));\n}\n\n// Coordenadas NDC (si se requiere)\nfloat2 NDCFromUV(float2 uv)\n{\n    return uv * 2.0 - 1.0;\n}\n\n// Mapa de dirección hacia el centro (vector unitario)\nfloat2 DirectionToCenter(float2 uv)\n{\n    return normalize(0.5 - uv);\n}\n\n//=========================================================================\n// 4. FRESNEL / CURVATURA\n//=========================================================================\n\n// Fresnel básico\nfloat FresnelBasic(float3 normal, float3 viewDir)\n{\n    return 1.0 - saturate(dot(normalize(normal), normalize(viewDir)));\n}\n\n// Fresnel con power y bias\nfloat FresnelAdvanced(float3 normal, float3 viewDir, float power, float bias)\n{\n    float f = 1.0 - saturate(dot(normalize(normal), normalize(viewDir)));\n    return pow(f, power) + bias;\n}\n\n// Curvatura simple usando diferencia entre normal y view\nfloat NormalCurvatureMask(float3 normal, float3 refNormal)\n{\n    return saturate(1.0 - dot(normalize(normal), normalize(refNormal)));\n}\n\n// Edge highlight por curvatura\nfloat EdgeHighlight(float3 normal, float3 viewDir, float power)\n{\n    float f = 1.0 - dot(normalize(normal), normalize(viewDir));\n    return pow(f, power);\n}\n\n//=========================================================================\n// 7. LUZ PROCEDURAL / SHADING CUSTOM\n//=========================================================================\n\n// Luz direccional simulada\nfloat SimulatedDirectionalLight(float3 normal, float3 lightDir)\n{\n    return saturate(dot(normalize(normal), normalize(lightDir)));\n}\n\n// Luz puntual simulada (basada en distancia)\nfloat SimulatedPointLight(float3 worldPos, float3 lightPos, float3 normal)\n{\n    float3 toLight = lightPos - worldPos;\n    float d = length(toLight);\n    float3 L = normalize(toLight);\n    float NdotL = saturate(dot(normal, L));\n    return NdotL / (d * d); // iluminación realista con caída\n}\n\n// Luz esférica suave (ideal para UI o FX en pantalla)\nfloat SphereLight(float2 uv, float2 center, float radius)\n{\n    float dist = distance(uv, center);\n    return smoothstep(radius, 0.0, dist);\n}\n\n// Sombra UV simulada\nfloat UVShadow(float2 uv, float2 lightDir, float softness)\n{\n    float n = dot(normalize(uv - 0.5), normalize(lightDir));\n    return smoothstep(0.0, softness, n);\n}\n\n//=========================================================================\n// 8. GLITCH FX / ERRORES VISUALES\n//=========================================================================\n\n// Separación de canales RGB (glitch tipo VHS)\nfloat2 RGBOffset(float2 uv, float time, float intensity, float channelOffset)\n{\n    float offset = sin(time * 20.0 + uv.y * 100.0) * intensity;\n    return uv + float2(channelOffset * offset, 0.0);\n}\n\n// Salto UV (tipo flicker o salto de línea)\nfloat2 UVJump(float2 uv, float time, float intensity)\n{\n    float glitch = step(0.95, frac(sin(dot(uv, float2(12.989, 78.233)) + time) * 43758.5453));\n    return uv + float2(0.0, glitch * intensity);\n}\n\n// Scanlines animadas\nfloat Scanlines(float2 uv, float time, float frequency, float thickness)\n{\n    float line = sin(uv.y * frequency + time * 20.0);\n    return smoothstep(thickness, 0.0, abs(line));\n}\n\n// Glitch temporal (fade in/out tipo error)\nfloat TemporalGlitch(float time, float speed, float duration)\n{\n    float t = frac(time * speed);\n    return step(t, duration);\n}\n\n#endif // VFX_MEGA_LIB_INCLUDED",
    "type": "código"
  },
  {
    "id": "5d95dfe9-d816-4ee5-8391-05d69f915e50",
    "title": "Time library",
    "created_at": "2025-04-02T06:12:08.567279+00:00",
    "content": "//===========================================================\n// TIME UTILITY LIBRARY - VFX / TECHNICAL ARTISTS\n// Usando i.fTime como base de tiempo\n//===========================================================\n\n#ifndef TIME_UTILS_INCLUDED\n#define TIME_UTILS_INCLUDED\n\n//-----------------------------------------------------------\n// Tiempo normalizado cíclico [0 → 1]\n// Ideal para loops de animación\n//-----------------------------------------------------------\nfloat Time01(float time, float speed)\n{\n    return frac(time * speed);\n}\n\n//-----------------------------------------------------------\n// Tiempo senoidal suave entre 0 y 1\n// Oscila suavemente - ideal para efectos respirantes o pulsantes\n//-----------------------------------------------------------\nfloat SineTime01(float time, float speed)\n{\n    return sin(time * speed) * 0.5 + 0.5;\n}\n\n//-----------------------------------------------------------\n// PingPong (triángulo) entre 0 y 1\n// Útil para efectos que deben ir y volver\n//-----------------------------------------------------------\nfloat PingPong(float time, float speed)\n{\n    return abs(frac(time * speed) * 2.0 - 1.0);\n}\n\n//-----------------------------------------------------------\n// Onda triangular suavizada (para parpadeos, loops simétricos)\n//-----------------------------------------------------------\nfloat TriangleWave(float time, float speed)\n{\n    return abs(frac(time * speed + 0.5) * 2.0 - 1.0);\n}\n\n//-----------------------------------------------------------\n// Pulso repetitivo (ideal para flashes, glitches...)\n// Devuelve 1 solo durante un tramo del ciclo\n//-----------------------------------------------------------\nfloat PulseLoop(float time, float speed, float width)\n{\n    float t = frac(time * speed);\n    return step(t, width); // Ejemplo: width = 0.1 → pulso breve\n}\n\n//-----------------------------------------------------------\n// Oscilador entre dos valores\n//-----------------------------------------------------------\nfloat Oscillate(float minVal, float maxVal, float time, float speed)\n{\n    float t = SineTime01(time, speed);\n    return lerp(minVal, maxVal, t);\n}\n\n//-----------------------------------------------------------\n// Ramp-Up Loop: sube de 0 a 1, luego se queda en 1 por un tiempo\n//-----------------------------------------------------------\nfloat RampHoldLoop(float time, float speed, float holdRatio)\n{\n    float t = frac(time * speed);\n    float rise = 1.0 - holdRatio;\n    return t < rise ? t / rise : 1.0;\n}\n\n//-----------------------------------------------------------\n// Delay temporal por fragmento (útil para efectos secuenciales)\n//-----------------------------------------------------------\nfloat TimeWithDelay(float time, float delay)\n{\n    return max(0.0, time - delay);\n}\n\n//-----------------------------------------------------------\n// Fase desincronizada por UV o World Position\n// Perfecto para que cada píxel haga el efecto en distinto momento\n//-----------------------------------------------------------\nfloat DesyncByCoord(float2 uv, float time, float speed, float spread)\n{\n    float offset = frac(dot(uv, float2(12.9898, 78.233))) * spread;\n    return frac((time + offset) * speed);\n}\n\n#endif // TIME_UTILS_INCLUDED",
    "type": "código"
  },
  {
    "id": "57b07ed6-96c1-41c8-8ee8-16b52c5ab250",
    "title": "Masks library",
    "created_at": "2025-04-01T21:59:41.320255+00:00",
    "content": "//===========================================================\n// HLSL MASK LIBRARY - EXTENDED\n//===========================================================\n\n#ifndef VFX_MASKS_INCLUDED\n#define VFX_MASKS_INCLUDED\n\n//-----------------------------------------------------------\n// UTILIDADES BÁSICAS\n//-----------------------------------------------------------\n\n// Clamp suave entre 0–1\nfloat Saturate(float x) {\n    return clamp(x, 0.0, 1.0);\n}\n\n// Interpolación suave Hermite (usado en soft masks)\nfloat SmoothStep(float edge0, float edge1, float x) {\n    float t = saturate((x - edge0) / (edge1 - edge0));\n    return t * t * (3.0 - 2.0 * t);\n}\n\n// Pulse entre dos rangos\nfloat Pulse(float edge0, float edge1, float x) {\n    return step(edge0, x) - step(edge1, x);\n}\n\n// Distancia UV al centro\nfloat DistToCenter(float2 uv, float2 center) {\n    return distance(uv, center);\n}\n\nfloat DistToEdge(float2 uv) {\n    float2 d = min(uv, 1.0 - uv);\n    return min(d.x, d.y);\n}\n\n//-----------------------------------------------------------\n// FORMAS BÁSICAS\n//-----------------------------------------------------------\n\n// Máscara circular\nfloat CircleMask(float2 uv, float2 center, float radius) {\n    float d = distance(uv, center);\n    return step(d, radius);\n}\n\n// Círculo suave (falloff)\nfloat SoftCircleMask(float2 uv, float2 center, float radius, float softness) {\n    float d = distance(uv, center);\n    return smoothstep(radius, radius - softness, d);\n}\n\n// Rectángulo centrado (sin rotación)\nfloat BoxMask(float2 uv, float2 center, float2 size) {\n    float2 diff = abs(uv - center);\n    float2 halfSize = size * 0.5;\n    return step(diff.x, halfSize.x) * step(diff.y, halfSize.y);\n}\n\n// Rectángulo con bordes suaves\nfloat SoftBoxMask(float2 uv, float2 center, float2 size, float softness) {\n    float2 diff = abs(uv - center);\n    float2 halfSize = size * 0.5;\n    float2 edge = smoothstep(halfSize, halfSize - softness, diff);\n    return edge.x * edge.y;\n}\n\n// Línea horizontal con grosor\nfloat LineMask(float2 uv, float y, float thickness) {\n    return step(abs(uv.y - y), thickness * 0.5);\n}\n\n// Línea suave\nfloat SoftLineMask(float2 uv, float y, float thickness, float softness) {\n    float d = abs(uv.y - y);\n    return smoothstep(thickness * 0.5 + softness, thickness * 0.5, d);\n}\n\n//-----------------------------------------------------------\n// FORMAS AVANZADAS\n//-----------------------------------------------------------\n\n// Anillo\nfloat RingMask(float2 uv, float2 center, float radius, float thickness) {\n    float d = distance(uv, center);\n    return step(abs(d - radius), thickness * 0.5);\n}\n\n// Anillo suave\nfloat SoftRingMask(float2 uv, float2 center, float radius, float thickness, float softness) {\n    float d = distance(uv, center);\n    float outer = smoothstep(radius + thickness * 0.5, radius + thickness * 0.5 - softness, d);\n    float inner = smoothstep(radius - thickness * 0.5, radius - thickness * 0.5 + softness, d);\n    return outer * inner;\n}\n\n// Máscara radial (de centro a borde)\nfloat RadialGradient(float2 uv, float2 center) {\n    return saturate(distance(uv, center));\n}\n\n// Máscara radial invertida\nfloat InvertedRadial(float2 uv, float2 center) {\n    return 1.0 - RadialGradient(uv, center);\n}\n\n// Máscara tipo borde\nfloat EdgeMask(float2 uv, float thickness) {\n    float edge = min(min(uv.x, 1.0 - uv.x), min(uv.y, 1.0 - uv.y));\n    return step(thickness, edge);\n}\n\n//-----------------------------------------------------------\n// MÁSCARAS ANIMADAS\n//-----------------------------------------------------------\n\n// Wipe horizontal\nfloat HorizontalWipe(float2 uv, float progress) {\n    return step(uv.x, progress);\n}\n\n// Wipe radial (reloj)\nfloat RadialWipe(float2 uv, float2 center, float progress) {\n    float2 dir = normalize(uv - center);\n    float angle = atan2(dir.y, dir.x) / (2.0 * 3.14159) + 0.5;\n    return step(angle, progress);\n}\n\n// Máscara con ruido\nfloat NoisyMask(float2 uv, float noiseValue, float threshold, float softness) {\n    return smoothstep(threshold, threshold - softness, noiseValue);\n}\n\n//-----------------------------------------------------------\n// MÁSCARAS EN ESPACIO WORLD / PERSONALIZADO\n//-----------------------------------------------------------\n\n// Máscara basada en altura (eje Y)\nfloat HeightMask(float3 worldPos, float height, float falloff) {\n    return smoothstep(height, height - falloff, worldPos.y);\n}\n\n// Máscara por proyección planar Y\nfloat PlanarYMask(float3 worldPos, float centerY, float range, float falloff) {\n    float d = abs(worldPos.y - centerY);\n    return smoothstep(range, range - falloff, d);\n}\n\n// Máscara por distancia a un punto en mundo\nfloat WorldDistanceMask(float3 worldPos, float3 worldCenter, float radius, float softness) {\n    float d = distance(worldPos, worldCenter);\n    return smoothstep(radius, radius - softness, d);\n}\n\n//-----------------------------------------------------------\n// MÁSCARA MODULADA / COMBINADA\n//-----------------------------------------------------------\n\n// Combine (AND lógico)\nfloat CombineAND(float a, float b) {\n    return a * b;\n}\n\n// Combine (OR lógico)\nfloat CombineOR(float a, float b) {\n    return saturate(a + b);\n}\n\n// Combine (XOR lógico visual)\nfloat CombineXOR(float a, float b) {\n    return abs(a - b);\n}\n\n// Interpolación entre dos máscaras\nfloat BlendMasks(float a, float b, float blend) {\n    return lerp(a, b, blend);\n}\n\n#endif // VFX_MASKS_INCLUDED",
    "type": "código"
  },
  {
    "id": "e0315988-7742-41bd-9e26-24a8ab9cb5b1",
    "title": "Utility Library",
    "created_at": "2025-04-01T21:56:28.250214+00:00",
    "content": "//====================================================================\n// HLSL UTILITY LIBRARY - TECHNICAL & VFX ARTISTS v2\n//====================================================================\n\n#ifndef VFX_UTILS_INCLUDED\n#define VFX_UTILS_INCLUDED\n\n//--------------------------------------------------\n// REMAP / INTERPOLACIONES\n//--------------------------------------------------\n\nfloat Remap(float v, float inMin, float inMax, float outMin, float outMax) {\n    return outMin + (v - inMin) * (outMax - outMin) / (inMax - inMin);\n}\n\nfloat RemapClamped(float v, float inMin, float inMax, float outMin, float outMax) {\n    float t = saturate((v - inMin) / (inMax - inMin));\n    return lerp(outMin, outMax, t);\n}\n\nfloat InverseLerp(float a, float b, float v) {\n    return saturate((v - a) / (b - a));\n}\n\nfloat EaseIn(float t)    { return t * t; }\nfloat EaseOut(float t)   { return 1.0 - pow(1.0 - t, 2.0); }\nfloat EaseInOut(float t) { return lerp(t*t, 1.0 - pow(1.0 - t, 2.0), step(0.5, t)); }\n\nfloat SmoothLerp(float a, float b, float t) {\n    t = t * t * (3.0 - 2.0 * t); // Hermite\n    return lerp(a, b, t);\n}\n\n//--------------------------------------------------\n// PROYECCIONES UV\n//--------------------------------------------------\n\n// Planar Projection\nfloat2 ProjectPlanar(float3 pos, float3 axisU, float3 axisV) {\n    return float2(dot(pos, axisU), dot(pos, axisV));\n}\n\n// Triplanar Projection (sin blending)\nfloat2 TriplanarUV(float3 pos, float3 normal, out float3 weights) {\n    float3 absN = abs(normal);\n    weights = absN / (absN.x + absN.y + absN.z);\n    return pos.yz; // ejemplo para eje Y, ajusta según blend deseado\n}\n\n// Cylindrical Projection\nfloat2 ProjectCylindrical(float3 pos) {\n    float angle = atan2(pos.z, pos.x);\n    float u = (angle + 3.14159) / (2.0 * 3.14159);\n    float v = pos.y;\n    return float2(u, v);\n}\n\n// Spherical Projection\nfloat2 ProjectSpherical(float3 pos) {\n    float3 n = normalize(pos);\n    float u = 0.5 + atan2(n.z, n.x) / (2.0 * 3.14159);\n    float v = 0.5 - asin(n.y) / 3.14159;\n    return float2(u, v);\n}\n\n//--------------------------------------------------\n// RUIDOS - ORDENADOS DE MÁS BARATO A MÁS CARO\n//--------------------------------------------------\n\n//--- 1. Hash noise (barato, sin continuidad) ---\nfloat Hash21(float2 p) {\n    p = frac(p * float2(123.34, 456.21));\n    p += dot(p, p + 45.32);\n    return frac(p.x * p.y);\n}\n\n//--- 2. Value Noise 2D (barato, interpolado) ---\nfloat ValueNoise(float2 uv) {\n    float2 i = floor(uv);\n    float2 f = frac(uv);\n    float a = Hash21(i);\n    float b = Hash21(i + float2(1, 0));\n    float c = Hash21(i + float2(0, 1));\n    float d = Hash21(i + float2(1, 1));\n    float2 u = f * f * (3.0 - 2.0 * f);\n    return lerp(lerp(a, b, u.x), lerp(c, d, u.x), u.y);\n}\n\n//--- 3. Perlin Noise 2D (más costoso, continuo) ---\nfloat2 Fade(float2 t) {\n    return t * t * (3.0 - 2.0 * t);\n}\n\nfloat Grad2(float2 p, float2 ip) {\n    float2 gradient = normalize(frac(sin(dot(ip, float2(127.1, 311.7))) * 43758.5453) * 2.0 - 1.0);\n    return dot(p, gradient);\n}\n\nfloat PerlinNoise(float2 uv) {\n    float2 i = floor(uv);\n    float2 f = frac(uv);\n\n    float a = Grad2(f, i);\n    float b = Grad2(f - float2(1, 0), i + float2(1, 0));\n    float c = Grad2(f - float2(0, 1), i + float2(0, 1));\n    float d = Grad2(f - float2(1, 1), i + float2(1, 1));\n\n    float2 u = Fade(f);\n    return lerp(lerp(a, b, u.x), lerp(c, d, u.x), u.y);\n}\n\n//--- 4. Gaussian Noise (para desenfoques o distorsión sutil) ---\nfloat Gaussian(float2 uv, float2 center, float sigma) {\n    float2 diff = uv - center;\n    float r2 = dot(diff, diff);\n    return exp(-r2 / (2.0 * sigma * sigma));\n}\n\n//--------------------------------------------------\n// MÁSCARAS / FORMAS\n//--------------------------------------------------\n\nfloat CircleMask(float2 uv, float2 center, float radius, float softness) {\n    float d = distance(uv, center);\n    return smoothstep(radius, radius - softness, d);\n}\n\nfloat RingMask(float2 uv, float2 center, float radius, float thickness, float softness) {\n    float d = distance(uv, center);\n    float outer = smoothstep(radius, radius - softness, d);\n    float inner = smoothstep(radius - thickness, radius - thickness - softness, d);\n    return outer * (1.0 - inner);\n}\n\nfloat SoftMask(float mask, float threshold, float softness) {\n    return smoothstep(threshold, threshold - softness, mask);\n}\n\n//--------------------------------------------------\n// ANIMACIONES / EFECTOS TIEMPO\n//--------------------------------------------------\n\nfloat Oscillate(float minVal, float maxVal, float time, float speed) {\n    float t = sin(time * speed) * 0.5 + 0.5;\n    return lerp(minVal, maxVal, t);\n}\n\nfloat TriangleWave(float t) {\n    return abs(frac(t + 0.5) * 2.0 - 1.0);\n}\n\nfloat Pulse(float edge0, float edge1, float x) {\n    return step(edge0, x) - step(edge1, x);\n}\n\n//--------------------------------------------------\n// COLOR\n//--------------------------------------------------\n\nfloat3 HSVtoRGB(float3 hsv) {\n    float3 K = float3(1.0, 2.0 / 3.0, 1.0 / 3.0);\n    float3 P = abs(frac(hsv.xxx + K.xyz) * 6.0 - 3.0);\n    return hsv.z * lerp(K.xxx, saturate(P - K.xxx), hsv.y);\n}\n\nfloat3 RGBtoHSV(float3 c) {\n    float4 K = float4(0., -1./3., 2./3., -1.);\n    float4 p = (c.g < c.b) ? float4(c.bg, K.wz) : float4(c.gb, K.xy);\n    float4 q = (c.r < p.x) ? float4(p.xyw, c.r) : float4(c.r, p.yzx);\n    float d = q.x - min(q.w, q.y);\n    float e = 1e-10;\n    return float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n#endif // VFX_UTILS_INCLUDED",
    "type": "código"
  },
  {
    "id": "193a1eff-8d79-4708-a78e-ca1e2e5894c2",
    "title": "Funciones hlsl mas usadas",
    "created_at": "2025-04-01T21:48:57.925052+00:00",
    "content": "//==============================\n// FUNCIONES HLSL MÁS USADAS\n//==============================\n\n//----- MATH BÁSICA -----\nfloat a = abs(-2.5);             // valor absoluto\nfloat b = ceil(1.3);             // redondea hacia arriba\nfloat c = floor(1.9);            // redondea hacia abajo\nfloat d = frac(3.75);            // parte decimal (0.75)\nfloat e = fmod(5.2, 2.0);        // módulo decimal (1.2)\nfloat f = clamp(1.5, 0.0, 1.0);  // limita entre 0 y 1\nfloat g = lerp(0.0, 1.0, 0.5);   // interpolación lineal (0.5)\nfloat h = min(2.0, 3.0);         // 2.0\nfloat i = max(5.0, 4.0);         // 5.0\nfloat j = saturate(x);           // clamp entre 0 y 1\n\n//----- RAMPAS / CONTROL -----\nfloat s1 = step(0.5, 0.3);                 // 0.0 (x < edge)\nfloat s2 = smoothstep(0.2, 0.8, 0.5);      // rampa suave\nfloat s3 = sign(-5.0);                     // -1\nfloat s4 = isnan(value);                  // 1 si es NaN\n\n//----- TRIGONOMETRÍA -----\nfloat t1 = sin(3.14);\nfloat t2 = cos(0.0);\nfloat t3 = tan(1.0);\nfloat t4 = asin(1.0);\nfloat t5 = acos(0.0);\nfloat t6 = atan2(y, x); // ángulo entre (x, y)\n\n//----- POTENCIAS Y LOGARITMOS -----\nfloat p1 = pow(2.0, 3.0);  // 8\nfloat p2 = sqrt(25.0);     // 5\nfloat p3 = rsqrt(25.0);    // 1 / sqrt(25) = 0.2\nfloat p4 = exp(1.0);       // e^1\nfloat p5 = log(2.71828);   // loge\n\n//----- VECTORES -----\nfloat len = length(float3(1, 2, 2));           // magnitud\nfloat dist = distance(a, b);                   // distancia\nfloat3 norm = normalize(float3(1, 2, 3));      // vector normalizado\nfloat dp = dot(a, b);                          // producto punto\nfloat3 cr = cross(float3(1,0,0), float3(0,1,0));// producto cruzado\nfloat3 ref = reflect(-viewDir, normal);        // reflexión\nfloat3 refr = refract(viewDir, normal, 1.0);   // refracción\nfloat3 face = faceforward(n, i, ng);           // orienta una normal hacia la cámara\n\n//----- TEXTURAS -----\nTexture2D tex : register(t0);\nSamplerState samp : register(s0);\nfloat4 col = tex.Sample(samp, uv);                 // sampleo normal\nfloat4 colBias = tex.SampleBias(samp, uv, -1.0);   // con bias\nfloat4 colGrad = tex.SampleGrad(samp, uv, dx, dy); // con gradiente manual\nfloat4 colLOD = tex.SampleLevel(samp, uv, 2.0);     // sample mip específico\nfloat2 texSize; tex.GetDimensions(texSize.x, texSize.y);\n\n//----- COLORES -----\nfloat3 hsv = float3(0.6, 1.0, 1.0); // ejemplo color HSV\nfloat3 rgb = hsv2rgb(hsv);          // si defines tú mismo esta función\nfloat3 gray = float3(0.5.xxx);      // gris neutro\n\n//----- UV / ANIMACIÓN -----\nfloat wave = sin(uv.x * 10.0 + time * 5.0);    // animación senoidal\nfloat2 scrollUV = uv + time * 0.1;            // scrolling\nfloat2 polar = float2(cos(a), sin(a));        // dirección circular\nfloat ripple = sin(distance(uv, center) * 20.0 - time * 5.0); // onda radial\n\n//----- RUIDO BÁSICO -----\nfloat hash(float2 p)\n{\n    return frac(sin(dot(p, float2(127.1, 311.7))) * 43758.5453);\n}\n\nfloat noise(float2 uv)\n{\n    float2 i = floor(uv);\n    float2 f = frac(uv);\n\n    float a = hash(i);\n    float b = hash(i + float2(1, 0));\n    float c = hash(i + float2(0, 1));\n    float d = hash(i + float2(1, 1));\n\n    float2 u = f * f * (3.0 - 2.0 * f); // fade\n\n    return lerp(lerp(a, b, u.x), lerp(c, d, u.x), u.y);\n}\n\n//----- PARALLAX OFFSET (básico) -----\nfloat height = heightMap.Sample(samp, uv).r;\nfloat2 parallaxOffset = viewDirTS.xy * height * intensity;\nfloat2 uvOffset = uv + parallaxOffset;",
    "type": "código"
  },
  {
    "id": "b8e04b67-f75f-4f2b-8f7d-f0d42cb325b3",
    "title": "Parallax mapping basico",
    "created_at": "2025-04-01T21:43:35.177911+00:00",
    "content": "float height = heightTex.Sample(sampler, uv).r;\nfloat2 offset = viewDirTS.xy * height * intensity;\nfloat2 newUV = uv + offset;",
    "type": "código"
  },
  {
    "id": "d24e3da0-cf5e-4046-9c6c-ff17dd3e7102",
    "title": "Treshold",
    "created_at": "2025-04-01T21:42:33.145036+00:00",
    "content": "Texture2D maskTex : register(t0);\nSamplerState maskSampler : register(s0);\n\nfloat threshold = 0.5;\n\nfloat4 PS_Main(float4 pos : SV_POSITION, float2 uv : TEXCOORD0) : SV_TARGET\n{\n    float mask = maskTex.Sample(maskSampler, uv).r;\n    float masked = step(threshold, mask);\n    return float4(masked.xxx, 1.0); // Blanco si mayor a threshold\n}",
    "type": "código"
  },
  {
    "id": "cd9d1012-6400-4faa-bc38-f565bec1c5e1",
    "title": "Solid Color",
    "created_at": "2025-04-01T21:41:35.893949+00:00",
    "content": "float4 PS_Main(float4 pos : SV_POSITION) : SV_TARGET\n{\n    return float4(1.0, 0.0, 0.0, 1.0); // Color rojo\n}",
    "type": "código"
  },
  {
    "id": "66607c43-d45b-4b71-9131-5fd1578fbbe3",
    "title": "Code Test",
    "created_at": "2025-04-01T20:34:40.582093+00:00",
    "content": "// Transformamos la dirección del visor de world space a tangent space\nfloat3 viewDirTS = mul(TBN, viewDirWS);\n\n// Calculamos un factor de escala basado en cuán inclinado es el ángulo de visión\n// viewDirTS.z es cuánto \"miramos de frente\"; si es bajo, estamos mirando en ángulo\n// En lugar de dividir por z, usamos (1 - z) como multiplicador para simular ese efecto\nfloat scale = saturate(1.0 - viewDirTS.z); // saturate asegura que el valor esté entre 0 y 1\n\n// Calculamos el desplazamiento de parallax multiplicando por ese factor\nfloat2 parallaxOffset = viewDirTS.xy * height * height_intensity * scale;\n\n// Sumamos el desplazamiento a las UV originales\nreturn uv + parallaxOffset;",
    "type": "código"
  }
]
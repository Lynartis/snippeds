[
  {
    "id": "c7c8bbf7-afa6-4a4c-80e7-2d0150b9458f",
    "title": "Layers",
    "created_at": "2025-04-21T11:48:45.234254+00:00",
    "content": "float hash(float3 p) {\n    p = frac(p * 0.3183099 + 0.1);\n    p *= 17.0;\n    return frac(p.x * p.y * p.z * (p.x + p.y + p.z));\n}\n\nfloat noise3D(float3 p) {\n    float3 i = floor(p);\n    float3 f = frac(p);\n    f = f * f * (3.0 - 2.0 * f); // smoothstep\n\n    float n000 = hash(i + float3(0,0,0));\n    float n100 = hash(i + float3(1,0,0));\n    float n010 = hash(i + float3(0,1,0));\n    float n110 = hash(i + float3(1,1,0));\n    float n001 = hash(i + float3(0,0,1));\n    float n101 = hash(i + float3(1,0,1));\n    float n011 = hash(i + float3(0,1,1));\n    float n111 = hash(i + float3(1,1,1));\n\n    float n00 = lerp(n000, n100, f.x);\n    float n10 = lerp(n010, n110, f.x);\n    float n01 = lerp(n001, n101, f.x);\n    float n11 = lerp(n011, n111, f.x);\n\n    float n0 = lerp(n00, n10, f.y);\n    float n1 = lerp(n01, n11, f.y);\n\n    return lerp(n0, n1, f.z);\n}\n\nfloat fbm(float3 p) {\n    float v = 0.0;\n    float a = 0.5;\n    for (int i = 0; i < 4; ++i) {\n        v += a * noise3D(p);\n        p *= 2.0;\n        a *= 0.5;\n    }\n    return v;\n}\n\nfloat4 PS_CloudParallax(V2F i) : SV_Target {\n    float3 worldPos = i.vWorld.xyz;\n    float3 basePos = worldPos * 0.05; // escala general\n\n    float parallaxIntensity = 0.3;\n    int layers = 5;\n    float layerDepth = 1.0;\n\n    float finalClouds = 0.0;\n\n    for (int l = 0; l < layers; ++l) {\n        float depth = l * layerDepth;\n        float3 offset = float3(0, 0, -depth * parallaxIntensity); // hacia delante en tu sistema\n        float3 p = basePos + offset;\n\n        float d = fbm(p);\n        float cloudLayer = smoothstep(0.45, 0.6, d);\n        float fade = 1.0 - (float)l / (float)(layers); // más lejano = más suave\n        finalClouds += cloudLayer * fade;\n    }\n\n    finalClouds = saturate(finalClouds);\n\n    float3 col = lerp(float3(0.6, 0.7, 1.0), float3(1.0, 1.0, 1.0), finalClouds);\n    return float4(col, 1.0);\n}",
    "type": "código"
  },
  {
    "id": "797327a4-deeb-43b2-861a-f03f8ade643d",
    "title": "Clouds2",
    "created_at": "2025-04-21T08:34:33.140994+00:00",
    "content": "float hash(float3 p) {\n    p = frac(p * 0.3183099 + 0.1);\n    p *= 17.0;\n    return frac(p.x * p.y * p.z * (p.x + p.y + p.z));\n}\n\nfloat noise3D(float3 p) {\n    float3 i = floor(p);\n    float3 f = frac(p);\n    f = f * f * (3.0 - 2.0 * f); // smoothstep\n\n    float n000 = hash(i + float3(0,0,0));\n    float n100 = hash(i + float3(1,0,0));\n    float n010 = hash(i + float3(0,1,0));\n    float n110 = hash(i + float3(1,1,0));\n    float n001 = hash(i + float3(0,0,1));\n    float n101 = hash(i + float3(1,0,1));\n    float n011 = hash(i + float3(0,1,1));\n    float n111 = hash(i + float3(1,1,1));\n\n    float n00 = lerp(n000, n100, f.x);\n    float n10 = lerp(n010, n110, f.x);\n    float n01 = lerp(n001, n101, f.x);\n    float n11 = lerp(n011, n111, f.x);\n\n    float n0 = lerp(n00, n10, f.y);\n    float n1 = lerp(n01, n11, f.y);\n\n    return lerp(n0, n1, f.z);\n}\n\nfloat fbm(float3 p) {\n    float v = 0.0;\n    float a = 0.5;\n    for (int i = 0; i < 5; ++i) {\n        v += a * noise3D(p);\n        p *= 2.0;\n        a *= 0.5;\n    }\n    return v;\n}\n\nfloat4 PS_Clouds(V2F i) : SV_Target {\n    float3 worldPos = i.vWorld.xyz;\n    float3 p = worldPos * 0.1; // escala del ruido\n\n    float density = fbm(p + float3(0, 0, _Time.y * 0.1)); // animación en Z\n    float clouds = smoothstep(0.4, 0.6, density); // umbral de nubes\n\n    float3 cloudColor = lerp(float3(0.7, 0.8, 1.0), float3(1.0, 1.0, 1.0), clouds);\n    return float4(cloudColor, 1.0);\n}",
    "type": "código"
  },
  {
    "id": "7e9769a1-36f6-4e53-ab1c-f30ebb0a793a",
    "title": "Noise",
    "created_at": "2025-04-21T08:33:59.53177+00:00",
    "content": "float noise3(float3 p) {\n    float3 i = floor(p);\n    float3 f = frac(p);\n    f = f * f * (3.0 - 2.0 * f);\n\n    float n = dot(i, float3(1.0, 57.0, 113.0));\n    float res = lerp(\n        lerp(\n            lerp(frac(sin(n + 0.0) * 43758.5453), frac(sin(n + 1.0) * 43758.5453), f.x),\n            lerp(frac(sin(n + 57.0) * 43758.5453), frac(sin(n + 58.0) * 43758.5453), f.x),\n            f.y),\n        lerp(\n            lerp(frac(sin(n + 113.0) * 43758.5453), frac(sin(n + 114.0) * 43758.5453), f.x),\n            lerp(frac(sin(n + 170.0) * 43758.5453), frac(sin(n + 171.0) * 43758.5453), f.x),\n            f.y),\n        f.z\n    );\n    return res;\n}\n\nfloat cloudNoise3D(float3 p) {\n    float d = 0;\n    float amp = 0.5;\n    float freq = 1.0;\n    for (int i = 0; i < 4; i++) {\n        d += amp * noise3(p * freq);\n        freq *= 2.0;\n        amp *= 0.5;\n    }\n    return smoothstep(0.4, 0.6, d);\n}\n\nfloat4 PS_CloudsCheap(V2F i) : SV_Target {\n    float3 p = i.vWorld.xyz * 0.05;\n    float n = cloudNoise3D(p + float3(0, 0, _Time.y * 0.05));\n    return float4(lerp(float3(0.7, 0.8, 1.0), float3(1.0, 1.0, 1.0), n), 1.0);\n}",
    "type": "código"
  },
  {
    "id": "aaa9e953-3e3b-4eb8-9273-57c0aacd3435",
    "title": "Mask",
    "created_at": "2025-04-11T08:45:03.074477+00:00",
    "content": "float mask = ...;         // 1 at center, 0 at border\nfloat noise = ...;        // sampled noise in [0,1]\nfloat threshold = 0.5;    // where noise starts to apply\nfloat invThreshold = 1.0 / threshold; // precomputed on CPU or outside shader\nfloat noiseStrength = 1.0; // full noise\n\n// Compute blend factor with multiplication only\nfloat t = saturate((1.0 - mask) * invThreshold); // t = 0 when mask=1, t=1 when mask=0\n\n// Blend noise in\nfloat noisyMask = lerp(mask, mask * noise, t * noiseStrength);",
    "type": "código"
  },
  {
    "id": "f52549fd-30a6-4a4f-b677-6a917ba40c3b",
    "title": "Paintdevert",
    "created_at": "2025-04-10T20:50:00.489176+00:00",
    "content": "-- Utility functions\r\nfn pointMin a b = [amin a.x b.x, amin a.y b.y, amin a.z b.z]\r\nfn pointMax a b = [amax a.x b.x, amax a.y b.y, amax a.z b.z]\r\n\r\n-- Function 1: Bake Element Centers into Vertex Color\r\nfn bakeElementCenters obj =\r\n(\r\n    if isKindOf obj Editable_Poly or classof obj == Editable_Mesh do\r\n    (\r\n        local theMesh = snapshotAsMesh obj\r\n\r\n        local bboxMin = [1e9,1e9,1e9]\r\n        local bboxMax = [-1e9,-1e9,-1e9]\r\n        for v = 1 to theMesh.numverts do\r\n        (\r\n            local pos = getVert theMesh v\r\n            bboxMin = pointMin bboxMin pos\r\n            bboxMax = pointMax bboxMax pos\r\n        )\r\n        local bboxSize = bboxMax - bboxMin\r\n        if bboxSize.x == 0 then bboxSize.x = 0.001\r\n        if bboxSize.y == 0 then bboxSize.y = 0.001\r\n        if bboxSize.z == 0 then bboxSize.z = 0.001\r\n\r\n        local numFaces = theMesh.numfaces\r\n        local faceProcessed = #{}\r\n        local faceElemMap = #()\r\n        local elemID = 0\r\n\r\n        while faceProcessed.numberSet < numFaces do\r\n        (\r\n            local startFace = (for i = 1 to numFaces where not faceProcessed[i] collect i)[1]\r\n            local connected = meshop.getElementsUsingFace theMesh #{startFace}\r\n            elemID += 1\r\n            for f in connected do faceElemMap[f] = elemID\r\n            faceProcessed += connected\r\n        )\r\n\r\n        local elemVerts = for i = 1 to elemID collect #{}\r\n        for f = 1 to numFaces do\r\n        (\r\n            local verts = getFace theMesh f\r\n            local id = faceElemMap[f]\r\n            elemVerts[id][verts.x] = true\r\n            elemVerts[id][verts.y] = true\r\n            elemVerts[id][verts.z] = true\r\n        )\r\n\r\n        meshop.setMapSupport theMesh 0 true\r\n        meshop.setNumMapVerts theMesh 0 theMesh.numverts\r\n\r\n        for i = 1 to elemID do\r\n        (\r\n            local verts = elemVerts[i]\r\n            local center = [0,0,0]\r\n            for v in verts do center += getVert theMesh v\r\n            center /= verts.numberSet\r\n\r\n            local localColor = (center - bboxMin) / bboxSize\r\n            local convertedColor = [localColor.x, localColor.z, 1.0 - localColor.y]\r\n\r\n            format \"Element % â Center: % | Normalized Color (Engine): %\\n\" i center convertedColor\r\n\r\n            for v in verts do\r\n                meshop.setMapVert theMesh 0 v convertedColor\r\n        )\r\n\r\n        for f = 1 to numFaces do\r\n            meshop.setMapFace theMesh 0 f (getFace theMesh f)\r\n\r\n        convertToMesh obj\r\n        obj.mesh = theMesh\r\n        convertToPoly obj\r\n        update obj\r\n    )\r\n)\r\n\r\n-- Function 2: Print real position from selected vertex\r\nfn printSelectedVertexColorPosition obj =\r\n(\r\n    if isKindOf obj Editable_Poly then\r\n    (\r\n        local selVerts = polyOp.getVertSelection obj\r\n        if selVerts.numberSet == 0 then\r\n        (\r\n            messageBox \"No vertex selected!\" title:\"Info\"\r\n        )\r\n        else\r\n        (\r\n            local vertIndex = (selVerts as array)[1]\r\n            local mesh = snapshotAsMesh obj\r\n            local color = meshop.getMapVert mesh 0 vertIndex\r\n\r\n            local bboxMin = [1e9,1e9,1e9]\r\n            local bboxMax = [-1e9,-1e9,-1e9]\r\n            for v = 1 to mesh.numverts do\r\n            (\r\n                local pos = getVert mesh v\r\n                bboxMin = pointMin bboxMin pos\r\n                bboxMax = pointMax bboxMax pos\r\n            )\r\n\r\n            local bboxSize = bboxMax - bboxMin\r\n            if bboxSize.x == 0 then bboxSize.x = 0.001\r\n            if bboxSize.y == 0 then bboxSize.y = 0.001\r\n            if bboxSize.z == 0 then bboxSize.z = 0.001\r\n\r\n            -- Convert color to position using engine axis\r\n            local engineColor = [color.x, color.y, color.z]\r\n            local position = [engineColor.x * bboxSize.x,\r\n                              engineColor.y * bboxSize.y,\r\n                              (1.0 - engineColor.z) * bboxSize.z] + bboxMin\r\n\r\n            format \"Vertex % â Color: % â Reconstructed Position: %\\n\" vertIndex color position\r\n        )\r\n    )\r\n    else\r\n    (\r\n        messageBox \"Select only one Editable Poly Vertex.\" title:\"Error\"\r\n    )\r\n)\r\n\r\n-- UI Tool\r\nrollout ElementCenterPainter \"Element Center Tool\" width:240\r\n(\r\n    button btnBake \"ð¦ Bake Element Centers to Vertex Color\" width:220 height:40\r\n    button btnPrint \"ð¨ Print Selected Vertex Position\" width:220 height:40\r\n\r\n    on btnBake pressed do\r\n    (\r\n        if selection.count > 0 then\r\n        (\r\n            for obj in selection do bakeElementCenters obj\r\n        )\r\n        else\r\n        (\r\n            messageBox \"Please select at least one object.\" title:\"No Selection\"\r\n        )\r\n    )\r\n\r\n    on btnPrint pressed do\r\n    (\r\n        if selection.count == 1 then\r\n        (\r\n            printSelectedVertexColorPosition selection[1]\r\n        )\r\n        else\r\n        (\r\n            messageBox \"Only one editable Poly Object.\" title:\"Error\"\r\n        )\r\n    )\r\n)\r\n\r\ncreateDialog ElementCenterPainter style:#(#style_titlebar, #style_sysmenu, #style_toolwindow)\r\n",
    "type": "código"
  },
  {
    "id": "01df1d56-e986-4ec8-830d-cdee81290c85",
    "title": "Uv lib",
    "created_at": "2025-04-09T21:43:54.866467+00:00",
    "content": "// ==============================\n// UV TRANSFORMATION & FX LIBRARY (HLSL)\n// Librería para manipular coordenadas UV en shaders\n// ==============================\n\n#ifndef UV_TRANSFORM_LIB\n#define UV_TRANSFORM_LIB\n\n//-------------------------------------\n// TRANSFORMACIONES BÁSICAS\n//-------------------------------------\n\n// Escala UV desde su centro\nfloat2 ScaleUV(float2 uv, float2 scale) {\n    return (uv - 0.5) * scale + 0.5;\n}\n\n// Rota las UV alrededor del centro (ángulo en radianes)\nfloat2 RotateUV(float2 uv, float angle) {\n    float2 centered = uv - 0.5;\n    float cosA = cos(angle);\n    float sinA = sin(angle);\n    float2 rotated = float2(\n        centered.x * cosA - centered.y * sinA,\n        centered.x * sinA + centered.y * cosA\n    );\n    return rotated + 0.5;\n}\n\n// Desplaza UV (scroll horizontal y vertical)\nfloat2 ScrollUV(float2 uv, float2 speed, float time) {\n    return uv + speed * time;\n}\n\n// Centro custom para transformar UVs\nfloat2 TransformUV(float2 uv, float2 pivot, float2 scale, float angle, float2 offset) {\n    uv -= pivot;\n    float cosA = cos(angle);\n    float sinA = sin(angle);\n    uv = float2(uv.x * cosA - uv.y * sinA, uv.x * sinA + uv.y * cosA);\n    uv *= scale;\n    uv += pivot + offset;\n    return uv;\n}\n\n//-------------------------------------\n// REPETICIÓN Y TILEADO\n//-------------------------------------\n\n// Tiling clásico\nfloat2 TileUV(float2 uv, float2 tiles) {\n    return frac(uv * tiles);\n}\n\n// Tiling con offset aleatorio por tile\nfloat2 RandomTileUV(float2 uv, float2 tiles, out float2 tileID) {\n    float2 uvTiled = uv * tiles;\n    tileID = floor(uvTiled);\n    return frac(uvTiled);\n}\n\n// Flip aleatorio por tile\nfloat2 RandomFlipTile(float2 uv, float2 tileID) {\n    float hash = frac(sin(dot(tileID, float2(12.9898, 78.233))) * 43758.5453);\n    if (hash < 0.5) uv.x = 1.0 - uv.x;\n    return uv;\n}\n\n//-------------------------------------\n// EFECTOS DE MOVIMIENTO\n//-------------------------------------\n\n// Desplazamiento sinusoidal horizontal/vertical\nfloat2 SinWaveUV(float2 uv, float frequency, float amplitude, float time, bool horizontal) {\n    if (horizontal) {\n        uv.x += sin(uv.y * frequency + time) * amplitude;\n    } else {\n        uv.y += sin(uv.x * frequency + time) * amplitude;\n    }\n    return uv;\n}\n\n// Ondas multidireccionales\nfloat2 MultiWaveUV(float2 uv, float time, float2 freq, float2 amp) {\n    uv.x += sin(uv.y * freq.x + time) * amp.x;\n    uv.y += cos(uv.x * freq.y + time) * amp.y;\n    return uv;\n}\n\n// Scroll en espiral\nfloat2 SpiralScrollUV(float2 uv, float speed, float time) {\n    float2 centered = uv - 0.5;\n    float angle = atan2(centered.y, centered.x) + time * speed;\n    float radius = length(centered);\n    return float2(cos(angle), sin(angle)) * radius + 0.5;\n}\n\n//-------------------------------------\n// DISTORSIONES Y WARPING\n//-------------------------------------\n\n// Warping radial\nfloat2 RadialWarpUV(float2 uv, float intensity) {\n    float2 centered = uv - 0.5;\n    float r = length(centered);\n    float angle = atan2(centered.y, centered.x);\n    r = pow(r, intensity);\n    return float2(cos(angle), sin(angle)) * r + 0.5;\n}\n\n// Warping tipo \"fisheye\"\nfloat2 FisheyeUV(float2 uv, float strength) {\n    float2 centered = uv * 2.0 - 1.0;\n    float r = dot(centered, centered);\n    float2 distorted = centered * (1.0 + strength * r);\n    return (distorted * 0.5 + 0.5);\n}\n\n// Distorsión polar\nfloat2 PolarDistortUV(float2 uv, float time, float strength) {\n    float2 centered = uv - 0.5;\n    float angle = atan2(centered.y, centered.x);\n    float radius = length(centered);\n    angle += sin(time + radius * 10.0) * strength;\n    return float2(cos(angle), sin(angle)) * radius + 0.5;\n}\n\n//-------------------------------------\n// EFECTOS AVANZADOS\n//-------------------------------------\n\n// Kaleidoscopio UV (reflejo en segmentos angulares)\nfloat2 KaleidoscopeUV(float2 uv, float segments) {\n    float2 centered = uv - 0.5;\n    float angle = atan2(centered.y, centered.x);\n    float radius = length(centered);\n    float mirrored = fmod(abs(angle), 2.0 * 3.14159 / segments);\n    angle = mirrored;\n    return float2(cos(angle), sin(angle)) * radius + 0.5;\n}\n\n// Flip UV por eje X o Y\nfloat2 FlipUV(float2 uv, bool flipX, bool flipY) {\n    return float2(flipX ? 1.0 - uv.x : uv.x, flipY ? 1.0 - uv.y : uv.y);\n}\n\n// Desplazamiento por ruido (requiere textura de ruido o función externa)\nfloat2 NoiseDistortUV(float2 uv, sampler2D noiseTex, float2 noiseScale, float2 strength, float time) {\n    float2 noiseUV = uv * noiseScale + time;\n    float2 n = tex2D(noiseTex, noiseUV).rg * 2.0 - 1.0;\n    return uv + n * strength;\n}\n\n//-------------------------------------\n// DEBUG / UTILIDADES VISUALES\n//-------------------------------------\n\n// Visualiza el checkerboard en UV space\nfloat CheckerUV(float2 uv, float2 scale) {\n    float2 check = floor(uv * scale);\n    return fmod(check.x + check.y, 2.0);\n}\n\n// Visualiza borde de UV (útil para detectar errores de distorsión)\nfloat BorderUV(float2 uv, float thickness) {\n    float border = step(uv.x, thickness) + step(uv.y, thickness) +\n                   step(1.0 - uv.x, thickness) + step(1.0 - uv.y, thickness);\n    return clamp(border, 0.0, 1.0);\n}\n\n#endif",
    "type": "código"
  },
  {
    "id": "0ffef3b9-a29f-4af5-a982-501f767fe5da",
    "title": "Movimiento",
    "created_at": "2025-04-09T21:31:46.675225+00:00",
    "content": "// ==============================\n// TRANSFORM & VFX UTILITY LIBRARY (HLSL)\n// Funciones útiles para distancias, rotaciones, órbitas, desplazamientos y efectos visuales\n// Para uso técnico y artístico\n// ==============================\n\n#ifndef TRANSFORM_VFX_LIB\n#define TRANSFORM_VFX_LIB\n\n// -------------------------------\n// BÁSICOS DE TRANSFORMACIÓN\n// -------------------------------\n\n// Distancia entre dos puntos 3D\nfloat Distance3D(float3 a, float3 b) {\n    return length(b - a);\n}\n\n// Distancia en plano XZ (2D)\nfloat Distance2D(float3 a, float3 b) {\n    return length(a.xz - b.xz);\n}\n\n// Dirección normalizada entre dos puntos\nfloat3 DirectionTo(float3 from, float3 to) {\n    return normalize(to - from);\n}\n\n// Mueve un punto en una dirección dada, con velocidad y tiempo\nfloat3 MovePoint(float3 pos, float3 dir, float speed, float time) {\n    return pos + normalize(dir) * speed * time;\n}\n\n// Interpolación suave entre dos puntos\nfloat3 SmoothMove(float3 a, float3 b, float t) {\n    return lerp(a, b, smoothstep(0.0, 1.0, t));\n}\n\n// Proyección de un punto sobre un plano definido por un punto y normal\nfloat3 ProjectOnPlane(float3 point, float3 planePoint, float3 planeNormal) {\n    float3 toPoint = point - planePoint;\n    return point - dot(toPoint, planeNormal) * planeNormal;\n}\n\n// Refleja un punto respecto a una normal\nfloat3 ReflectOverPlane(float3 point, float3 normal) {\n    return point - 2 * dot(point, normal) * normal;\n}\n\n// -------------------------------\n// ROTACIONES Y EJES\n// -------------------------------\n\n// Rota un punto alrededor del eje Y\nfloat3 RotateAroundY(float3 pos, float angleRadians) {\n    float cosA = cos(angleRadians);\n    float sinA = sin(angleRadians);\n    float3 result = pos;\n    result.x = pos.x * cosA - pos.z * sinA;\n    result.z = pos.x * sinA + pos.z * cosA;\n    return result;\n}\n\n// Rota un punto alrededor de un pivote en eje Y\nfloat3 RotateAroundPivotY(float3 pos, float3 pivot, float angleRadians) {\n    float3 local = pos - pivot;\n    local = RotateAroundY(local, angleRadians);\n    return pivot + local;\n}\n\n// Devuelve ejes ortogonales a partir de un vector \"forward\"\nvoid GetOrthogonalAxes(float3 forward, out float3 right, out float3 up) {\n    forward = normalize(forward);\n    float3 worldUp = float3(0, 1, 0);\n    right = normalize(cross(worldUp, forward));\n    up = normalize(cross(forward, right));\n}\n\n// -------------------------------\n// EFECTOS DE ÓRBITA Y MOVIMIENTO CIRCULAR\n// -------------------------------\n\n// Movimiento circular en el plano XZ\nfloat3 CircularOrbitXZ(float3 center, float radius, float angleRadians) {\n    float x = center.x + cos(angleRadians) * radius;\n    float z = center.z + sin(angleRadians) * radius;\n    return float3(x, center.y, z);\n}\n\n// Órbita elíptica con control de escala en X y Z\nfloat3 EllipticalOrbitXZ(float3 center, float2 radii, float angleRadians) {\n    float x = center.x + cos(angleRadians) * radii.x;\n    float z = center.z + sin(angleRadians) * radii.y;\n    return float3(x, center.y, z);\n}\n\n// Movimiento en espiral creciente\nfloat3 SpiralMotion(float3 center, float angleRadians, float radiusGrowth, float heightGrowth) {\n    float radius = angleRadians * radiusGrowth;\n    float height = angleRadians * heightGrowth;\n    return float3(\n        center.x + cos(angleRadians) * radius,\n        center.y + height,\n        center.z + sin(angleRadians) * radius\n    );\n}\n\n// Movimiento circular horizontal (XY)\nfloat2 CircularMotion2D(float2 center, float radius, float angleRadians) {\n    return center + float2(cos(angleRadians), sin(angleRadians)) * radius;\n}\n\n// -------------------------------\n// VFX OFFSET - RUIDO Y ONDAS\n// -------------------------------\n\n// Offset vertical con onda senoidal\nfloat3 SinWaveOffsetY(float3 pos, float frequency, float amplitude, float time) {\n    pos.y += sin(time * frequency + pos.x * 0.5) * amplitude;\n    return pos;\n}\n\n// Offset direccional con ondas en 3D\nfloat3 SineWaveDeform(float3 pos, float frequency, float amplitude, float time) {\n    pos.x += sin(pos.y * frequency + time) * amplitude;\n    pos.z += cos(pos.y * frequency + time) * amplitude;\n    return pos;\n}\n\n// Desplazamiento simple por ruido Perlin (requiere función noise)\nfloat3 NoiseOffset(float3 pos, float scale, float amplitude, float time) {\n    float n = noise(pos * scale + time);\n    return pos + n * amplitude;\n}\n\n// -------------------------------\n// TRANSFORMACIONES PERSONALIZADAS\n// -------------------------------\n\n// Mover un punto a lo largo de un eje local\nfloat3 MoveAlongAxis(float3 pos, float3 origin, float3 axisDir, float amount) {\n    return pos + normalize(axisDir) * amount;\n}\n\n// Aplica \"look-at\" rotación (devuelve matriz básica orientada)\nfloat3x3 LookAtMatrix(float3 from, float3 to, float3 upDir) {\n    float3 forward = normalize(to - from);\n    float3 right = normalize(cross(upDir, forward));\n    float3 up = cross(forward, right);\n    return float3x3(right, up, forward);\n}\n\n// -------------------------------\n// USO DE EJEMPLO (EN SHADER O FUNCIÓN)\n// -------------------------------\n/*\n\nfloat3 pos = float3(0, 0, 0);\nfloat time = _Time.y;\n\n// Movimiento en círculo\nfloat3 orbitPos = CircularOrbitXZ(float3(0, 0, 0), 2.0, time);\n\n// Onda vertical\nfloat3 wave = SinWaveOffsetY(pos, 3.0, 0.5, time);\n\n// Espiral ascendente\nfloat3 spiral = SpiralMotion(float3(0, 0, 0), time, 0.2, 0.1);\n\n// Rotación sobre eje\nfloat3 rotated = RotateAroundY(pos, time);\n\n// Offset de ruido (requiere función de ruido o textura)\nfloat3 noisy = NoiseOffset(pos, 1.0, 0.2, time);\n\n*/\n\n#endif",
    "type": "código"
  },
  {
    "id": "9dda9f77-957a-4285-950e-ea0a5c92eef9",
    "title": "Undefined 2",
    "created_at": "2025-04-09T21:25:19.776691+00:00",
    "content": "=== Parámetros globales configurables desde CPU ===\r\ncbuffer BoundingBoxData : register(b0)\r\n{\r\n    float3 boxMin;     // Esquina mínima del bounding box donde puede aparecer el rayo\r\n    float3 boxMax;     // Esquina máxima del bounding box\r\n    float g_fTime;     // Tiempo global en segundos, usado para animar los rayos\r\n}\r\n\r\n// === Funciones auxiliares ===\r\n\r\n// Hash simple: valor pseudoaleatorio en [0, 1) a partir de un número\r\nfloat hash(float n) \r\n{\r\n    return frac(sin(n) * 43758.5453);\r\n}\r\n\r\n// Genera un vector 3D pseudoaleatorio usando una semilla\r\nfloat3 rand3(float seed)\r\n{\r\n    return float3(\r\n        hash(seed),             // X\r\n        hash(seed + 19.1),      // Y\r\n        hash(seed + 73.7)       // Z\r\n    );\r\n}\r\n\r\n// Remapea linealmente t de un rango a otro: [inMin, inMax] → [outMin, outMax]\r\nfloat linearMap(float t, float inMin, float inMax, float outMin, float outMax)\r\n{\r\n    float f = saturate((t - inMin) / (inMax - inMin));\r\n    return lerp(outMin, outMax, f);\r\n}\r\n\r\n// === Genera un único punto de rayo y su intensidad actual (si está activo) ===\r\nvoid GetLightning(out float3 position, out float intensity)\r\n{\r\n    // Valores por defecto: rayo inactivo\r\n    position = float3(-9999.0, -9999.0, -9999.0); // Sentinel para rayo no activo\r\n    intensity = 0.0;\r\n\r\n    // Cada ~10 segundos se genera un nuevo ciclo de rayo\r\n    float cycleSeed = floor(g_fTime / 10.0);\r\n\r\n    // Intervalo aleatorio entre rayos (2.5 a 5.5 segundos)\r\n    float interval = 2.5 + hash(cycleSeed + 1.0) * 3.0;\r\n\r\n    // Duración del flash (0.15 a 0.4 segundos)\r\n    float lifeTime = 0.15 + hash(cycleSeed + 2.0) * 0.25;\r\n\r\n    // Offset aleatorio dentro del intervalo (evita sincronización)\r\n    float offset = hash(cycleSeed + 3.0) * interval;\r\n\r\n    // Tiempo normalizado dentro del intervalo actual (va de 0 a 1)\r\n    float localTime = frac((g_fTime + offset) / interval);\r\n\r\n    // Máscara para activar el rayo solo si está dentro de su vida útil\r\n    float isActive = step(localTime, lifeTime / interval); // 1 si activo, 0 si no\r\n\r\n    // Calculamos los valores solo si está activo (sin if real)\r\n    float t = localTime * (interval / lifeTime); // Normalizado 0–1 durante el flash\r\n    float fade = saturate(1.0 - abs(t * 2.0 - 1.0)); // Fade in/out en forma de triángulo\r\n\r\n    float3 randPos = rand3(cycleSeed);\r\n    float3 boxSize = boxMax - boxMin;\r\n    float3 generatedPos = boxMin + randPos * boxSize;\r\n\r\n    float minIntensity = 0.4;\r\n    float maxIntensity = 1.5;\r\n    float generatedIntensity = linearMap(fade, 0.0, 1.0, minIntensity, maxIntensity);\r\n\r\n    // Multiplicamos por la máscara en lugar de usar if\r\n    position = lerp(position, generatedPos, isActive);       // Si isActive = 1, usamos la posición generada\r\n    intensity = generatedIntensity * isActive;               // Si isActive = 0, se anula\r\n}\r\n\r\n\r\n\r\nUso en Pixel shader\r\n\r\n\r\nfloat4 PSMain(VertexInput i) : SV_Target\r\n{\r\n    float3 lightningPos;\r\n    float lightningIntensity;\r\n\r\n    // Obtener rayo actual (posición e intensidad)\r\n    GetLightning(lightningPos, lightningIntensity);\r\n\r\n    float3 smokeColor = float3(0.2, 0.2, 0.2); // Color base del humo\r\n    float3 light = 0;\r\n\r\n    // Creamos una máscara para saber si el rayo es válido (evitamos if)\r\n    float lightningActive = step(-9000.0, lightningPos.x); // 1 si activo, 0 si no\r\n\r\n    // Calcular distancia e intensidad si el rayo está activo\r\n    float dist = distance(i.worldPos.xyz, lightningPos);\r\n    float falloff = saturate(1.0 - dist * 5.0); // Luz disminuye con la distancia\r\n\r\n    // Aplicar luz solo si está activa\r\n    light += lightningActive * lightningIntensity * falloff;\r\n\r\n    // Color final del humo\r\n    float3 finalColor = smokeColor * light;\r\n    return float4(finalColor, 1.0);\r\n}\r\n",
    "type": "código"
  },
  {
    "id": "3ba6f2e5-5013-4714-b41a-72381230df45",
    "title": "Undefined1",
    "created_at": "2025-04-09T21:23:41.20958+00:00",
    "content": "// === INPUTS (por vértice o fragmento) ===\r\nfloat3 vertexPosWS;       // Posición del vértice del humo en espacio mundo\r\nfloat3 normalWS;          // Normal del plano en espacio mundo\r\nfloat3 tangentWS;         // Tangente (eje X local del plano)\r\nfloat3 bitangentWS;       // Bitangente (eje Y local del plano)\r\nfloat3 lightPosWS;        // Posición de la luz generada en espacio mundo\r\nfloat  maxLightDistance;  // Distancia máxima donde la luz puede afectar\r\nfloat3 smokeColor;        // Color base del humo (ej. gris)\r\n\r\nfloat2 uv;                // Coordenadas UV del plano\r\nTexture2D tex1RGBA;       // RGBA: left (R), right (G), top (B), bottom (A)\r\nTexture2D tex2RG;         // RG: back (R), front (G)\r\nSamplerState samplerState;\r\n\r\n// === 1. Vector desde el vértice hacia la luz ===\r\nfloat3 toLight = lightPosWS - vertexPosWS;\r\nfloat  lightDistance = length(toLight); // Distancia real\r\n\r\n// === 2. Crear máscara de activación de la luz ===\r\n// Estas máscaras reemplazan un if tradicional como:\r\n// if (lightDistance < maxLightDistance && lightPosWS.x > -9000.0)\r\nfloat distMask  = step(lightDistance, maxLightDistance);   // 1 si está dentro del rango\r\nfloat posMask   = step(-9000.0, lightPosWS.x);             // 1 si la luz está activa (no es -9999)\r\nfloat applyMask = distMask * posMask;                      // 1 si se aplica, 0 si no\r\n\r\n// === 3. Dirección de la luz en espacio tangente ===\r\n// Convierte el vector toLight a coordenadas locales del plano (tangent space)\r\nfloat3 toLightNorm = normalize(toLight + 1e-6); // evitar división por 0 con un numero muy pequeño 1e-6\r\nfloat3 lightDirTS = float3(\r\n    dot(toLightNorm, tangentWS),\r\n    dot(toLightNorm, bitangentWS),\r\n    dot(toLightNorm, normalWS)\r\n);\r\n\r\n// === 4. Samplear las texturas con los canales de iluminación ===\r\nfloat4 tex1 = tex1RGBA.Sample(samplerState, uv); // RGBA = L, R, T, B\r\nfloat2 tex2 = tex2RG.Sample(samplerState, uv);   // RG = Back, Front\r\n\r\n// === 5. Determinar eje dominante de la dirección ===\r\n// El eje con mayor componente absoluta será el que define la dirección principal\r\nfloat3 absDir = abs(lightDirTS);\r\n\r\nfloat xDominant = step(max(absDir.y, absDir.z), absDir.x); // 1 si X es el mayor\r\nfloat yDominant = step(max(absDir.x, absDir.z), absDir.y); // 1 si Y es el mayor\r\nfloat zDominant = 1.0 - xDominant - yDominant;              // lo que sobra (Z)\r\n\r\n// === 6. Determinar signo del eje dominante ===\r\n// Reemplaza ifs como: if (dir.x > 0) → derecha, else → izquierda\r\nfloat3 dir = normalize(lightDirTS + 1e-6);\r\n\r\nfloat xSign = step(0.0, dir.x); // 0 = izquierda, 1 = derecha\r\nfloat ySign = step(0.0, dir.y); // 0 = abajo,     1 = arriba\r\nfloat zSign = step(0.0, dir.z); // 0 = atrás,     1 = frente\r\n\r\n// === 7. Selección del canal de textura según la dirección ===\r\n// `lerp(a, b, s)` elige `a` si s=0 y `b` si s=1\r\nfloat leftRight   = lerp(tex1.r, tex1.g, xSign); // izquierda/derecha\r\nfloat topBottom   = lerp(tex1.a, tex1.b, ySign); // abajo/arriba\r\nfloat backFront   = lerp(tex2.r, tex2.g, zSign); // atrás/frente\r\n\r\n// === 8. Combinar solo el canal de dirección dominante ===\r\n// Esto reemplaza:\r\n// if (X domina) usar left/right\r\n// else if (Y domina) usar top/bottom\r\n// else usar back/front\r\nfloat lightingAmount = applyMask * (\r\n    xDominant * leftRight +\r\n    yDominant * topBottom +\r\n    zDominant * backFront\r\n);\r\n\r\n// === 9. Color final del humo ===\r\nfloat3 finalColor = smokeColor * lightingAmount;\r\n\r\n// === 10. Salida final ===\r\nreturn float4(finalColor, 1.0);",
    "type": "código"
  },
  {
    "id": "2547da6e-53c5-400b-a8e0-07e791dca0cf",
    "title": "Uv projection sphere",
    "created_at": "2025-04-07T14:27:59.338809+00:00",
    "content": "float3 dir = normalize(worldPosition - viewerPosition);\nfloat2 sphericalUV;\nsphericalUV.x = 0.5 + atan2(dir.z, dir.x) / (2.0 * PI);\nsphericalUV.y = 0.5 - asin(dir.y) / PI;",
    "type": "código"
  },
  {
    "id": "9bf4284f-5ee7-4bb8-938d-48b71db7b39c",
    "title": "Time waves",
    "created_at": "2025-04-03T18:47:17.691674+00:00",
    "content": "//=========================================================================\n// WAVE & FLICKER LIBRARY - HLSL VFX / TECHNICAL ARTISTS\n// Basado en variable 't' de tiempo (cíclica o continua)\n//=========================================================================\n\n#ifndef VFX_WAVES_INCLUDED\n#define VFX_WAVES_INCLUDED\n\n//-----------------------------------------------------------\n// ONDAS BÁSICAS (loop perfectos)\n//-----------------------------------------------------------\n\n// Onda seno normalizada [0,1]\nfloat Sin01(float t)\n{\n    return sin(t) * 0.5 + 0.5;\n}\n\n// Onda triangular [0,1]\nfloat TriangleWave(float t)\n{\n    return abs(frac(t + 0.5) * 2.0 - 1.0);\n}\n\n// Onda sierra ascendente (Sawtooth Up)\nfloat SawUp(float t)\n{\n    return frac(t);\n}\n\n// Onda sierra descendente (Sawtooth Down)\nfloat SawDown(float t)\n{\n    return 1.0 - frac(t);\n}\n\n// Onda cuadrada (Square wave)\nfloat SquareWave(float t, float threshold)\n{\n    return frac(t) < threshold ? 1.0 : 0.0;\n}\n\n// Onda seno cuadrada (Sine → Step)\nfloat SineSquare(float t, float threshold)\n{\n    return Sin01(t) > threshold ? 1.0 : 0.0;\n}\n\n//-----------------------------------------------------------\n// ONDAS MODIFICADAS / EXPONENCIALES\n//-----------------------------------------------------------\n\n// Onda exponencial rápida [0,1]\nfloat ExpSaw(float t, float k)\n{\n    return pow(frac(t), k);\n}\n\n// Onda con entrada lenta y salida rápida\nfloat EaseOutSaw(float t)\n{\n    float x = frac(t);\n    return 1.0 - pow(1.0 - x, 2.0);\n}\n\n// Onda blend senoidal-triangular\nfloat SineTriangleMix(float t, float blend)\n{\n    return lerp(TriangleWave(t), Sin01(t), blend);\n}\n\n// Oscilador entre dos valores\nfloat Oscillate(float minVal, float maxVal, float t)\n{\n    return lerp(minVal, maxVal, Sin01(t));\n}\n\n//-----------------------------------------------------------\n// FLICKERS Y RANDOM FX LOOPABLES\n//-----------------------------------------------------------\n\n// Hash simple loopable [0–1]\nfloat HashLoop(float t, float seed)\n{\n    float x = frac(t + seed);\n    return frac(sin(x * 42.376 + seed * 12.345) * 43758.5453);\n}\n\n// Flicker suave aleatorio (loop perfecto)\nfloat FlickerSmooth(float t, float seed)\n{\n    float a = HashLoop(floor(t), seed);\n    float b = HashLoop(floor(t) + 1.0, seed);\n    float f = frac(t);\n    return lerp(a, b, smoothstep(0.0, 1.0, f));\n}\n\n// Flicker agresivo / energía / fuego\nfloat FlickerFast(float t, float seed)\n{\n    return HashLoop(t * 20.0, seed);\n}\n\n// Sparkle \"mágico\" suave con curva\nfloat SparkleMagic(float t, float seed)\n{\n    float r = FlickerSmooth(t, seed);\n    return pow(r, 6.0); // muy oscuro con picos brillantes\n}\n\n// Flash aleatorio con on/off\nfloat RandomFlash(float t, float seed, float chance)\n{\n    return step(1.0 - chance, HashLoop(t * 10.0, seed));\n}\n\n//-----------------------------------------------------------\n// PATRONES MULTICAPA / RUIDOS DE LUZ\n//-----------------------------------------------------------\n\n// Luz pulsante tipo faro o lava\nfloat BeaconLight(float t, float base, float flicker, float speed, float seed)\n{\n    float wave = Sin01(t * speed);\n    float fx = FlickerSmooth(t * speed, seed);\n    return base + wave * 0.5 + fx * flicker;\n}\n\n// Luz fuego procedural\nfloat FireLight(float t, float base, float chaos, float seed)\n{\n    float f = FlickerFast(t, seed);\n    return base + pow(f, 3.0) * chaos;\n}\n\n// Electricidad / glitch\nfloat ElectricJitter(float t, float seed)\n{\n    return SquareWave(t * 10.0 + HashLoop(t, seed), 0.2) * HashLoop(t * 2.0, seed);\n}\n\n//-----------------------------------------------------------\n// SHAPES LOOPABLES COMO MÁSCARAS\n//-----------------------------------------------------------\n\n// Pulso loopable con rango\nfloat Pulse(float t, float width)\n{\n    return step(frac(t), width);\n}\n\n// Pulso suave loopable\nfloat PulseSmooth(float t, float width, float fade)\n{\n    float f = frac(t);\n    return smoothstep(0.0, fade, f) * (1.0 - smoothstep(width - fade, width, f));\n}\n\n#endif // VFX_WAVES_INCLUDED",
    "type": "código"
  },
  {
    "id": "14da0bf4-8597-4e75-a13e-5b077466c80c",
    "title": "Stars optimized",
    "created_at": "2025-04-03T18:35:52.437417+00:00",
    "content": "// === Optimized 3D Gradient Noise ===\nvec3 hash(vec3 p) {\n    p = fract(p * 0.3183099 + vec3(0.1, 0.2, 0.3));\n    p *= 17.0;\n    return -1.0 + 2.0 * fract(p * (p.yzx + 19.19));\n}\n\nfloat noise(vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    vec3 u = f * f * (3.0 - 2.0 * f);\n\n    vec3 g000 = hash(i + vec3(0,0,0));\n    vec3 g100 = hash(i + vec3(1,0,0));\n    vec3 g010 = hash(i + vec3(0,1,0));\n    vec3 g110 = hash(i + vec3(1,1,0));\n    vec3 g001 = hash(i + vec3(0,0,1));\n    vec3 g101 = hash(i + vec3(1,0,1));\n    vec3 g011 = hash(i + vec3(0,1,1));\n    vec3 g111 = hash(i + vec3(1,1,1));\n\n    float n000 = dot(g000, f - vec3(0,0,0));\n    float n100 = dot(g100, f - vec3(1,0,0));\n    float n010 = dot(g010, f - vec3(0,1,0));\n    float n110 = dot(g110, f - vec3(1,1,0));\n    float n001 = dot(g001, f - vec3(0,0,1));\n    float n101 = dot(g101, f - vec3(1,0,1));\n    float n011 = dot(g011, f - vec3(0,1,1));\n    float n111 = dot(g111, f - vec3(1,1,1));\n\n    float nx00 = mix(n000, n100, u.x);\n    float nx10 = mix(n010, n110, u.x);\n    float nx01 = mix(n001, n101, u.x);\n    float nx11 = mix(n011, n111, u.x);\n\n    float nxy0 = mix(nx00, nx10, u.y);\n    float nxy1 = mix(nx01, nx11, u.y);\n\n    return mix(nxy0, nxy1, u.z);\n}\n\n// === Main Shader ===\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 centeredUV = uv * 2.0 - 1.0;\n\n    // Curvatura angular (más bajo = más compresión en bordes)\n    float angularScale = 0.3;\n\n    // Zoom global del patrón\n    float zoom = 4.0;\n\n    // Dirección corregida\n    vec3 dir = normalize(vec3(centeredUV * angularScale, 1.0));\n    vec3 dir200 = dir * 200.0 * zoom;\n    vec3 dir100 = dir * 100.0 * zoom + vec3(iTime);\n\n    // Base noise\n    float baseNoise = clamp(noise(dir200), 0.0, 1.0);\n\n    // Más estrellas: usamos pow(x, 4) en lugar de pow(x, 8)\n    float n = baseNoise;\n    n *= n; // ^2\n    n *= n; // ^4\n\n    float flicker = mix(0.4, 1.4, noise(dir100));\n    float stars = n * 200.0 * flicker;\n\n    fragColor = vec4(vec3(stars), 1.0);\n}",
    "type": "código"
  },
  {
    "id": "7cc47bd6-fac6-4cde-8a82-772d4c0bf660",
    "title": "Vertex shader toolkit",
    "created_at": "2025-04-02T06:27:08.30053+00:00",
    "content": "//=========================================================================\n// VERTEX TRANSFORM UTILITY LIBRARY - VFX / TECHNICAL ARTISTS\n//=========================================================================\n\n#ifndef VFX_VERTEX_TRANSFORMS_INCLUDED\n#define VFX_VERTEX_TRANSFORMS_INCLUDED\n\n//-----------------------------------------------------------\n// ROTACIONES\n//-----------------------------------------------------------\n\n// Rotación en el eje Z\nfloat2 Rotate2D(float2 pos, float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return float2(pos.x * c - pos.y * s, pos.x * s + pos.y * c);\n}\n\n// Rotación alrededor de eje arbitrario\nfloat3 RotateAroundAxis(float3 pos, float3 axis, float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    float3x3 R =\n    {\n        c + axis.x * axis.x * (1 - c),\n        axis.x * axis.y * (1 - c) - axis.z * s,\n        axis.x * axis.z * (1 - c) + axis.y * s,\n\n        axis.y * axis.x * (1 - c) + axis.z * s,\n        c + axis.y * axis.y * (1 - c),\n        axis.y * axis.z * (1 - c) - axis.x * s,\n\n        axis.z * axis.x * (1 - c) - axis.y * s,\n        axis.z * axis.y * (1 - c) + axis.x * s,\n        c + axis.z * axis.z * (1 - c)\n    };\n    return mul(R, pos);\n}\n\n// Rotación alrededor de un pivote\nfloat3 RotateAroundPivot(float3 pos, float3 pivot, float3 axis, float angle)\n{\n    float3 local = pos - pivot;\n    float3 rotated = RotateAroundAxis(local, axis, angle);\n    return rotated + pivot;\n}\n\n//-----------------------------------------------------------\n// ESCALADO Y TRANSLACIÓN\n//-----------------------------------------------------------\n\nfloat3 ScaleAroundPivot(float3 pos, float3 pivot, float3 scale)\n{\n    return (pos - pivot) * scale + pivot;\n}\n\nfloat3 Translate(float3 pos, float3 offset)\n{\n    return pos + offset;\n}\n\n//-----------------------------------------------------------\n// DEFORMACIONES / OSCILACIONES\n//-----------------------------------------------------------\n\n// Onda senoidal en eje Y\nfloat3 SinWaveY(float3 pos, float frequency, float amplitude, float time)\n{\n    pos.y += sin(pos.x * frequency + time) * amplitude;\n    return pos;\n}\n\n// Wobble XYZ (3D sin wave)\nfloat3 Wobble(float3 pos, float3 freq, float3 amp, float time)\n{\n    pos += sin(pos * freq + time) * amp;\n    return pos;\n}\n\n// Morph entre dos posiciones\nfloat3 MorphPosition(float3 posA, float3 posB, float factor)\n{\n    return lerp(posA, posB, factor);\n}\n\n// Stretch hacia arriba con falloff (útil para FX tipo \"grow\")\nfloat3 VerticalStretch(float3 pos, float heightLimit, float intensity)\n{\n    float t = saturate(pos.y / heightLimit);\n    pos.y += t * intensity;\n    return pos;\n}\n\n//-----------------------------------------------------------\n// NOISE VERTEX OFFSET\n//-----------------------------------------------------------\n\n// Hash rápido\nfloat Hash21(float2 p)\n{\n    p = frac(p * float2(123.34, 456.21));\n    p += dot(p, p + 45.32);\n    return frac(p.x * p.y);\n}\n\n// Simple noise offset en Y\nfloat3 VertexNoiseOffset(float3 pos, float scale, float strength)\n{\n    float2 p = pos.xz * scale;\n    float noise = Hash21(p);\n    pos.y += (noise - 0.5) * strength;\n    return pos;\n}\n\n// Noise animado (ideal para fuego, lava, etc.)\nfloat3 VertexNoiseAnim(float3 pos, float scale, float strength, float time)\n{\n    float2 p = pos.xz * scale + time * 0.5;\n    float noise = Hash21(p);\n    pos.y += (noise - 0.5) * strength;\n    return pos;\n}\n\n//-----------------------------------------------------------\n// TAPER Y SHEAR\n//-----------------------------------------------------------\n\n// Taper: estrecha o ensancha según altura\nfloat3 TaperY(float3 pos, float height, float factor)\n{\n    float t = saturate(pos.y / height);\n    pos.xz *= lerp(1.0, factor, t);\n    return pos;\n}\n\n// Shear XZ basado en altura Y\nfloat3 ShearXZ(float3 pos, float height, float shearAmount)\n{\n    float t = saturate(pos.y / height);\n    pos.x += t * shearAmount;\n    pos.z += t * shearAmount;\n    return pos;\n}\n\n#endif // VFX_VERTEX_TRANSFORMS_INCLUDED",
    "type": "código"
  },
  {
    "id": "245ebab7-793f-4bda-b6c8-05ac1fcec3e7",
    "title": "Postprocess",
    "created_at": "2025-04-02T06:24:00.383718+00:00",
    "content": "//=========================================================================\n// VFX/TECH ARTISTS - HLSL LIBRARY 2 + 5 + 6 + 9\n// Shapes Procedurales + TBN/Parallax + Material FX + Post FX\n//=========================================================================\n\n#ifndef VFX_MATERIAL_UTILS_INCLUDED\n#define VFX_MATERIAL_UTILS_INCLUDED\n\n//=========================================================================\n// 2. SHAPES PROCEDURALES (sin texturas)\n//=========================================================================\n\n// Círculo centrado en UV\nfloat Circle(float2 uv, float2 center, float radius)\n{\n    float d = distance(uv, center);\n    return step(d, radius);\n}\n\n// Círculo suave\nfloat SoftCircle(float2 uv, float2 center, float radius, float softness)\n{\n    float d = distance(uv, center);\n    return smoothstep(radius, radius - softness, d);\n}\n\n// Estrella de 5 puntas\nfloat Star5(float2 uv, float2 center, float size, float sharpness)\n{\n    float2 p = uv - center;\n    float a = atan2(p.y, p.x);\n    float r = length(p);\n    float star = cos(5.0 * a) * sharpness + 0.5;\n    return smoothstep(star * size, star * size - 0.01, r);\n}\n\n// Polígono",
    "type": "código"
  },
  {
    "id": "dd29ea9a-dd13-4574-8106-6089b3a8d59e",
    "title": "Distortion and geo",
    "created_at": "2025-04-02T06:22:24.051298+00:00",
    "content": "//=========================================================================\n// VFX/TECH ARTISTS - MEGA HLSL LIBRARY\n// Distorsión UV + Geometría de Pantalla + Fresnel + Luz + Glitch FX\n//=========================================================================\n\n#ifndef VFX_MEGA_LIB_INCLUDED\n#define VFX_MEGA_LIB_INCLUDED\n\n//=========================================================================\n// 1. DISTORSIÓN UV / PROCEDURAL WARP\n//=========================================================================\n\n// Scroll UV básico\nfloat2 ScrollUV(float2 uv, float2 direction, float speed, float time)\n{\n    return uv + direction * speed * time;\n}\n\n// Onda senoidal\nfloat2 SinWaveDistort(float2 uv, float frequency, float amplitude, float time)\n{\n    uv.y += sin(uv.x * frequency + time) * amplitude;\n    return uv;\n}\n\n// Onda radial (turbulencia circular)\nfloat2 RadialWaveDistort(float2 uv, float2 center, float freq, float amp, float time)\n{\n    float2 offset = uv - center;\n    float r = length(offset);\n    float angle = atan2(offset.y, offset.x);\n    r += sin(angle * freq + time) * amp;\n    return center + float2(cos(angle), sin(angle)) * r;\n}\n\n// Distorsión con ruido simple\nfloat Hash21(float2 p)\n{\n    p = frac(p * float2(123.34, 456.21));\n    p += dot(p, p + 45.32);\n    return frac(p.x * p.y);\n}\n\nfloat ValueNoise(float2 uv)\n{\n    float2 i = floor(uv);\n    float2 f = frac(uv);\n    float a = Hash21(i);\n    float b = Hash21(i + float2(1, 0));\n    float c = Hash21(i + float2(0, 1));\n    float d = Hash21(i + float2(1, 1));\n    float2 u = f * f * (3.0 - 2.0 * f);\n    return lerp(lerp(a, b, u.x), lerp(c, d, u.x), u.y);\n}\n\nfloat2 NoiseWarpUV(float2 uv, float scale, float strength, float time)\n{\n    float2 n = float2(\n        ValueNoise(uv * scale + float2(0, time)),\n        ValueNoise(uv * scale + float2(5.2, time + 1.0))\n    );\n    return uv + (n - 0.5) * strength;\n}\n\n//=========================================================================\n// 3. GEOMETRÍA DE PANTALLA / UV TOOLS\n//=========================================================================\n\n// Coordenadas centradas (-1 a 1)\nfloat2 CenteredUV(float2 uv)\n{\n    return uv * 2.0 - 1.0;\n}\n\n// Distancia al centro\nfloat DistanceToCenter(float2 uv)\n{\n    return length(CenteredUV(uv));\n}\n\n// Máscara de borde (falloff hacia los lados)\nfloat EdgeMask(float2 uv, float thickness)\n{\n    float2 edge = min(uv, 1.0 - uv);\n    return smoothstep(thickness, 0.0, min(edge.x, edge.y));\n}\n\n// Coordenadas NDC (si se requiere)\nfloat2 NDCFromUV(float2 uv)\n{\n    return uv * 2.0 - 1.0;\n}\n\n// Mapa de dirección hacia el centro (vector unitario)\nfloat2 DirectionToCenter(float2 uv)\n{\n    return normalize(0.5 - uv);\n}\n\n//=========================================================================\n// 4. FRESNEL / CURVATURA\n//=========================================================================\n\n// Fresnel básico\nfloat FresnelBasic(float3 normal, float3 viewDir)\n{\n    return 1.0 - saturate(dot(normalize(normal), normalize(viewDir)));\n}\n\n// Fresnel con power y bias\nfloat FresnelAdvanced(float3 normal, float3 viewDir, float power, float bias)\n{\n    float f = 1.0 - saturate(dot(normalize(normal), normalize(viewDir)));\n    return pow(f, power) + bias;\n}\n\n// Curvatura simple usando diferencia entre normal y view\nfloat NormalCurvatureMask(float3 normal, float3 refNormal)\n{\n    return saturate(1.0 - dot(normalize(normal), normalize(refNormal)));\n}\n\n// Edge highlight por curvatura\nfloat EdgeHighlight(float3 normal, float3 viewDir, float power)\n{\n    float f = 1.0 - dot(normalize(normal), normalize(viewDir));\n    return pow(f, power);\n}\n\n//=========================================================================\n// 7. LUZ PROCEDURAL / SHADING CUSTOM\n//=========================================================================\n\n// Luz direccional simulada\nfloat SimulatedDirectionalLight(float3 normal, float3 lightDir)\n{\n    return saturate(dot(normalize(normal), normalize(lightDir)));\n}\n\n// Luz puntual simulada (basada en distancia)\nfloat SimulatedPointLight(float3 worldPos, float3 lightPos, float3 normal)\n{\n    float3 toLight = lightPos - worldPos;\n    float d = length(toLight);\n    float3 L = normalize(toLight);\n    float NdotL = saturate(dot(normal, L));\n    return NdotL / (d * d); // iluminación realista con caída\n}\n\n// Luz esférica suave (ideal para UI o FX en pantalla)\nfloat SphereLight(float2 uv, float2 center, float radius)\n{\n    float dist = distance(uv, center);\n    return smoothstep(radius, 0.0, dist);\n}\n\n// Sombra UV simulada\nfloat UVShadow(float2 uv, float2 lightDir, float softness)\n{\n    float n = dot(normalize(uv - 0.5), normalize(lightDir));\n    return smoothstep(0.0, softness, n);\n}\n\n//=========================================================================\n// 8. GLITCH FX / ERRORES VISUALES\n//=========================================================================\n\n// Separación de canales RGB (glitch tipo VHS)\nfloat2 RGBOffset(float2 uv, float time, float intensity, float channelOffset)\n{\n    float offset = sin(time * 20.0 + uv.y * 100.0) * intensity;\n    return uv + float2(channelOffset * offset, 0.0);\n}\n\n// Salto UV (tipo flicker o salto de línea)\nfloat2 UVJump(float2 uv, float time, float intensity)\n{\n    float glitch = step(0.95, frac(sin(dot(uv, float2(12.989, 78.233)) + time) * 43758.5453));\n    return uv + float2(0.0, glitch * intensity);\n}\n\n// Scanlines animadas\nfloat Scanlines(float2 uv, float time, float frequency, float thickness)\n{\n    float line = sin(uv.y * frequency + time * 20.0);\n    return smoothstep(thickness, 0.0, abs(line));\n}\n\n// Glitch temporal (fade in/out tipo error)\nfloat TemporalGlitch(float time, float speed, float duration)\n{\n    float t = frac(time * speed);\n    return step(t, duration);\n}\n\n#endif // VFX_MEGA_LIB_INCLUDED",
    "type": "código"
  },
  {
    "id": "5d95dfe9-d816-4ee5-8391-05d69f915e50",
    "title": "Time library",
    "created_at": "2025-04-02T06:12:08.567279+00:00",
    "content": "//===========================================================\n// TIME UTILITY LIBRARY - VFX / TECHNICAL ARTISTS\n// Usando i.fTime como base de tiempo\n//===========================================================\n\n#ifndef TIME_UTILS_INCLUDED\n#define TIME_UTILS_INCLUDED\n\n//-----------------------------------------------------------\n// Tiempo normalizado cíclico [0 → 1]\n// Ideal para loops de animación\n//-----------------------------------------------------------\nfloat Time01(float time, float speed)\n{\n    return frac(time * speed);\n}\n\n//-----------------------------------------------------------\n// Tiempo senoidal suave entre 0 y 1\n// Oscila suavemente - ideal para efectos respirantes o pulsantes\n//-----------------------------------------------------------\nfloat SineTime01(float time, float speed)\n{\n    return sin(time * speed) * 0.5 + 0.5;\n}\n\n//-----------------------------------------------------------\n// PingPong (triángulo) entre 0 y 1\n// Útil para efectos que deben ir y volver\n//-----------------------------------------------------------\nfloat PingPong(float time, float speed)\n{\n    return abs(frac(time * speed) * 2.0 - 1.0);\n}\n\n//-----------------------------------------------------------\n// Onda triangular suavizada (para parpadeos, loops simétricos)\n//-----------------------------------------------------------\nfloat TriangleWave(float time, float speed)\n{\n    return abs(frac(time * speed + 0.5) * 2.0 - 1.0);\n}\n\n//-----------------------------------------------------------\n// Pulso repetitivo (ideal para flashes, glitches...)\n// Devuelve 1 solo durante un tramo del ciclo\n//-----------------------------------------------------------\nfloat PulseLoop(float time, float speed, float width)\n{\n    float t = frac(time * speed);\n    return step(t, width); // Ejemplo: width = 0.1 → pulso breve\n}\n\n//-----------------------------------------------------------\n// Oscilador entre dos valores\n//-----------------------------------------------------------\nfloat Oscillate(float minVal, float maxVal, float time, float speed)\n{\n    float t = SineTime01(time, speed);\n    return lerp(minVal, maxVal, t);\n}\n\n//-----------------------------------------------------------\n// Ramp-Up Loop: sube de 0 a 1, luego se queda en 1 por un tiempo\n//-----------------------------------------------------------\nfloat RampHoldLoop(float time, float speed, float holdRatio)\n{\n    float t = frac(time * speed);\n    float rise = 1.0 - holdRatio;\n    return t < rise ? t / rise : 1.0;\n}\n\n//-----------------------------------------------------------\n// Delay temporal por fragmento (útil para efectos secuenciales)\n//-----------------------------------------------------------\nfloat TimeWithDelay(float time, float delay)\n{\n    return max(0.0, time - delay);\n}\n\n//-----------------------------------------------------------\n// Fase desincronizada por UV o World Position\n// Perfecto para que cada píxel haga el efecto en distinto momento\n//-----------------------------------------------------------\nfloat DesyncByCoord(float2 uv, float time, float speed, float spread)\n{\n    float offset = frac(dot(uv, float2(12.9898, 78.233))) * spread;\n    return frac((time + offset) * speed);\n}\n\n#endif // TIME_UTILS_INCLUDED",
    "type": "código"
  },
  {
    "id": "57b07ed6-96c1-41c8-8ee8-16b52c5ab250",
    "title": "Masks library",
    "created_at": "2025-04-01T21:59:41.320255+00:00",
    "content": "//===========================================================\n// HLSL MASK LIBRARY - EXTENDED\n//===========================================================\n\n#ifndef VFX_MASKS_INCLUDED\n#define VFX_MASKS_INCLUDED\n\n//-----------------------------------------------------------\n// UTILIDADES BÁSICAS\n//-----------------------------------------------------------\n\n// Clamp suave entre 0–1\nfloat Saturate(float x) {\n    return clamp(x, 0.0, 1.0);\n}\n\n// Interpolación suave Hermite (usado en soft masks)\nfloat SmoothStep(float edge0, float edge1, float x) {\n    float t = saturate((x - edge0) / (edge1 - edge0));\n    return t * t * (3.0 - 2.0 * t);\n}\n\n// Pulse entre dos rangos\nfloat Pulse(float edge0, float edge1, float x) {\n    return step(edge0, x) - step(edge1, x);\n}\n\n// Distancia UV al centro\nfloat DistToCenter(float2 uv, float2 center) {\n    return distance(uv, center);\n}\n\nfloat DistToEdge(float2 uv) {\n    float2 d = min(uv, 1.0 - uv);\n    return min(d.x, d.y);\n}\n\n//-----------------------------------------------------------\n// FORMAS BÁSICAS\n//-----------------------------------------------------------\n\n// Máscara circular\nfloat CircleMask(float2 uv, float2 center, float radius) {\n    float d = distance(uv, center);\n    return step(d, radius);\n}\n\n// Círculo suave (falloff)\nfloat SoftCircleMask(float2 uv, float2 center, float radius, float softness) {\n    float d = distance(uv, center);\n    return smoothstep(radius, radius - softness, d);\n}\n\n// Rectángulo centrado (sin rotación)\nfloat BoxMask(float2 uv, float2 center, float2 size) {\n    float2 diff = abs(uv - center);\n    float2 halfSize = size * 0.5;\n    return step(diff.x, halfSize.x) * step(diff.y, halfSize.y);\n}\n\n// Rectángulo con bordes suaves\nfloat SoftBoxMask(float2 uv, float2 center, float2 size, float softness) {\n    float2 diff = abs(uv - center);\n    float2 halfSize = size * 0.5;\n    float2 edge = smoothstep(halfSize, halfSize - softness, diff);\n    return edge.x * edge.y;\n}\n\n// Línea horizontal con grosor\nfloat LineMask(float2 uv, float y, float thickness) {\n    return step(abs(uv.y - y), thickness * 0.5);\n}\n\n// Línea suave\nfloat SoftLineMask(float2 uv, float y, float thickness, float softness) {\n    float d = abs(uv.y - y);\n    return smoothstep(thickness * 0.5 + softness, thickness * 0.5, d);\n}\n\n//-----------------------------------------------------------\n// FORMAS AVANZADAS\n//-----------------------------------------------------------\n\n// Anillo\nfloat RingMask(float2 uv, float2 center, float radius, float thickness) {\n    float d = distance(uv, center);\n    return step(abs(d - radius), thickness * 0.5);\n}\n\n// Anillo suave\nfloat SoftRingMask(float2 uv, float2 center, float radius, float thickness, float softness) {\n    float d = distance(uv, center);\n    float outer = smoothstep(radius + thickness * 0.5, radius + thickness * 0.5 - softness, d);\n    float inner = smoothstep(radius - thickness * 0.5, radius - thickness * 0.5 + softness, d);\n    return outer * inner;\n}\n\n// Máscara radial (de centro a borde)\nfloat RadialGradient(float2 uv, float2 center) {\n    return saturate(distance(uv, center));\n}\n\n// Máscara radial invertida\nfloat InvertedRadial(float2 uv, float2 center) {\n    return 1.0 - RadialGradient(uv, center);\n}\n\n// Máscara tipo borde\nfloat EdgeMask(float2 uv, float thickness) {\n    float edge = min(min(uv.x, 1.0 - uv.x), min(uv.y, 1.0 - uv.y));\n    return step(thickness, edge);\n}\n\n//-----------------------------------------------------------\n// MÁSCARAS ANIMADAS\n//-----------------------------------------------------------\n\n// Wipe horizontal\nfloat HorizontalWipe(float2 uv, float progress) {\n    return step(uv.x, progress);\n}\n\n// Wipe radial (reloj)\nfloat RadialWipe(float2 uv, float2 center, float progress) {\n    float2 dir = normalize(uv - center);\n    float angle = atan2(dir.y, dir.x) / (2.0 * 3.14159) + 0.5;\n    return step(angle, progress);\n}\n\n// Máscara con ruido\nfloat NoisyMask(float2 uv, float noiseValue, float threshold, float softness) {\n    return smoothstep(threshold, threshold - softness, noiseValue);\n}\n\n//-----------------------------------------------------------\n// MÁSCARAS EN ESPACIO WORLD / PERSONALIZADO\n//-----------------------------------------------------------\n\n// Máscara basada en altura (eje Y)\nfloat HeightMask(float3 worldPos, float height, float falloff) {\n    return smoothstep(height, height - falloff, worldPos.y);\n}\n\n// Máscara por proyección planar Y\nfloat PlanarYMask(float3 worldPos, float centerY, float range, float falloff) {\n    float d = abs(worldPos.y - centerY);\n    return smoothstep(range, range - falloff, d);\n}\n\n// Máscara por distancia a un punto en mundo\nfloat WorldDistanceMask(float3 worldPos, float3 worldCenter, float radius, float softness) {\n    float d = distance(worldPos, worldCenter);\n    return smoothstep(radius, radius - softness, d);\n}\n\n//-----------------------------------------------------------\n// MÁSCARA MODULADA / COMBINADA\n//-----------------------------------------------------------\n\n// Combine (AND lógico)\nfloat CombineAND(float a, float b) {\n    return a * b;\n}\n\n// Combine (OR lógico)\nfloat CombineOR(float a, float b) {\n    return saturate(a + b);\n}\n\n// Combine (XOR lógico visual)\nfloat CombineXOR(float a, float b) {\n    return abs(a - b);\n}\n\n// Interpolación entre dos máscaras\nfloat BlendMasks(float a, float b, float blend) {\n    return lerp(a, b, blend);\n}\n\n#endif // VFX_MASKS_INCLUDED",
    "type": "código"
  },
  {
    "id": "e0315988-7742-41bd-9e26-24a8ab9cb5b1",
    "title": "Utility Library",
    "created_at": "2025-04-01T21:56:28.250214+00:00",
    "content": "//====================================================================\n// HLSL UTILITY LIBRARY - TECHNICAL & VFX ARTISTS v2\n//====================================================================\n\n#ifndef VFX_UTILS_INCLUDED\n#define VFX_UTILS_INCLUDED\n\n//--------------------------------------------------\n// REMAP / INTERPOLACIONES\n//--------------------------------------------------\n\nfloat Remap(float v, float inMin, float inMax, float outMin, float outMax) {\n    return outMin + (v - inMin) * (outMax - outMin) / (inMax - inMin);\n}\n\nfloat RemapClamped(float v, float inMin, float inMax, float outMin, float outMax) {\n    float t = saturate((v - inMin) / (inMax - inMin));\n    return lerp(outMin, outMax, t);\n}\n\nfloat InverseLerp(float a, float b, float v) {\n    return saturate((v - a) / (b - a));\n}\n\nfloat EaseIn(float t)    { return t * t; }\nfloat EaseOut(float t)   { return 1.0 - pow(1.0 - t, 2.0); }\nfloat EaseInOut(float t) { return lerp(t*t, 1.0 - pow(1.0 - t, 2.0), step(0.5, t)); }\n\nfloat SmoothLerp(float a, float b, float t) {\n    t = t * t * (3.0 - 2.0 * t); // Hermite\n    return lerp(a, b, t);\n}\n\n//--------------------------------------------------\n// PROYECCIONES UV\n//--------------------------------------------------\n\n// Planar Projection\nfloat2 ProjectPlanar(float3 pos, float3 axisU, float3 axisV) {\n    return float2(dot(pos, axisU), dot(pos, axisV));\n}\n\n// Triplanar Projection (sin blending)\nfloat2 TriplanarUV(float3 pos, float3 normal, out float3 weights) {\n    float3 absN = abs(normal);\n    weights = absN / (absN.x + absN.y + absN.z);\n    return pos.yz; // ejemplo para eje Y, ajusta según blend deseado\n}\n\n// Cylindrical Projection\nfloat2 ProjectCylindrical(float3 pos) {\n    float angle = atan2(pos.z, pos.x);\n    float u = (angle + 3.14159) / (2.0 * 3.14159);\n    float v = pos.y;\n    return float2(u, v);\n}\n\n// Spherical Projection\nfloat2 ProjectSpherical(float3 pos) {\n    float3 n = normalize(pos);\n    float u = 0.5 + atan2(n.z, n.x) / (2.0 * 3.14159);\n    float v = 0.5 - asin(n.y) / 3.14159;\n    return float2(u, v);\n}\n\n//--------------------------------------------------\n// RUIDOS - ORDENADOS DE MÁS BARATO A MÁS CARO\n//--------------------------------------------------\n\n//--- 1. Hash noise (barato, sin continuidad) ---\nfloat Hash21(float2 p) {\n    p = frac(p * float2(123.34, 456.21));\n    p += dot(p, p + 45.32);\n    return frac(p.x * p.y);\n}\n\n//--- 2. Value Noise 2D (barato, interpolado) ---\nfloat ValueNoise(float2 uv) {\n    float2 i = floor(uv);\n    float2 f = frac(uv);\n    float a = Hash21(i);\n    float b = Hash21(i + float2(1, 0));\n    float c = Hash21(i + float2(0, 1));\n    float d = Hash21(i + float2(1, 1));\n    float2 u = f * f * (3.0 - 2.0 * f);\n    return lerp(lerp(a, b, u.x), lerp(c, d, u.x), u.y);\n}\n\n//--- 3. Perlin Noise 2D (más costoso, continuo) ---\nfloat2 Fade(float2 t) {\n    return t * t * (3.0 - 2.0 * t);\n}\n\nfloat Grad2(float2 p, float2 ip) {\n    float2 gradient = normalize(frac(sin(dot(ip, float2(127.1, 311.7))) * 43758.5453) * 2.0 - 1.0);\n    return dot(p, gradient);\n}\n\nfloat PerlinNoise(float2 uv) {\n    float2 i = floor(uv);\n    float2 f = frac(uv);\n\n    float a = Grad2(f, i);\n    float b = Grad2(f - float2(1, 0), i + float2(1, 0));\n    float c = Grad2(f - float2(0, 1), i + float2(0, 1));\n    float d = Grad2(f - float2(1, 1), i + float2(1, 1));\n\n    float2 u = Fade(f);\n    return lerp(lerp(a, b, u.x), lerp(c, d, u.x), u.y);\n}\n\n//--- 4. Gaussian Noise (para desenfoques o distorsión sutil) ---\nfloat Gaussian(float2 uv, float2 center, float sigma) {\n    float2 diff = uv - center;\n    float r2 = dot(diff, diff);\n    return exp(-r2 / (2.0 * sigma * sigma));\n}\n\n//--------------------------------------------------\n// MÁSCARAS / FORMAS\n//--------------------------------------------------\n\nfloat CircleMask(float2 uv, float2 center, float radius, float softness) {\n    float d = distance(uv, center);\n    return smoothstep(radius, radius - softness, d);\n}\n\nfloat RingMask(float2 uv, float2 center, float radius, float thickness, float softness) {\n    float d = distance(uv, center);\n    float outer = smoothstep(radius, radius - softness, d);\n    float inner = smoothstep(radius - thickness, radius - thickness - softness, d);\n    return outer * (1.0 - inner);\n}\n\nfloat SoftMask(float mask, float threshold, float softness) {\n    return smoothstep(threshold, threshold - softness, mask);\n}\n\n//--------------------------------------------------\n// ANIMACIONES / EFECTOS TIEMPO\n//--------------------------------------------------\n\nfloat Oscillate(float minVal, float maxVal, float time, float speed) {\n    float t = sin(time * speed) * 0.5 + 0.5;\n    return lerp(minVal, maxVal, t);\n}\n\nfloat TriangleWave(float t) {\n    return abs(frac(t + 0.5) * 2.0 - 1.0);\n}\n\nfloat Pulse(float edge0, float edge1, float x) {\n    return step(edge0, x) - step(edge1, x);\n}\n\n//--------------------------------------------------\n// COLOR\n//--------------------------------------------------\n\nfloat3 HSVtoRGB(float3 hsv) {\n    float3 K = float3(1.0, 2.0 / 3.0, 1.0 / 3.0);\n    float3 P = abs(frac(hsv.xxx + K.xyz) * 6.0 - 3.0);\n    return hsv.z * lerp(K.xxx, saturate(P - K.xxx), hsv.y);\n}\n\nfloat3 RGBtoHSV(float3 c) {\n    float4 K = float4(0., -1./3., 2./3., -1.);\n    float4 p = (c.g < c.b) ? float4(c.bg, K.wz) : float4(c.gb, K.xy);\n    float4 q = (c.r < p.x) ? float4(p.xyw, c.r) : float4(c.r, p.yzx);\n    float d = q.x - min(q.w, q.y);\n    float e = 1e-10;\n    return float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n#endif // VFX_UTILS_INCLUDED",
    "type": "código"
  },
  {
    "id": "193a1eff-8d79-4708-a78e-ca1e2e5894c2",
    "title": "Funciones hlsl mas usadas",
    "created_at": "2025-04-01T21:48:57.925052+00:00",
    "content": "//==============================\n// FUNCIONES HLSL MÁS USADAS\n//==============================\n\n//----- MATH BÁSICA -----\nfloat a = abs(-2.5);             // valor absoluto\nfloat b = ceil(1.3);             // redondea hacia arriba\nfloat c = floor(1.9);            // redondea hacia abajo\nfloat d = frac(3.75);            // parte decimal (0.75)\nfloat e = fmod(5.2, 2.0);        // módulo decimal (1.2)\nfloat f = clamp(1.5, 0.0, 1.0);  // limita entre 0 y 1\nfloat g = lerp(0.0, 1.0, 0.5);   // interpolación lineal (0.5)\nfloat h = min(2.0, 3.0);         // 2.0\nfloat i = max(5.0, 4.0);         // 5.0\nfloat j = saturate(x);           // clamp entre 0 y 1\n\n//----- RAMPAS / CONTROL -----\nfloat s1 = step(0.5, 0.3);                 // 0.0 (x < edge)\nfloat s2 = smoothstep(0.2, 0.8, 0.5);      // rampa suave\nfloat s3 = sign(-5.0);                     // -1\nfloat s4 = isnan(value);                  // 1 si es NaN\n\n//----- TRIGONOMETRÍA -----\nfloat t1 = sin(3.14);\nfloat t2 = cos(0.0);\nfloat t3 = tan(1.0);\nfloat t4 = asin(1.0);\nfloat t5 = acos(0.0);\nfloat t6 = atan2(y, x); // ángulo entre (x, y)\n\n//----- POTENCIAS Y LOGARITMOS -----\nfloat p1 = pow(2.0, 3.0);  // 8\nfloat p2 = sqrt(25.0);     // 5\nfloat p3 = rsqrt(25.0);    // 1 / sqrt(25) = 0.2\nfloat p4 = exp(1.0);       // e^1\nfloat p5 = log(2.71828);   // loge\n\n//----- VECTORES -----\nfloat len = length(float3(1, 2, 2));           // magnitud\nfloat dist = distance(a, b);                   // distancia\nfloat3 norm = normalize(float3(1, 2, 3));      // vector normalizado\nfloat dp = dot(a, b);                          // producto punto\nfloat3 cr = cross(float3(1,0,0), float3(0,1,0));// producto cruzado\nfloat3 ref = reflect(-viewDir, normal);        // reflexión\nfloat3 refr = refract(viewDir, normal, 1.0);   // refracción\nfloat3 face = faceforward(n, i, ng);           // orienta una normal hacia la cámara\n\n//----- TEXTURAS -----\nTexture2D tex : register(t0);\nSamplerState samp : register(s0);\nfloat4 col = tex.Sample(samp, uv);                 // sampleo normal\nfloat4 colBias = tex.SampleBias(samp, uv, -1.0);   // con bias\nfloat4 colGrad = tex.SampleGrad(samp, uv, dx, dy); // con gradiente manual\nfloat4 colLOD = tex.SampleLevel(samp, uv, 2.0);     // sample mip específico\nfloat2 texSize; tex.GetDimensions(texSize.x, texSize.y);\n\n//----- COLORES -----\nfloat3 hsv = float3(0.6, 1.0, 1.0); // ejemplo color HSV\nfloat3 rgb = hsv2rgb(hsv);          // si defines tú mismo esta función\nfloat3 gray = float3(0.5.xxx);      // gris neutro\n\n//----- UV / ANIMACIÓN -----\nfloat wave = sin(uv.x * 10.0 + time * 5.0);    // animación senoidal\nfloat2 scrollUV = uv + time * 0.1;            // scrolling\nfloat2 polar = float2(cos(a), sin(a));        // dirección circular\nfloat ripple = sin(distance(uv, center) * 20.0 - time * 5.0); // onda radial\n\n//----- RUIDO BÁSICO -----\nfloat hash(float2 p)\n{\n    return frac(sin(dot(p, float2(127.1, 311.7))) * 43758.5453);\n}\n\nfloat noise(float2 uv)\n{\n    float2 i = floor(uv);\n    float2 f = frac(uv);\n\n    float a = hash(i);\n    float b = hash(i + float2(1, 0));\n    float c = hash(i + float2(0, 1));\n    float d = hash(i + float2(1, 1));\n\n    float2 u = f * f * (3.0 - 2.0 * f); // fade\n\n    return lerp(lerp(a, b, u.x), lerp(c, d, u.x), u.y);\n}\n\n//----- PARALLAX OFFSET (básico) -----\nfloat height = heightMap.Sample(samp, uv).r;\nfloat2 parallaxOffset = viewDirTS.xy * height * intensity;\nfloat2 uvOffset = uv + parallaxOffset;",
    "type": "código"
  },
  {
    "id": "b8e04b67-f75f-4f2b-8f7d-f0d42cb325b3",
    "title": "Parallax mapping basico",
    "created_at": "2025-04-01T21:43:35.177911+00:00",
    "content": "float height = heightTex.Sample(sampler, uv).r;\nfloat2 offset = viewDirTS.xy * height * intensity;\nfloat2 newUV = uv + offset;",
    "type": "código"
  },
  {
    "id": "d24e3da0-cf5e-4046-9c6c-ff17dd3e7102",
    "title": "Treshold",
    "created_at": "2025-04-01T21:42:33.145036+00:00",
    "content": "Texture2D maskTex : register(t0);\nSamplerState maskSampler : register(s0);\n\nfloat threshold = 0.5;\n\nfloat4 PS_Main(float4 pos : SV_POSITION, float2 uv : TEXCOORD0) : SV_TARGET\n{\n    float mask = maskTex.Sample(maskSampler, uv).r;\n    float masked = step(threshold, mask);\n    return float4(masked.xxx, 1.0); // Blanco si mayor a threshold\n}",
    "type": "código"
  },
  {
    "id": "cd9d1012-6400-4faa-bc38-f565bec1c5e1",
    "title": "Solid Color",
    "created_at": "2025-04-01T21:41:35.893949+00:00",
    "content": "float4 PS_Main(float4 pos : SV_POSITION) : SV_TARGET\n{\n    return float4(1.0, 0.0, 0.0, 1.0); // Color rojo\n}",
    "type": "código"
  },
  {
    "id": "66607c43-d45b-4b71-9131-5fd1578fbbe3",
    "title": "Code Test",
    "created_at": "2025-04-01T20:34:40.582093+00:00",
    "content": "// Transformamos la dirección del visor de world space a tangent space\nfloat3 viewDirTS = mul(TBN, viewDirWS);\n\n// Calculamos un factor de escala basado en cuán inclinado es el ángulo de visión\n// viewDirTS.z es cuánto \"miramos de frente\"; si es bajo, estamos mirando en ángulo\n// En lugar de dividir por z, usamos (1 - z) como multiplicador para simular ese efecto\nfloat scale = saturate(1.0 - viewDirTS.z); // saturate asegura que el valor esté entre 0 y 1\n\n// Calculamos el desplazamiento de parallax multiplicando por ese factor\nfloat2 parallaxOffset = viewDirTS.xy * height * height_intensity * scale;\n\n// Sumamos el desplazamiento a las UV originales\nreturn uv + parallaxOffset;",
    "type": "código"
  }
]
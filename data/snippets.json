[
  {
    "id": "9bf4284f-5ee7-4bb8-938d-48b71db7b39c",
    "title": "Time waves",
    "created_at": "2025-04-03T18:47:17.691674+00:00",
    "content": "//=========================================================================\n// WAVE & FLICKER LIBRARY - HLSL VFX / TECHNICAL ARTISTS\n// Basado en variable 't' de tiempo (cíclica o continua)\n//=========================================================================\n\n#ifndef VFX_WAVES_INCLUDED\n#define VFX_WAVES_INCLUDED\n\n//-----------------------------------------------------------\n// ONDAS BÁSICAS (loop perfectos)\n//-----------------------------------------------------------\n\n// Onda seno normalizada [0,1]\nfloat Sin01(float t)\n{\n    return sin(t) * 0.5 + 0.5;\n}\n\n// Onda triangular [0,1]\nfloat TriangleWave(float t)\n{\n    return abs(frac(t + 0.5) * 2.0 - 1.0);\n}\n\n// Onda sierra ascendente (Sawtooth Up)\nfloat SawUp(float t)\n{\n    return frac(t);\n}\n\n// Onda sierra descendente (Sawtooth Down)\nfloat SawDown(float t)\n{\n    return 1.0 - frac(t);\n}\n\n// Onda cuadrada (Square wave)\nfloat SquareWave(float t, float threshold)\n{\n    return frac(t) < threshold ? 1.0 : 0.0;\n}\n\n// Onda seno cuadrada (Sine → Step)\nfloat SineSquare(float t, float threshold)\n{\n    return Sin01(t) > threshold ? 1.0 : 0.0;\n}\n\n//-----------------------------------------------------------\n// ONDAS MODIFICADAS / EXPONENCIALES\n//-----------------------------------------------------------\n\n// Onda exponencial rápida [0,1]\nfloat ExpSaw(float t, float k)\n{\n    return pow(frac(t), k);\n}\n\n// Onda con entrada lenta y salida rápida\nfloat EaseOutSaw(float t)\n{\n    float x = frac(t);\n    return 1.0 - pow(1.0 - x, 2.0);\n}\n\n// Onda blend senoidal-triangular\nfloat SineTriangleMix(float t, float blend)\n{\n    return lerp(TriangleWave(t), Sin01(t), blend);\n}\n\n// Oscilador entre dos valores\nfloat Oscillate(float minVal, float maxVal, float t)\n{\n    return lerp(minVal, maxVal, Sin01(t));\n}\n\n//-----------------------------------------------------------\n// FLICKERS Y RANDOM FX LOOPABLES\n//-----------------------------------------------------------\n\n// Hash simple loopable [0–1]\nfloat HashLoop(float t, float seed)\n{\n    float x = frac(t + seed);\n    return frac(sin(x * 42.376 + seed * 12.345) * 43758.5453);\n}\n\n// Flicker suave aleatorio (loop perfecto)\nfloat FlickerSmooth(float t, float seed)\n{\n    float a = HashLoop(floor(t), seed);\n    float b = HashLoop(floor(t) + 1.0, seed);\n    float f = frac(t);\n    return lerp(a, b, smoothstep(0.0, 1.0, f));\n}\n\n// Flicker agresivo / energía / fuego\nfloat FlickerFast(float t, float seed)\n{\n    return HashLoop(t * 20.0, seed);\n}\n\n// Sparkle \"mágico\" suave con curva\nfloat SparkleMagic(float t, float seed)\n{\n    float r = FlickerSmooth(t, seed);\n    return pow(r, 6.0); // muy oscuro con picos brillantes\n}\n\n// Flash aleatorio con on/off\nfloat RandomFlash(float t, float seed, float chance)\n{\n    return step(1.0 - chance, HashLoop(t * 10.0, seed));\n}\n\n//-----------------------------------------------------------\n// PATRONES MULTICAPA / RUIDOS DE LUZ\n//-----------------------------------------------------------\n\n// Luz pulsante tipo faro o lava\nfloat BeaconLight(float t, float base, float flicker, float speed, float seed)\n{\n    float wave = Sin01(t * speed);\n    float fx = FlickerSmooth(t * speed, seed);\n    return base + wave * 0.5 + fx * flicker;\n}\n\n// Luz fuego procedural\nfloat FireLight(float t, float base, float chaos, float seed)\n{\n    float f = FlickerFast(t, seed);\n    return base + pow(f, 3.0) * chaos;\n}\n\n// Electricidad / glitch\nfloat ElectricJitter(float t, float seed)\n{\n    return SquareWave(t * 10.0 + HashLoop(t, seed), 0.2) * HashLoop(t * 2.0, seed);\n}\n\n//-----------------------------------------------------------\n// SHAPES LOOPABLES COMO MÁSCARAS\n//-----------------------------------------------------------\n\n// Pulso loopable con rango\nfloat Pulse(float t, float width)\n{\n    return step(frac(t), width);\n}\n\n// Pulso suave loopable\nfloat PulseSmooth(float t, float width, float fade)\n{\n    float f = frac(t);\n    return smoothstep(0.0, fade, f) * (1.0 - smoothstep(width - fade, width, f));\n}\n\n#endif // VFX_WAVES_INCLUDED",
    "type": "código"
  },
  {
    "id": "14da0bf4-8597-4e75-a13e-5b077466c80c",
    "title": "Stars optimized",
    "created_at": "2025-04-03T18:35:52.437417+00:00",
    "content": "// === Optimized 3D Gradient Noise ===\nvec3 hash(vec3 p) {\n    p = fract(p * 0.3183099 + vec3(0.1, 0.2, 0.3));\n    p *= 17.0;\n    return -1.0 + 2.0 * fract(p * (p.yzx + 19.19));\n}\n\nfloat noise(vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    vec3 u = f * f * (3.0 - 2.0 * f);\n\n    vec3 g000 = hash(i + vec3(0,0,0));\n    vec3 g100 = hash(i + vec3(1,0,0));\n    vec3 g010 = hash(i + vec3(0,1,0));\n    vec3 g110 = hash(i + vec3(1,1,0));\n    vec3 g001 = hash(i + vec3(0,0,1));\n    vec3 g101 = hash(i + vec3(1,0,1));\n    vec3 g011 = hash(i + vec3(0,1,1));\n    vec3 g111 = hash(i + vec3(1,1,1));\n\n    float n000 = dot(g000, f - vec3(0,0,0));\n    float n100 = dot(g100, f - vec3(1,0,0));\n    float n010 = dot(g010, f - vec3(0,1,0));\n    float n110 = dot(g110, f - vec3(1,1,0));\n    float n001 = dot(g001, f - vec3(0,0,1));\n    float n101 = dot(g101, f - vec3(1,0,1));\n    float n011 = dot(g011, f - vec3(0,1,1));\n    float n111 = dot(g111, f - vec3(1,1,1));\n\n    float nx00 = mix(n000, n100, u.x);\n    float nx10 = mix(n010, n110, u.x);\n    float nx01 = mix(n001, n101, u.x);\n    float nx11 = mix(n011, n111, u.x);\n\n    float nxy0 = mix(nx00, nx10, u.y);\n    float nxy1 = mix(nx01, nx11, u.y);\n\n    return mix(nxy0, nxy1, u.z);\n}\n\n// === Main Shader ===\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 centeredUV = uv * 2.0 - 1.0;\n\n    // Curvatura angular (más bajo = más compresión en bordes)\n    float angularScale = 0.3;\n\n    // Zoom global del patrón\n    float zoom = 4.0;\n\n    // Dirección corregida\n    vec3 dir = normalize(vec3(centeredUV * angularScale, 1.0));\n    vec3 dir200 = dir * 200.0 * zoom;\n    vec3 dir100 = dir * 100.0 * zoom + vec3(iTime);\n\n    // Base noise\n    float baseNoise = clamp(noise(dir200), 0.0, 1.0);\n\n    // Más estrellas: usamos pow(x, 4) en lugar de pow(x, 8)\n    float n = baseNoise;\n    n *= n; // ^2\n    n *= n; // ^4\n\n    float flicker = mix(0.4, 1.4, noise(dir100));\n    float stars = n * 200.0 * flicker;\n\n    fragColor = vec4(vec3(stars), 1.0);\n}",
    "type": "código"
  },
  {
    "id": "7cc47bd6-fac6-4cde-8a82-772d4c0bf660",
    "title": "Vertex shader toolkit",
    "created_at": "2025-04-02T06:27:08.30053+00:00",
    "content": "//=========================================================================\n// VERTEX TRANSFORM UTILITY LIBRARY - VFX / TECHNICAL ARTISTS\n//=========================================================================\n\n#ifndef VFX_VERTEX_TRANSFORMS_INCLUDED\n#define VFX_VERTEX_TRANSFORMS_INCLUDED\n\n//-----------------------------------------------------------\n// ROTACIONES\n//-----------------------------------------------------------\n\n// Rotación en el eje Z\nfloat2 Rotate2D(float2 pos, float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return float2(pos.x * c - pos.y * s, pos.x * s + pos.y * c);\n}\n\n// Rotación alrededor de eje arbitrario\nfloat3 RotateAroundAxis(float3 pos, float3 axis, float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    float3x3 R =\n    {\n        c + axis.x * axis.x * (1 - c),\n        axis.x * axis.y * (1 - c) - axis.z * s,\n        axis.x * axis.z * (1 - c) + axis.y * s,\n\n        axis.y * axis.x * (1 - c) + axis.z * s,\n        c + axis.y * axis.y * (1 - c),\n        axis.y * axis.z * (1 - c) - axis.x * s,\n\n        axis.z * axis.x * (1 - c) - axis.y * s,\n        axis.z * axis.y * (1 - c) + axis.x * s,\n        c + axis.z * axis.z * (1 - c)\n    };\n    return mul(R, pos);\n}\n\n// Rotación alrededor de un pivote\nfloat3 RotateAroundPivot(float3 pos, float3 pivot, float3 axis, float angle)\n{\n    float3 local = pos - pivot;\n    float3 rotated = RotateAroundAxis(local, axis, angle);\n    return rotated + pivot;\n}\n\n//-----------------------------------------------------------\n// ESCALADO Y TRANSLACIÓN\n//-----------------------------------------------------------\n\nfloat3 ScaleAroundPivot(float3 pos, float3 pivot, float3 scale)\n{\n    return (pos - pivot) * scale + pivot;\n}\n\nfloat3 Translate(float3 pos, float3 offset)\n{\n    return pos + offset;\n}\n\n//-----------------------------------------------------------\n// DEFORMACIONES / OSCILACIONES\n//-----------------------------------------------------------\n\n// Onda senoidal en eje Y\nfloat3 SinWaveY(float3 pos, float frequency, float amplitude, float time)\n{\n    pos.y += sin(pos.x * frequency + time) * amplitude;\n    return pos;\n}\n\n// Wobble XYZ (3D sin wave)\nfloat3 Wobble(float3 pos, float3 freq, float3 amp, float time)\n{\n    pos += sin(pos * freq + time) * amp;\n    return pos;\n}\n\n// Morph entre dos posiciones\nfloat3 MorphPosition(float3 posA, float3 posB, float factor)\n{\n    return lerp(posA, posB, factor);\n}\n\n// Stretch hacia arriba con falloff (útil para FX tipo \"grow\")\nfloat3 VerticalStretch(float3 pos, float heightLimit, float intensity)\n{\n    float t = saturate(pos.y / heightLimit);\n    pos.y += t * intensity;\n    return pos;\n}\n\n//-----------------------------------------------------------\n// NOISE VERTEX OFFSET\n//-----------------------------------------------------------\n\n// Hash rápido\nfloat Hash21(float2 p)\n{\n    p = frac(p * float2(123.34, 456.21));\n    p += dot(p, p + 45.32);\n    return frac(p.x * p.y);\n}\n\n// Simple noise offset en Y\nfloat3 VertexNoiseOffset(float3 pos, float scale, float strength)\n{\n    float2 p = pos.xz * scale;\n    float noise = Hash21(p);\n    pos.y += (noise - 0.5) * strength;\n    return pos;\n}\n\n// Noise animado (ideal para fuego, lava, etc.)\nfloat3 VertexNoiseAnim(float3 pos, float scale, float strength, float time)\n{\n    float2 p = pos.xz * scale + time * 0.5;\n    float noise = Hash21(p);\n    pos.y += (noise - 0.5) * strength;\n    return pos;\n}\n\n//-----------------------------------------------------------\n// TAPER Y SHEAR\n//-----------------------------------------------------------\n\n// Taper: estrecha o ensancha según altura\nfloat3 TaperY(float3 pos, float height, float factor)\n{\n    float t = saturate(pos.y / height);\n    pos.xz *= lerp(1.0, factor, t);\n    return pos;\n}\n\n// Shear XZ basado en altura Y\nfloat3 ShearXZ(float3 pos, float height, float shearAmount)\n{\n    float t = saturate(pos.y / height);\n    pos.x += t * shearAmount;\n    pos.z += t * shearAmount;\n    return pos;\n}\n\n#endif // VFX_VERTEX_TRANSFORMS_INCLUDED",
    "type": "código"
  },
  {
    "id": "245ebab7-793f-4bda-b6c8-05ac1fcec3e7",
    "title": "Postprocess",
    "created_at": "2025-04-02T06:24:00.383718+00:00",
    "content": "//=========================================================================\n// VFX/TECH ARTISTS - HLSL LIBRARY 2 + 5 + 6 + 9\n// Shapes Procedurales + TBN/Parallax + Material FX + Post FX\n//=========================================================================\n\n#ifndef VFX_MATERIAL_UTILS_INCLUDED\n#define VFX_MATERIAL_UTILS_INCLUDED\n\n//=========================================================================\n// 2. SHAPES PROCEDURALES (sin texturas)\n//=========================================================================\n\n// Círculo centrado en UV\nfloat Circle(float2 uv, float2 center, float radius)\n{\n    float d = distance(uv, center);\n    return step(d, radius);\n}\n\n// Círculo suave\nfloat SoftCircle(float2 uv, float2 center, float radius, float softness)\n{\n    float d = distance(uv, center);\n    return smoothstep(radius, radius - softness, d);\n}\n\n// Estrella de 5 puntas\nfloat Star5(float2 uv, float2 center, float size, float sharpness)\n{\n    float2 p = uv - center;\n    float a = atan2(p.y, p.x);\n    float r = length(p);\n    float star = cos(5.0 * a) * sharpness + 0.5;\n    return smoothstep(star * size, star * size - 0.01, r);\n}\n\n// Polígono",
    "type": "código"
  },
  {
    "id": "dd29ea9a-dd13-4574-8106-6089b3a8d59e",
    "title": "Distortion and geo",
    "created_at": "2025-04-02T06:22:24.051298+00:00",
    "content": "//=========================================================================\n// VFX/TECH ARTISTS - MEGA HLSL LIBRARY\n// Distorsión UV + Geometría de Pantalla + Fresnel + Luz + Glitch FX\n//=========================================================================\n\n#ifndef VFX_MEGA_LIB_INCLUDED\n#define VFX_MEGA_LIB_INCLUDED\n\n//=========================================================================\n// 1. DISTORSIÓN UV / PROCEDURAL WARP\n//=========================================================================\n\n// Scroll UV básico\nfloat2 ScrollUV(float2 uv, float2 direction, float speed, float time)\n{\n    return uv + direction * speed * time;\n}\n\n// Onda senoidal\nfloat2 SinWaveDistort(float2 uv, float frequency, float amplitude, float time)\n{\n    uv.y += sin(uv.x * frequency + time) * amplitude;\n    return uv;\n}\n\n// Onda radial (turbulencia circular)\nfloat2 RadialWaveDistort(float2 uv, float2 center, float freq, float amp, float time)\n{\n    float2 offset = uv - center;\n    float r = length(offset);\n    float angle = atan2(offset.y, offset.x);\n    r += sin(angle * freq + time) * amp;\n    return center + float2(cos(angle), sin(angle)) * r;\n}\n\n// Distorsión con ruido simple\nfloat Hash21(float2 p)\n{\n    p = frac(p * float2(123.34, 456.21));\n    p += dot(p, p + 45.32);\n    return frac(p.x * p.y);\n}\n\nfloat ValueNoise(float2 uv)\n{\n    float2 i = floor(uv);\n    float2 f = frac(uv);\n    float a = Hash21(i);\n    float b = Hash21(i + float2(1, 0));\n    float c = Hash21(i + float2(0, 1));\n    float d = Hash21(i + float2(1, 1));\n    float2 u = f * f * (3.0 - 2.0 * f);\n    return lerp(lerp(a, b, u.x), lerp(c, d, u.x), u.y);\n}\n\nfloat2 NoiseWarpUV(float2 uv, float scale, float strength, float time)\n{\n    float2 n = float2(\n        ValueNoise(uv * scale + float2(0, time)),\n        ValueNoise(uv * scale + float2(5.2, time + 1.0))\n    );\n    return uv + (n - 0.5) * strength;\n}\n\n//=========================================================================\n// 3. GEOMETRÍA DE PANTALLA / UV TOOLS\n//=========================================================================\n\n// Coordenadas centradas (-1 a 1)\nfloat2 CenteredUV(float2 uv)\n{\n    return uv * 2.0 - 1.0;\n}\n\n// Distancia al centro\nfloat DistanceToCenter(float2 uv)\n{\n    return length(CenteredUV(uv));\n}\n\n// Máscara de borde (falloff hacia los lados)\nfloat EdgeMask(float2 uv, float thickness)\n{\n    float2 edge = min(uv, 1.0 - uv);\n    return smoothstep(thickness, 0.0, min(edge.x, edge.y));\n}\n\n// Coordenadas NDC (si se requiere)\nfloat2 NDCFromUV(float2 uv)\n{\n    return uv * 2.0 - 1.0;\n}\n\n// Mapa de dirección hacia el centro (vector unitario)\nfloat2 DirectionToCenter(float2 uv)\n{\n    return normalize(0.5 - uv);\n}\n\n//=========================================================================\n// 4. FRESNEL / CURVATURA\n//=========================================================================\n\n// Fresnel básico\nfloat FresnelBasic(float3 normal, float3 viewDir)\n{\n    return 1.0 - saturate(dot(normalize(normal), normalize(viewDir)));\n}\n\n// Fresnel con power y bias\nfloat FresnelAdvanced(float3 normal, float3 viewDir, float power, float bias)\n{\n    float f = 1.0 - saturate(dot(normalize(normal), normalize(viewDir)));\n    return pow(f, power) + bias;\n}\n\n// Curvatura simple usando diferencia entre normal y view\nfloat NormalCurvatureMask(float3 normal, float3 refNormal)\n{\n    return saturate(1.0 - dot(normalize(normal), normalize(refNormal)));\n}\n\n// Edge highlight por curvatura\nfloat EdgeHighlight(float3 normal, float3 viewDir, float power)\n{\n    float f = 1.0 - dot(normalize(normal), normalize(viewDir));\n    return pow(f, power);\n}\n\n//=========================================================================\n// 7. LUZ PROCEDURAL / SHADING CUSTOM\n//=========================================================================\n\n// Luz direccional simulada\nfloat SimulatedDirectionalLight(float3 normal, float3 lightDir)\n{\n    return saturate(dot(normalize(normal), normalize(lightDir)));\n}\n\n// Luz puntual simulada (basada en distancia)\nfloat SimulatedPointLight(float3 worldPos, float3 lightPos, float3 normal)\n{\n    float3 toLight = lightPos - worldPos;\n    float d = length(toLight);\n    float3 L = normalize(toLight);\n    float NdotL = saturate(dot(normal, L));\n    return NdotL / (d * d); // iluminación realista con caída\n}\n\n// Luz esférica suave (ideal para UI o FX en pantalla)\nfloat SphereLight(float2 uv, float2 center, float radius)\n{\n    float dist = distance(uv, center);\n    return smoothstep(radius, 0.0, dist);\n}\n\n// Sombra UV simulada\nfloat UVShadow(float2 uv, float2 lightDir, float softness)\n{\n    float n = dot(normalize(uv - 0.5), normalize(lightDir));\n    return smoothstep(0.0, softness, n);\n}\n\n//=========================================================================\n// 8. GLITCH FX / ERRORES VISUALES\n//=========================================================================\n\n// Separación de canales RGB (glitch tipo VHS)\nfloat2 RGBOffset(float2 uv, float time, float intensity, float channelOffset)\n{\n    float offset = sin(time * 20.0 + uv.y * 100.0) * intensity;\n    return uv + float2(channelOffset * offset, 0.0);\n}\n\n// Salto UV (tipo flicker o salto de línea)\nfloat2 UVJump(float2 uv, float time, float intensity)\n{\n    float glitch = step(0.95, frac(sin(dot(uv, float2(12.989, 78.233)) + time) * 43758.5453));\n    return uv + float2(0.0, glitch * intensity);\n}\n\n// Scanlines animadas\nfloat Scanlines(float2 uv, float time, float frequency, float thickness)\n{\n    float line = sin(uv.y * frequency + time * 20.0);\n    return smoothstep(thickness, 0.0, abs(line));\n}\n\n// Glitch temporal (fade in/out tipo error)\nfloat TemporalGlitch(float time, float speed, float duration)\n{\n    float t = frac(time * speed);\n    return step(t, duration);\n}\n\n#endif // VFX_MEGA_LIB_INCLUDED",
    "type": "código"
  },
  {
    "id": "5d95dfe9-d816-4ee5-8391-05d69f915e50",
    "title": "Time library",
    "created_at": "2025-04-02T06:12:08.567279+00:00",
    "content": "//===========================================================\n// TIME UTILITY LIBRARY - VFX / TECHNICAL ARTISTS\n// Usando i.fTime como base de tiempo\n//===========================================================\n\n#ifndef TIME_UTILS_INCLUDED\n#define TIME_UTILS_INCLUDED\n\n//-----------------------------------------------------------\n// Tiempo normalizado cíclico [0 → 1]\n// Ideal para loops de animación\n//-----------------------------------------------------------\nfloat Time01(float time, float speed)\n{\n    return frac(time * speed);\n}\n\n//-----------------------------------------------------------\n// Tiempo senoidal suave entre 0 y 1\n// Oscila suavemente - ideal para efectos respirantes o pulsantes\n//-----------------------------------------------------------\nfloat SineTime01(float time, float speed)\n{\n    return sin(time * speed) * 0.5 + 0.5;\n}\n\n//-----------------------------------------------------------\n// PingPong (triángulo) entre 0 y 1\n// Útil para efectos que deben ir y volver\n//-----------------------------------------------------------\nfloat PingPong(float time, float speed)\n{\n    return abs(frac(time * speed) * 2.0 - 1.0);\n}\n\n//-----------------------------------------------------------\n// Onda triangular suavizada (para parpadeos, loops simétricos)\n//-----------------------------------------------------------\nfloat TriangleWave(float time, float speed)\n{\n    return abs(frac(time * speed + 0.5) * 2.0 - 1.0);\n}\n\n//-----------------------------------------------------------\n// Pulso repetitivo (ideal para flashes, glitches...)\n// Devuelve 1 solo durante un tramo del ciclo\n//-----------------------------------------------------------\nfloat PulseLoop(float time, float speed, float width)\n{\n    float t = frac(time * speed);\n    return step(t, width); // Ejemplo: width = 0.1 → pulso breve\n}\n\n//-----------------------------------------------------------\n// Oscilador entre dos valores\n//-----------------------------------------------------------\nfloat Oscillate(float minVal, float maxVal, float time, float speed)\n{\n    float t = SineTime01(time, speed);\n    return lerp(minVal, maxVal, t);\n}\n\n//-----------------------------------------------------------\n// Ramp-Up Loop: sube de 0 a 1, luego se queda en 1 por un tiempo\n//-----------------------------------------------------------\nfloat RampHoldLoop(float time, float speed, float holdRatio)\n{\n    float t = frac(time * speed);\n    float rise = 1.0 - holdRatio;\n    return t < rise ? t / rise : 1.0;\n}\n\n//-----------------------------------------------------------\n// Delay temporal por fragmento (útil para efectos secuenciales)\n//-----------------------------------------------------------\nfloat TimeWithDelay(float time, float delay)\n{\n    return max(0.0, time - delay);\n}\n\n//-----------------------------------------------------------\n// Fase desincronizada por UV o World Position\n// Perfecto para que cada píxel haga el efecto en distinto momento\n//-----------------------------------------------------------\nfloat DesyncByCoord(float2 uv, float time, float speed, float spread)\n{\n    float offset = frac(dot(uv, float2(12.9898, 78.233))) * spread;\n    return frac((time + offset) * speed);\n}\n\n#endif // TIME_UTILS_INCLUDED",
    "type": "código"
  },
  {
    "id": "57b07ed6-96c1-41c8-8ee8-16b52c5ab250",
    "title": "Masks library",
    "created_at": "2025-04-01T21:59:41.320255+00:00",
    "content": "//===========================================================\n// HLSL MASK LIBRARY - EXTENDED\n//===========================================================\n\n#ifndef VFX_MASKS_INCLUDED\n#define VFX_MASKS_INCLUDED\n\n//-----------------------------------------------------------\n// UTILIDADES BÁSICAS\n//-----------------------------------------------------------\n\n// Clamp suave entre 0–1\nfloat Saturate(float x) {\n    return clamp(x, 0.0, 1.0);\n}\n\n// Interpolación suave Hermite (usado en soft masks)\nfloat SmoothStep(float edge0, float edge1, float x) {\n    float t = saturate((x - edge0) / (edge1 - edge0));\n    return t * t * (3.0 - 2.0 * t);\n}\n\n// Pulse entre dos rangos\nfloat Pulse(float edge0, float edge1, float x) {\n    return step(edge0, x) - step(edge1, x);\n}\n\n// Distancia UV al centro\nfloat DistToCenter(float2 uv, float2 center) {\n    return distance(uv, center);\n}\n\nfloat DistToEdge(float2 uv) {\n    float2 d = min(uv, 1.0 - uv);\n    return min(d.x, d.y);\n}\n\n//-----------------------------------------------------------\n// FORMAS BÁSICAS\n//-----------------------------------------------------------\n\n// Máscara circular\nfloat CircleMask(float2 uv, float2 center, float radius) {\n    float d = distance(uv, center);\n    return step(d, radius);\n}\n\n// Círculo suave (falloff)\nfloat SoftCircleMask(float2 uv, float2 center, float radius, float softness) {\n    float d = distance(uv, center);\n    return smoothstep(radius, radius - softness, d);\n}\n\n// Rectángulo centrado (sin rotación)\nfloat BoxMask(float2 uv, float2 center, float2 size) {\n    float2 diff = abs(uv - center);\n    float2 halfSize = size * 0.5;\n    return step(diff.x, halfSize.x) * step(diff.y, halfSize.y);\n}\n\n// Rectángulo con bordes suaves\nfloat SoftBoxMask(float2 uv, float2 center, float2 size, float softness) {\n    float2 diff = abs(uv - center);\n    float2 halfSize = size * 0.5;\n    float2 edge = smoothstep(halfSize, halfSize - softness, diff);\n    return edge.x * edge.y;\n}\n\n// Línea horizontal con grosor\nfloat LineMask(float2 uv, float y, float thickness) {\n    return step(abs(uv.y - y), thickness * 0.5);\n}\n\n// Línea suave\nfloat SoftLineMask(float2 uv, float y, float thickness, float softness) {\n    float d = abs(uv.y - y);\n    return smoothstep(thickness * 0.5 + softness, thickness * 0.5, d);\n}\n\n//-----------------------------------------------------------\n// FORMAS AVANZADAS\n//-----------------------------------------------------------\n\n// Anillo\nfloat RingMask(float2 uv, float2 center, float radius, float thickness) {\n    float d = distance(uv, center);\n    return step(abs(d - radius), thickness * 0.5);\n}\n\n// Anillo suave\nfloat SoftRingMask(float2 uv, float2 center, float radius, float thickness, float softness) {\n    float d = distance(uv, center);\n    float outer = smoothstep(radius + thickness * 0.5, radius + thickness * 0.5 - softness, d);\n    float inner = smoothstep(radius - thickness * 0.5, radius - thickness * 0.5 + softness, d);\n    return outer * inner;\n}\n\n// Máscara radial (de centro a borde)\nfloat RadialGradient(float2 uv, float2 center) {\n    return saturate(distance(uv, center));\n}\n\n// Máscara radial invertida\nfloat InvertedRadial(float2 uv, float2 center) {\n    return 1.0 - RadialGradient(uv, center);\n}\n\n// Máscara tipo borde\nfloat EdgeMask(float2 uv, float thickness) {\n    float edge = min(min(uv.x, 1.0 - uv.x), min(uv.y, 1.0 - uv.y));\n    return step(thickness, edge);\n}\n\n//-----------------------------------------------------------\n// MÁSCARAS ANIMADAS\n//-----------------------------------------------------------\n\n// Wipe horizontal\nfloat HorizontalWipe(float2 uv, float progress) {\n    return step(uv.x, progress);\n}\n\n// Wipe radial (reloj)\nfloat RadialWipe(float2 uv, float2 center, float progress) {\n    float2 dir = normalize(uv - center);\n    float angle = atan2(dir.y, dir.x) / (2.0 * 3.14159) + 0.5;\n    return step(angle, progress);\n}\n\n// Máscara con ruido\nfloat NoisyMask(float2 uv, float noiseValue, float threshold, float softness) {\n    return smoothstep(threshold, threshold - softness, noiseValue);\n}\n\n//-----------------------------------------------------------\n// MÁSCARAS EN ESPACIO WORLD / PERSONALIZADO\n//-----------------------------------------------------------\n\n// Máscara basada en altura (eje Y)\nfloat HeightMask(float3 worldPos, float height, float falloff) {\n    return smoothstep(height, height - falloff, worldPos.y);\n}\n\n// Máscara por proyección planar Y\nfloat PlanarYMask(float3 worldPos, float centerY, float range, float falloff) {\n    float d = abs(worldPos.y - centerY);\n    return smoothstep(range, range - falloff, d);\n}\n\n// Máscara por distancia a un punto en mundo\nfloat WorldDistanceMask(float3 worldPos, float3 worldCenter, float radius, float softness) {\n    float d = distance(worldPos, worldCenter);\n    return smoothstep(radius, radius - softness, d);\n}\n\n//-----------------------------------------------------------\n// MÁSCARA MODULADA / COMBINADA\n//-----------------------------------------------------------\n\n// Combine (AND lógico)\nfloat CombineAND(float a, float b) {\n    return a * b;\n}\n\n// Combine (OR lógico)\nfloat CombineOR(float a, float b) {\n    return saturate(a + b);\n}\n\n// Combine (XOR lógico visual)\nfloat CombineXOR(float a, float b) {\n    return abs(a - b);\n}\n\n// Interpolación entre dos máscaras\nfloat BlendMasks(float a, float b, float blend) {\n    return lerp(a, b, blend);\n}\n\n#endif // VFX_MASKS_INCLUDED",
    "type": "código"
  },
  {
    "id": "e0315988-7742-41bd-9e26-24a8ab9cb5b1",
    "title": "Utility Library",
    "created_at": "2025-04-01T21:56:28.250214+00:00",
    "content": "//====================================================================\n// HLSL UTILITY LIBRARY - TECHNICAL & VFX ARTISTS v2\n//====================================================================\n\n#ifndef VFX_UTILS_INCLUDED\n#define VFX_UTILS_INCLUDED\n\n//--------------------------------------------------\n// REMAP / INTERPOLACIONES\n//--------------------------------------------------\n\nfloat Remap(float v, float inMin, float inMax, float outMin, float outMax) {\n    return outMin + (v - inMin) * (outMax - outMin) / (inMax - inMin);\n}\n\nfloat RemapClamped(float v, float inMin, float inMax, float outMin, float outMax) {\n    float t = saturate((v - inMin) / (inMax - inMin));\n    return lerp(outMin, outMax, t);\n}\n\nfloat InverseLerp(float a, float b, float v) {\n    return saturate((v - a) / (b - a));\n}\n\nfloat EaseIn(float t)    { return t * t; }\nfloat EaseOut(float t)   { return 1.0 - pow(1.0 - t, 2.0); }\nfloat EaseInOut(float t) { return lerp(t*t, 1.0 - pow(1.0 - t, 2.0), step(0.5, t)); }\n\nfloat SmoothLerp(float a, float b, float t) {\n    t = t * t * (3.0 - 2.0 * t); // Hermite\n    return lerp(a, b, t);\n}\n\n//--------------------------------------------------\n// PROYECCIONES UV\n//--------------------------------------------------\n\n// Planar Projection\nfloat2 ProjectPlanar(float3 pos, float3 axisU, float3 axisV) {\n    return float2(dot(pos, axisU), dot(pos, axisV));\n}\n\n// Triplanar Projection (sin blending)\nfloat2 TriplanarUV(float3 pos, float3 normal, out float3 weights) {\n    float3 absN = abs(normal);\n    weights = absN / (absN.x + absN.y + absN.z);\n    return pos.yz; // ejemplo para eje Y, ajusta según blend deseado\n}\n\n// Cylindrical Projection\nfloat2 ProjectCylindrical(float3 pos) {\n    float angle = atan2(pos.z, pos.x);\n    float u = (angle + 3.14159) / (2.0 * 3.14159);\n    float v = pos.y;\n    return float2(u, v);\n}\n\n// Spherical Projection\nfloat2 ProjectSpherical(float3 pos) {\n    float3 n = normalize(pos);\n    float u = 0.5 + atan2(n.z, n.x) / (2.0 * 3.14159);\n    float v = 0.5 - asin(n.y) / 3.14159;\n    return float2(u, v);\n}\n\n//--------------------------------------------------\n// RUIDOS - ORDENADOS DE MÁS BARATO A MÁS CARO\n//--------------------------------------------------\n\n//--- 1. Hash noise (barato, sin continuidad) ---\nfloat Hash21(float2 p) {\n    p = frac(p * float2(123.34, 456.21));\n    p += dot(p, p + 45.32);\n    return frac(p.x * p.y);\n}\n\n//--- 2. Value Noise 2D (barato, interpolado) ---\nfloat ValueNoise(float2 uv) {\n    float2 i = floor(uv);\n    float2 f = frac(uv);\n    float a = Hash21(i);\n    float b = Hash21(i + float2(1, 0));\n    float c = Hash21(i + float2(0, 1));\n    float d = Hash21(i + float2(1, 1));\n    float2 u = f * f * (3.0 - 2.0 * f);\n    return lerp(lerp(a, b, u.x), lerp(c, d, u.x), u.y);\n}\n\n//--- 3. Perlin Noise 2D (más costoso, continuo) ---\nfloat2 Fade(float2 t) {\n    return t * t * (3.0 - 2.0 * t);\n}\n\nfloat Grad2(float2 p, float2 ip) {\n    float2 gradient = normalize(frac(sin(dot(ip, float2(127.1, 311.7))) * 43758.5453) * 2.0 - 1.0);\n    return dot(p, gradient);\n}\n\nfloat PerlinNoise(float2 uv) {\n    float2 i = floor(uv);\n    float2 f = frac(uv);\n\n    float a = Grad2(f, i);\n    float b = Grad2(f - float2(1, 0), i + float2(1, 0));\n    float c = Grad2(f - float2(0, 1), i + float2(0, 1));\n    float d = Grad2(f - float2(1, 1), i + float2(1, 1));\n\n    float2 u = Fade(f);\n    return lerp(lerp(a, b, u.x), lerp(c, d, u.x), u.y);\n}\n\n//--- 4. Gaussian Noise (para desenfoques o distorsión sutil) ---\nfloat Gaussian(float2 uv, float2 center, float sigma) {\n    float2 diff = uv - center;\n    float r2 = dot(diff, diff);\n    return exp(-r2 / (2.0 * sigma * sigma));\n}\n\n//--------------------------------------------------\n// MÁSCARAS / FORMAS\n//--------------------------------------------------\n\nfloat CircleMask(float2 uv, float2 center, float radius, float softness) {\n    float d = distance(uv, center);\n    return smoothstep(radius, radius - softness, d);\n}\n\nfloat RingMask(float2 uv, float2 center, float radius, float thickness, float softness) {\n    float d = distance(uv, center);\n    float outer = smoothstep(radius, radius - softness, d);\n    float inner = smoothstep(radius - thickness, radius - thickness - softness, d);\n    return outer * (1.0 - inner);\n}\n\nfloat SoftMask(float mask, float threshold, float softness) {\n    return smoothstep(threshold, threshold - softness, mask);\n}\n\n//--------------------------------------------------\n// ANIMACIONES / EFECTOS TIEMPO\n//--------------------------------------------------\n\nfloat Oscillate(float minVal, float maxVal, float time, float speed) {\n    float t = sin(time * speed) * 0.5 + 0.5;\n    return lerp(minVal, maxVal, t);\n}\n\nfloat TriangleWave(float t) {\n    return abs(frac(t + 0.5) * 2.0 - 1.0);\n}\n\nfloat Pulse(float edge0, float edge1, float x) {\n    return step(edge0, x) - step(edge1, x);\n}\n\n//--------------------------------------------------\n// COLOR\n//--------------------------------------------------\n\nfloat3 HSVtoRGB(float3 hsv) {\n    float3 K = float3(1.0, 2.0 / 3.0, 1.0 / 3.0);\n    float3 P = abs(frac(hsv.xxx + K.xyz) * 6.0 - 3.0);\n    return hsv.z * lerp(K.xxx, saturate(P - K.xxx), hsv.y);\n}\n\nfloat3 RGBtoHSV(float3 c) {\n    float4 K = float4(0., -1./3., 2./3., -1.);\n    float4 p = (c.g < c.b) ? float4(c.bg, K.wz) : float4(c.gb, K.xy);\n    float4 q = (c.r < p.x) ? float4(p.xyw, c.r) : float4(c.r, p.yzx);\n    float d = q.x - min(q.w, q.y);\n    float e = 1e-10;\n    return float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n#endif // VFX_UTILS_INCLUDED",
    "type": "código"
  },
  {
    "id": "193a1eff-8d79-4708-a78e-ca1e2e5894c2",
    "title": "Funciones hlsl mas usadas",
    "created_at": "2025-04-01T21:48:57.925052+00:00",
    "content": "//==============================\n// FUNCIONES HLSL MÁS USADAS\n//==============================\n\n//----- MATH BÁSICA -----\nfloat a = abs(-2.5);             // valor absoluto\nfloat b = ceil(1.3);             // redondea hacia arriba\nfloat c = floor(1.9);            // redondea hacia abajo\nfloat d = frac(3.75);            // parte decimal (0.75)\nfloat e = fmod(5.2, 2.0);        // módulo decimal (1.2)\nfloat f = clamp(1.5, 0.0, 1.0);  // limita entre 0 y 1\nfloat g = lerp(0.0, 1.0, 0.5);   // interpolación lineal (0.5)\nfloat h = min(2.0, 3.0);         // 2.0\nfloat i = max(5.0, 4.0);         // 5.0\nfloat j = saturate(x);           // clamp entre 0 y 1\n\n//----- RAMPAS / CONTROL -----\nfloat s1 = step(0.5, 0.3);                 // 0.0 (x < edge)\nfloat s2 = smoothstep(0.2, 0.8, 0.5);      // rampa suave\nfloat s3 = sign(-5.0);                     // -1\nfloat s4 = isnan(value);                  // 1 si es NaN\n\n//----- TRIGONOMETRÍA -----\nfloat t1 = sin(3.14);\nfloat t2 = cos(0.0);\nfloat t3 = tan(1.0);\nfloat t4 = asin(1.0);\nfloat t5 = acos(0.0);\nfloat t6 = atan2(y, x); // ángulo entre (x, y)\n\n//----- POTENCIAS Y LOGARITMOS -----\nfloat p1 = pow(2.0, 3.0);  // 8\nfloat p2 = sqrt(25.0);     // 5\nfloat p3 = rsqrt(25.0);    // 1 / sqrt(25) = 0.2\nfloat p4 = exp(1.0);       // e^1\nfloat p5 = log(2.71828);   // loge\n\n//----- VECTORES -----\nfloat len = length(float3(1, 2, 2));           // magnitud\nfloat dist = distance(a, b);                   // distancia\nfloat3 norm = normalize(float3(1, 2, 3));      // vector normalizado\nfloat dp = dot(a, b);                          // producto punto\nfloat3 cr = cross(float3(1,0,0), float3(0,1,0));// producto cruzado\nfloat3 ref = reflect(-viewDir, normal);        // reflexión\nfloat3 refr = refract(viewDir, normal, 1.0);   // refracción\nfloat3 face = faceforward(n, i, ng);           // orienta una normal hacia la cámara\n\n//----- TEXTURAS -----\nTexture2D tex : register(t0);\nSamplerState samp : register(s0);\nfloat4 col = tex.Sample(samp, uv);                 // sampleo normal\nfloat4 colBias = tex.SampleBias(samp, uv, -1.0);   // con bias\nfloat4 colGrad = tex.SampleGrad(samp, uv, dx, dy); // con gradiente manual\nfloat4 colLOD = tex.SampleLevel(samp, uv, 2.0);     // sample mip específico\nfloat2 texSize; tex.GetDimensions(texSize.x, texSize.y);\n\n//----- COLORES -----\nfloat3 hsv = float3(0.6, 1.0, 1.0); // ejemplo color HSV\nfloat3 rgb = hsv2rgb(hsv);          // si defines tú mismo esta función\nfloat3 gray = float3(0.5.xxx);      // gris neutro\n\n//----- UV / ANIMACIÓN -----\nfloat wave = sin(uv.x * 10.0 + time * 5.0);    // animación senoidal\nfloat2 scrollUV = uv + time * 0.1;            // scrolling\nfloat2 polar = float2(cos(a), sin(a));        // dirección circular\nfloat ripple = sin(distance(uv, center) * 20.0 - time * 5.0); // onda radial\n\n//----- RUIDO BÁSICO -----\nfloat hash(float2 p)\n{\n    return frac(sin(dot(p, float2(127.1, 311.7))) * 43758.5453);\n}\n\nfloat noise(float2 uv)\n{\n    float2 i = floor(uv);\n    float2 f = frac(uv);\n\n    float a = hash(i);\n    float b = hash(i + float2(1, 0));\n    float c = hash(i + float2(0, 1));\n    float d = hash(i + float2(1, 1));\n\n    float2 u = f * f * (3.0 - 2.0 * f); // fade\n\n    return lerp(lerp(a, b, u.x), lerp(c, d, u.x), u.y);\n}\n\n//----- PARALLAX OFFSET (básico) -----\nfloat height = heightMap.Sample(samp, uv).r;\nfloat2 parallaxOffset = viewDirTS.xy * height * intensity;\nfloat2 uvOffset = uv + parallaxOffset;",
    "type": "código"
  },
  {
    "id": "b8e04b67-f75f-4f2b-8f7d-f0d42cb325b3",
    "title": "Parallax mapping basico",
    "created_at": "2025-04-01T21:43:35.177911+00:00",
    "content": "float height = heightTex.Sample(sampler, uv).r;\nfloat2 offset = viewDirTS.xy * height * intensity;\nfloat2 newUV = uv + offset;",
    "type": "código"
  },
  {
    "id": "d24e3da0-cf5e-4046-9c6c-ff17dd3e7102",
    "title": "Treshold",
    "created_at": "2025-04-01T21:42:33.145036+00:00",
    "content": "Texture2D maskTex : register(t0);\nSamplerState maskSampler : register(s0);\n\nfloat threshold = 0.5;\n\nfloat4 PS_Main(float4 pos : SV_POSITION, float2 uv : TEXCOORD0) : SV_TARGET\n{\n    float mask = maskTex.Sample(maskSampler, uv).r;\n    float masked = step(threshold, mask);\n    return float4(masked.xxx, 1.0); // Blanco si mayor a threshold\n}",
    "type": "código"
  },
  {
    "id": "cd9d1012-6400-4faa-bc38-f565bec1c5e1",
    "title": "Solid Color",
    "created_at": "2025-04-01T21:41:35.893949+00:00",
    "content": "float4 PS_Main(float4 pos : SV_POSITION) : SV_TARGET\n{\n    return float4(1.0, 0.0, 0.0, 1.0); // Color rojo\n}",
    "type": "código"
  },
  {
    "id": "66607c43-d45b-4b71-9131-5fd1578fbbe3",
    "title": "Code Test",
    "created_at": "2025-04-01T20:34:40.582093+00:00",
    "content": "// Transformamos la dirección del visor de world space a tangent space\nfloat3 viewDirTS = mul(TBN, viewDirWS);\n\n// Calculamos un factor de escala basado en cuán inclinado es el ángulo de visión\n// viewDirTS.z es cuánto \"miramos de frente\"; si es bajo, estamos mirando en ángulo\n// En lugar de dividir por z, usamos (1 - z) como multiplicador para simular ese efecto\nfloat scale = saturate(1.0 - viewDirTS.z); // saturate asegura que el valor esté entre 0 y 1\n\n// Calculamos el desplazamiento de parallax multiplicando por ese factor\nfloat2 parallaxOffset = viewDirTS.xy * height * height_intensity * scale;\n\n// Sumamos el desplazamiento a las UV originales\nreturn uv + parallaxOffset;",
    "type": "código"
  }
]